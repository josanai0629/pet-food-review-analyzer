<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ペットフードレビュー分析ツール</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .upload-area {
            border: 2px dashed #4CAF50;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin: 20px 0;
            background-color: #f9f9f9;
            transition: all 0.3s;
        }
        .upload-area:hover {
            background-color: #e8f5e9;
        }
        .upload-area.dragover {
            background-color: #c8e6c9;
            border-color: #2E7D32;
        }
        .file-input {
            display: none;
        }
        .upload-button {
            background-color: #4CAF50;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
            transition: background-color 0.3s;
        }
        .upload-button:hover {
            background-color: #45a049;
        }
        .progress {
            margin: 20px 0;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .stats {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .sentiment-summary {
            margin: 20px 0;
            padding: 15px;
            background-color: #e3f2fd;
            border-radius: 5px;
            border-left: 4px solid #2196F3;
        }
        .sample-results {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            max-height: 300px;
            overflow-y: auto;
        }
        .result-item {
            margin: 10px 0;
            padding: 10px;
            background-color: white;
            border-radius: 5px;
            border-left: 4px solid #4CAF50;
        }
        .error {
            color: #d32f2f;
            font-weight: bold;
        }
        .success {
            color: #388e3c;
            font-weight: bold;
        }
        .file-list {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #e0e0e0;
        }
        .file-item:last-child {
            border-bottom: none;
        }
        .remove-file {
            background-color: #f44336;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .remove-file:hover {
            background-color: #d32f2f;
        }
        .debug-button {
            background-color: #ff9800;
            margin-left: 10px;
        }
        .debug-button:hover {
            background-color: #f57c00;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>ペットフードレビュー分析ツール</h1>
        
        <div class="upload-area" id="uploadArea">
            <p>ここにExcelファイルをドラッグ&ドロップ<br>または</p>
            <input type="file" id="fileInput" class="file-input" accept=".xlsx,.xls" multiple>
            <label for="fileInput" class="upload-button">ファイルを選択</label>
            <p style="margin-top: 20px; font-size: 14px; color: #666;">
                必要なファイル：<br>
                1. Raw_Review.xlsx（レビューデータ）<br>
                2. Master.xlsx（ラベルマスター）※オプション
            </p>
        </div>

        <div id="fileList" class="file-list" style="display: none;">
            <h3>アップロードされたファイル</h3>
            <div id="fileItems"></div>
        </div>
        
        <div id="status" class="progress" style="display: none;">
            ファイルを読み込んでください
        </div>

        <div style="text-align: center;">
            <button onclick="processData()" id="processBtn" style="display: none;">データ処理を開始</button>
            <button onclick="debugDateData()" id="debugBtn" class="debug-button" style="display: none;">日付データをデバッグ</button>
            <button onclick="downloadExcel()" id="downloadBtn" disabled>Excelファイルをダウンロード</button>
        </div>

        <div id="stats" class="stats" style="display: none;">
            <h3>処理統計</h3>
            <div id="statsContent"></div>
        </div>

        <div id="sentimentSummary" class="sentiment-summary" style="display: none;">
            <h3>センチメント分析サマリー</h3>
            <div id="sentimentContent"></div>
        </div>

        <div id="sampleResults" class="sample-results" style="display: none;">
            <h3>処理結果サンプル</h3>
            <div id="sampleContent"></div>
        </div>
    </div>

    <script>
        let processedData = null;
        let rawData = null;
        let masterLabels = [
            '食べる', '食べない', '吐き戻し・便の改善', 'その他', '安い',
            '配送・梱包', '高い・値上げ', '吐く・便が悪くなる', '賞味期限', 'ジッパーが欲しい'
        ];
        let uploadedFiles = {};
        let sentimentDataList = [];

        // ドラッグ&ドロップの設定
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });

        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
        });

        function handleFiles(files) {
            Array.from(files).forEach(file => {
                if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        uploadedFiles[file.name] = {
                            name: file.name,
                            data: e.target.result
                        };
                        updateFileList();
                        checkFiles();
                    };
                    reader.readAsArrayBuffer(file);
                }
            });
        }

        function updateFileList() {
            const fileList = document.getElementById('fileList');
            const fileItems = document.getElementById('fileItems');
            
            if (Object.keys(uploadedFiles).length > 0) {
                fileList.style.display = 'block';
                fileItems.innerHTML = '';
                
                Object.values(uploadedFiles).forEach(file => {
                    const item = document.createElement('div');
                    item.className = 'file-item';
                    item.innerHTML = `
                        <span>${file.name}</span>
                        <button class="remove-file" onclick="removeFile('${file.name}')">削除</button>
                    `;
                    fileItems.appendChild(item);
                });
            } else {
                fileList.style.display = 'none';
            }
        }

        function removeFile(fileName) {
            delete uploadedFiles[fileName];
            updateFileList();
            checkFiles();
        }

        function checkFiles() {
            const hasRawReview = Object.keys(uploadedFiles).some(name => 
                name.toLowerCase().includes('raw_review') || name.toLowerCase().includes('review')
            );
            
            if (hasRawReview) {
                document.getElementById('processBtn').style.display = 'inline-block';
                document.getElementById('debugBtn').style.display = 'inline-block';
                document.getElementById('status').style.display = 'block';
                document.getElementById('status').textContent = '処理準備完了';
                
                // Master.xlsxがある場合は読み込む
                const masterFile = Object.values(uploadedFiles).find(file => 
                    file.name.toLowerCase().includes('master')
                );
                if (masterFile) {
                    const workbook = XLSX.read(masterFile.data);
                    const sheet = workbook.Sheets[workbook.SheetNames[0]];
                    const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                    masterLabels = data.map(row => row[0]).filter(label => label);
                }
            } else {
                document.getElementById('processBtn').style.display = 'none';
                document.getElementById('debugBtn').style.display = 'none';
                document.getElementById('status').style.display = 'none';
            }
        }

        // 修正された日付解析関数
        function parseDate(dateStr) {
            if (!dateStr) return { year: '', month: '', yearMonth: '', quarter: '' };
            
            console.log('入力された日付データ:', dateStr, 'タイプ:', typeof dateStr);
            
            let date = null;
            
            // 1. Excelシリアル値の場合（数値で25569以上の値）
            if (typeof dateStr === 'number' && dateStr > 25569) { // 1970/1/1以降
                // Excelシリアル値をJavaScript日付に変換
                // Excelは1900/1/1を1とするが、JavaScriptは1970/1/1が基準
                const excelEpoch = new Date(1899, 11, 30); // 1899/12/30
                date = new Date(excelEpoch.getTime() + dateStr * 24 * 60 * 60 * 1000);
            }
            // 2. 「2024年1月」形式
            else if (typeof dateStr === 'string') {
                const yearMonthMatch = dateStr.match(/(\d{4})年(\d{1,2})月/);
                if (yearMonthMatch) {
                    const year = parseInt(yearMonthMatch[1]);
                    const month = parseInt(yearMonthMatch[2]);
                    date = new Date(year, month - 1, 1);
                }
                // 3. 「2024/1/15」「2024-01-15」などの一般的な形式
                else {
                    // 文字列を標準的な日付として解析を試行
                    const normalizedDate = dateStr.replace(/[年月日]/g, '/').replace(/-/g, '/');
                    const testDate = new Date(normalizedDate);
                    if (!isNaN(testDate.getTime())) {
                        date = testDate;
                    }
                }
            }
            
            // 日付オブジェクトが有効な場合の処理
            if (date && !isNaN(date.getTime())) {
                const year = date.getFullYear().toString();
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                const monthNum = parseInt(month);
                const quarter = `${year}Q${Math.ceil(monthNum / 3)}`;
                
                const result = {
                    year: year,
                    month: month,
                    yearMonth: `${year}年${month}月`,
                    quarter: quarter
                };
                
                console.log('解析結果:', result);
                return result;
            }
            
            console.log('日付解析失敗:', dateStr);
            return { year: '', month: '', yearMonth: '', quarter: '' };
        }

        // デバッグ用の関数
        function debugDateData() {
            if (!rawData || rawData.length < 2) {
                const rawReviewFile = Object.values(uploadedFiles).find(file => 
                    file.name.toLowerCase().includes('raw_review') || file.name.toLowerCase().includes('review')
                );
                
                if (!rawReviewFile) {
                    alert('レビューデータファイルが見つかりません');
                    return;
                }
                
                const rawWorkbook = XLSX.read(rawReviewFile.data);
                const rawSheet = rawWorkbook.Sheets[rawWorkbook.SheetNames[0]];
                rawData = XLSX.utils.sheet_to_json(rawSheet, { header: 1 });
            }
            
            console.log('=== 日付データのデバッグ情報 ===');
            console.log('ヘッダー:', rawData[0]);
            
            // 最初の10行のB列データを確認
            for (let i = 1; i <= Math.min(10, rawData.length - 1); i++) {
                const dateValue = rawData[i][1]; // B列
                console.log(`${i}行目 B列:`, dateValue, 'タイプ:', typeof dateValue);
                
                if (dateValue) {
                    const parsed = parseDate(dateValue);
                    console.log(`  → 解析結果:`, parsed);
                }
            }
            
            alert('コンソールを確認してください。F12を押してConsoleタブを見てください。');
        }

        // 改良されたラベル検出関数（K列の実データに基づく改善版）
        function detectLabels(reviewText) {
            if (!reviewText) return 'その他';
            const text = String(reviewText).toLowerCase();
            
            // 優先順位の高い特定パターンのチェック
            
            // 1. 配送・梱包関連
            if (text.match(/配送|梱包|発送|届[きいくけ]|とど[きいくけ]|到着|包装|配達|宅配|荷物|箱|段ボール|ダンボール/)) {
                return '配送・梱包';
            }
            
            // 2. 価格関連（値上がり/高いの判定を先に）
            if (text.match(/値上[げがり]|値段.{0,5}上が|価格.{0,5}上が|高くな[っり]|値段.{0,5}高[いくめ]|高価|高額|高すぎ|たか[いく]|高い/)) {
                return '高い・値上げ';
            }
            if (text.match(/安[いくめ]|やす[いくめ]|安価|お得|リーズナブル|コスパ|手頃|手ごろ|低価格|割安|お買い得/)) {
                return '安い';
            }
            
            // 3. 賞味期限
            if (text.match(/賞味期限|消費期限|期限|日付|使用期限|有効期限/)) {
                return '賞味期限';
            }
            
            // 4. ジッパー
            if (text.match(/ジッパー|チャック|密封|ジップ|保存.{0,10}(不便|困|できない)|袋.{0,10}(閉|締)|ファスナー/)) {
                return 'ジッパーが欲しい';
            }
            
            // 5. 吐く・便関連（改善と悪化を明確に区別）
            if (text.match(/(吐|はく|嘔吐|吐き戻し).{0,20}(減[ったり]|なくな[ったり]|しなくな[ったり]|改善|良くな[ったり]|減少|治[ったまり])|便.{0,20}(良[くいか]な[ったり]|改善|調子が良|快調|しっかり|正常)|うんち.{0,20}(良[くいか]な[ったり]|改善|しっかり)|毛玉.{0,20}(減[ったり]|なくな[ったり]|少な[くい])/)) {
                return '吐き戻し・便の改善';
            }
            if (text.match(/吐[くいたきけ]|はく|嘔吐|吐き戻[しすり]|もど[すし]|下痢|げり|便.{0,5}[緩悪臭]|うんち.{0,10}[緩悪臭]|軟便|血便|便秘|べんぴ/) && 
                !text.match(/(減[ったり]|なくな[ったり]|しなくな[ったり]|改善|良くな[ったり])/)) {
                return '吐く・便が悪くなる';
            }
            
            // 6. 食べる・食べない（最後に判定）
            if (text.match(/食べ(てくれ)?な[いかくけ]|食べ.{0,5}くれな[いかくけ]|食いつ[かきく].{0,5}(悪|ない|ダメ)|残[すしちり]|拒否|口にしない|見向きもしない|匂いを嗅[いぐ]だだけ|そっぽ|興味.{0,5}示さな/)) {
                return '食べない';
            }
            if (text.match(/食べ[るてたり]|たべ[るてたり]|食いつ[きくいが].{0,5}(良|いい|よ[いくか])|完食|美味[しそ]|おいし|喜んで.{0,5}食べ|バクバク|ペロリ|がっつ[きくい]|夢中|よく食べ|大好き|お気に入り/)) {
                return '食べる';
            }
            
            return 'その他';
        }

        // 改良されたセンチメント分析関数
        function analyzeSentiment(reviewText) {
            if (!reviewText) {
                return {
                    label: 'ニュートラル',
                    score: 50,
                    reason: 'レビューテキストが空のため判定不可'
                };
            }
            
            const text = String(reviewText);
            let score = 50; // 基準スコア
            const reasons = [];
            
            // ポジティブ要素の検出
            if (text.match(/食べ[るてたり](?!な)|美味[しそ]|おいし|喜んで|バクバク|完食|よく食べ|大好き/)) {
                score += 15;
                reasons.push('食いつきが良い');
            }
            if (text.match(/満足|良[いくかけ](?!な)|気に入|お気に入り|リピート|また買|定番|ずっと/)) {
                score += 10;
                reasons.push('満足度が高い');
            }
            if (text.match(/(吐|嘔吐).{0,20}(減|なくなった|改善)|便.{0,20}良|健康|元気|調子.{0,5}良/)) {
                score += 15;
                reasons.push('健康面での改善');
            }
            if (text.match(/安[いくめ]|やす[いくめ]|お得|コスパ|手頃/)) {
                score += 10;
                reasons.push('価格満足度が高い');
            }
            if (text.match(/毛並み.{0,10}(良|綺麗|ツヤ|サラサラ)|毛艶|毛.{0,5}ツヤツヤ/)) {
                score += 10;
                reasons.push('毛並みの改善');
            }
            
            // ネガティブ要素の検出
            if (text.match(/食べ(てくれ)?な[いかくけ]|拒否|残[すし]/)) {
                score -= 20;
                reasons.push('食いつきが悪い');
            }
            if (text.match(/吐[くいたけ]|嘔吐|下痢|軟便|便.{0,5}悪/) && !text.match(/(減|なくなった|改善)/)) {
                score -= 15;
                reasons.push('体調不良の発生');
            }
            if (text.match(/高[いくめ]|たか[いくめ]|値上[げがり]/)) {
                score -= 10;
                reasons.push('価格への不満');
            }
            if (text.match(/残念|がっかり|期待はずれ|ダメ|最悪|二度と|もう買わない/)) {
                score -= 15;
                reasons.push('期待との乖離');
            }
            
            // スコアを0-100の範囲に収める
            score = Math.max(0, Math.min(100, score));
            
            // ラベルの判定
            let label = 'ニュートラル';
            if (score >= 70) label = 'ポジティブ';
            else if (score <= 30) label = 'ネガティブ';
            
            // 理由の生成
            let reason = '';
            if (reasons.length > 0) {
                reason = reasons.join('、') + 'ため。';
            } else {
                reason = '特定の評価要素が見当たらないため中立的と判定。';
            }
            
            return {
                label: label,
                score: score,
                reason: reason
            };
        }

        // センチメント分析サマリーの生成と表示
        function generateAndShowSentimentSummary() {
            const positive = sentimentDataList.filter(s => s.label === 'ポジティブ').length;
            const negative = sentimentDataList.filter(s => s.label === 'ネガティブ').length;
            const neutral = sentimentDataList.filter(s => s.label === 'ニュートラル').length;
            const total = sentimentDataList.length;
            
            let summaryHTML = `
                <p><strong>総レビュー数:</strong> ${total}件</p>
                <p><strong>ポジティブ:</strong> ${positive}件 (${(positive/total*100).toFixed(1)}%)</p>
                <p><strong>ネガティブ:</strong> ${negative}件 (${(negative/total*100).toFixed(1)}%)</p>
                <p><strong>ニュートラル:</strong> ${neutral}件 (${(neutral/total*100).toFixed(1)}%)</p>
                <h4>主な傾向:</h4>
                <ul>
            `;
            
            if (positive > negative * 2) {
                summaryHTML += '<li>全体的に好評価が多く、製品に対する満足度が高い傾向にあります。</li>';
            }
            if (negative > positive * 2) {
                summaryHTML += '<li>改善が必要な点が多く見受けられます。</li>';
            }
            if (Math.abs(positive - negative) < total * 0.1) {
                summaryHTML += '<li>評価が分かれており、個体差や好みの違いが大きいようです。</li>';
            }
            
            // 主なポジティブ要因の分析
            const positiveReasons = {};
            sentimentDataList.filter(s => s.label === 'ポジティブ').forEach(s => {
                if (s.reason.includes('食いつきが良い')) positiveReasons['食いつき'] = (positiveReasons['食いつき'] || 0) + 1;
                if (s.reason.includes('健康面での改善')) positiveReasons['健康改善'] = (positiveReasons['健康改善'] || 0) + 1;
                if (s.reason.includes('価格満足度')) positiveReasons['価格'] = (positiveReasons['価格'] || 0) + 1;
            });
            
            if (Object.keys(positiveReasons).length > 0) {
                summaryHTML += '<li>ポジティブ評価の主な要因：';
                const topReasons = Object.entries(positiveReasons).sort((a, b) => b[1] - a[1]).slice(0, 3);
                summaryHTML += topReasons.map(([reason, count]) => `${reason}(${count}件)`).join('、');
                summaryHTML += '</li>';
            }
            
            summaryHTML += '</ul>';
            
            document.getElementById('sentimentContent').innerHTML = summaryHTML;
            document.getElementById('sentimentSummary').style.display = 'block';
        }

        // データ処理メイン関数
        async function processData() {
            const statusDiv = document.getElementById('status');
            const processBtn = document.getElementById('processBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            
            try {
                processBtn.disabled = true;
                statusDiv.textContent = 'ファイルを読み込み中...';
                
                // Raw_Review.xlsxを探す
                const rawReviewFile = Object.values(uploadedFiles).find(file => 
                    file.name.toLowerCase().includes('raw_review') || file.name.toLowerCase().includes('review')
                );
                
                if (!rawReviewFile) {
                    throw new Error('レビューデータファイルが見つかりません');
                }
                
                const rawWorkbook = XLSX.read(rawReviewFile.data);
                const rawSheet = rawWorkbook.Sheets[rawWorkbook.SheetNames[0]];
                rawData = XLSX.utils.sheet_to_json(rawSheet, { header: 1 });
                
                statusDiv.textContent = `データを処理中... (総行数: ${rawData.length - 1})`;
                
                // デバッグ: 最初の数行のデータを確認
                console.log('ヘッダー:', rawData[0]);
                console.log('1行目データ:', rawData[1]);
                console.log('2行目データ:', rawData[2]);
                
                // ヘッダー作成
                const headers = [...rawData[0], 'L列_ラベル', 'M列_年', 'N列_月', 'O列_年月', 'P列_センチメント', 'Q列_クォーター'];
                processedData = [headers];
                
                // センチメントデータをリセット
                sentimentDataList = [];
                
                // バッチ処理
                const batchSize = 100;
                const totalRows = rawData.length - 1;
                
                for (let i = 1; i < rawData.length; i++) {
                    const row = rawData[i];
                    
                    // ★修正: B列（インデックス1）、K列（インデックス10）を参照するように変更
                    const reviewDate = row[1]; // B列（0ベースなのでインデックス1）
                    const reviewText = row[10]; // K列（0ベースなのでインデックス10）
                    
                    // デバッグ出力（最初の5行のみ）
                    if (i <= 5) {
                        console.log(`${i}行目 - 日付:`, reviewDate, 'レビュー:', reviewText?.substring(0, 50));
                    }
                    
                    const dateInfo = parseDate(reviewDate);
                    const labels = detectLabels(reviewText);
                    const sentimentData = analyzeSentiment(reviewText);
                    
                    // センチメント分析結果をフォーマット
                    const sentimentFormatted = `ラベル: ${sentimentData.label}\nスコア: ${sentimentData.score}\n理由: ${sentimentData.reason}`;
                    
                    const newRow = [...row, labels, dateInfo.year, dateInfo.month, dateInfo.yearMonth, sentimentFormatted, dateInfo.quarter];
                    processedData.push(newRow);
                    sentimentDataList.push(sentimentData);
                    
                    // 進捗更新
                    if (i % batchSize === 0) {
                        statusDiv.textContent = `処理中... ${i}/${totalRows} (${Math.round(i/totalRows*100)}%)`;
                        await new Promise(resolve => setTimeout(resolve, 10)); // UIを更新
                    }
                }
                
                statusDiv.innerHTML = '<span class="success">処理完了！</span>';
                downloadBtn.disabled = false;
                
                // 統計情報の表示
                showStatistics();
                // センチメントサマリーの表示
                generateAndShowSentimentSummary();
                // サンプル結果の表示
                showSampleResults();
                
            } catch (error) {
                statusDiv.innerHTML = `<span class="error">エラー: ${error.message}</span>`;
                processBtn.disabled = false;
            }
        }

        // 統計情報を表示
        function showStatistics() {
            const statsDiv = document.getElementById('stats');
            const statsContent = document.getElementById('statsContent');
            
            // 年月別集計
            const yearMonthStats = {};
            const labelStats = {};
            
            for (let i = 1; i < processedData.length; i++) {
                const yearMonth = processedData[i][14]; // O列
                const labels = processedData[i][11]; // L列
                
                if (yearMonth) {
                    yearMonthStats[yearMonth] = (yearMonthStats[yearMonth] || 0) + 1;
                }
                
                // ラベル集計（単一ラベルとして扱う）
                if (labels) {
                    labelStats[labels] = (labelStats[labels] || 0) + 1;
                }
            }
            
            let html = '<p><strong>総レビュー数:</strong> ' + (processedData.length - 1) + '</p>';
            html += '<p><strong>期間:</strong> ' + Object.keys(yearMonthStats).sort()[0] + ' ～ ' + 
                    Object.keys(yearMonthStats).sort().slice(-1)[0] + '</p>';
            
            html += '<p><strong>ラベル別件数:</strong></p><ul>';
            Object.entries(labelStats).sort((a, b) => b[1] - a[1]).forEach(([label, count]) => {
                html += `<li>${label}: ${count}件</li>`;
            });
            html += '</ul>';
            
            statsContent.innerHTML = html;
            statsDiv.style.display = 'block';
        }

        // サンプル結果を表示
        function showSampleResults() {
            const sampleDiv = document.getElementById('sampleResults');
            const sampleContent = document.getElementById('sampleContent');
            
            let html = '';
            for (let i = 1; i <= 5 && i < processedData.length; i++) {
                const row = processedData[i];
                const sentimentLines = row[15].split('\n');
                html += `<div class="result-item">
                    <strong>レビュー:</strong> ${String(row[10]).substring(0, 100)}...<br>
                    <strong>ラベル:</strong> ${row[11]}<br>
                    <strong>年月:</strong> ${row[14]}<br>
                    <strong>センチメント分析:</strong><br>
                    ${sentimentLines.map(line => `&nbsp;&nbsp;${line}`).join('<br>')}
                </div>`;
            }
            
            sampleContent.innerHTML = html;
            sampleDiv.style.display = 'block';
        }

        // Excelファイルをダウンロード
        function downloadExcel() {
            if (!processedData) return;
            
            // シート1: 処理済みデータ
            const wb = XLSX.utils.book_new();
            const ws1 = XLSX.utils.aoa_to_sheet(processedData);
            XLSX.utils.book_append_sheet(wb, ws1, 'レビューデータ');
            
            // シート2: 統計データを作成（3つの表を含む）
            const statsData = createStatisticsSheet();
            const ws2 = XLSX.utils.aoa_to_sheet(statsData);
            XLSX.utils.book_append_sheet(wb, ws2, '統計分析');
            
            // シート3: センチメントサマリー
            const sentimentSummaryData = createSentimentSummarySheet();
            const ws3 = XLSX.utils.aoa_to_sheet(sentimentSummaryData);
            XLSX.utils.book_append_sheet(wb, ws3, 'センチメント分析');
            
            // ファイルをダウンロード
            XLSX.writeFile(wb, 'ペットフードレビュー分析結果.xlsx');
        }

        // 統計シートを作成（3つの表を含む）
        function createStatisticsSheet() {
            const statsData = [['ペットフードレビュー分析結果 - 統計分析']];
            statsData.push([]);
            
            // データ集計の準備
            const yearMonthLabelCounts = {};
            const quarterLabelCounts = {};
            const yearMonthTotals = {};
            const quarterTotals = {};
            const allLabels = new Set(masterLabels); // マスターラベルを使用
            const allYearMonths = new Set();
            const allQuarters = new Set();
            
            // データ集計
            for (let i = 1; i < processedData.length; i++) {
                const yearMonth = processedData[i][14]; // O列
                const quarter = processedData[i][16]; // Q列
                const label = processedData[i][11]; // L列（単一ラベル）
                
                if (yearMonth && label) {
                    allYearMonths.add(yearMonth);
                    yearMonthTotals[yearMonth] = (yearMonthTotals[yearMonth] || 0) + 1;
                    
                    if (!yearMonthLabelCounts[yearMonth]) {
                        yearMonthLabelCounts[yearMonth] = {};
                    }
                    
                    yearMonthLabelCounts[yearMonth][label] = 
                        (yearMonthLabelCounts[yearMonth][label] || 0) + 1;
                }
                
                if (quarter && label) {
                    allQuarters.add(quarter);
                    quarterTotals[quarter] = (quarterTotals[quarter] || 0) + 1;
                    
                    if (!quarterLabelCounts[quarter]) {
                        quarterLabelCounts[quarter] = {};
                    }
                    
                    quarterLabelCounts[quarter][label] = 
                        (quarterLabelCounts[quarter][label] || 0) + 1;
                }
            }
            
            const sortedYearMonths = Array.from(allYearMonths).sort();
            const sortedQuarters = Array.from(allQuarters).sort();
            const sortedLabels = Array.from(allLabels);
            
            // 表1: 年月ごとの実数推移
            statsData.push(['【表1】年月ごとの実数推移']);
            statsData.push(['ラベル', ...sortedYearMonths]);
            
            sortedLabels.forEach(label => {
                const row = [label];
                sortedYearMonths.forEach(ym => {
                    row.push(yearMonthLabelCounts[ym] && yearMonthLabelCounts[ym][label] ? yearMonthLabelCounts[ym][label] : 0);
                });
                statsData.push(row);
            });
            
            // 合計行
            const totalRow = ['合計'];
            sortedYearMonths.forEach(ym => {
                totalRow.push(yearMonthTotals[ym] || 0);
            });
            statsData.push(totalRow);
            
            // 空行で区切り
            statsData.push([]);
            statsData.push([]);
            
            // 表2: 年月ごとの割合推移
            statsData.push(['【表2】年月ごとの割合推移（%）']);
            statsData.push(['ラベル', ...sortedYearMonths]);
            
            sortedLabels.forEach(label => {
                const row = [label];
                sortedYearMonths.forEach(ym => {
                    const count = yearMonthLabelCounts[ym] && yearMonthLabelCounts[ym][label] ? yearMonthLabelCounts[ym][label] : 0;
                    const total = yearMonthTotals[ym] || 1;
                    const percentage = ((count / total) * 100).toFixed(1);
                    row.push(percentage + '%');
                });
                statsData.push(row);
            });
            
            // 空行で区切り
            statsData.push([]);
            statsData.push([]);
            
            // 表3: クォーターごとのまとめ
            statsData.push(['【表3】クォーターごとのまとめ']);
            
            // 実数部分
            statsData.push(['ラベル（実数）', ...sortedQuarters]);
            sortedLabels.forEach(label => {
                const row = [label];
                sortedQuarters.forEach(q => {
                    row.push(quarterLabelCounts[q] && quarterLabelCounts[q][label] ? quarterLabelCounts[q][label] : 0);
                });
                statsData.push(row);
            });
            
            // 合計行
            const quarterTotalRow = ['合計'];
            sortedQuarters.forEach(q => {
                quarterTotalRow.push(quarterTotals[q] || 0);
            });
            statsData.push(quarterTotalRow);
            
            statsData.push([]);
            
            // 割合部分
            statsData.push(['ラベル（割合%）', ...sortedQuarters]);
            sortedLabels.forEach(label => {
                const row = [label];
                sortedQuarters.forEach(q => {
                    const count = quarterLabelCounts[q] && quarterLabelCounts[q][label] ? quarterLabelCounts[q][label] : 0;
                    const total = quarterTotals[q] || 1;
                    const percentage = ((count / total) * 100).toFixed(1);
                    row.push(percentage + '%');
                });
                statsData.push(row);
            });
            
            return statsData;
        }

        // センチメントサマリーシートを作成
        function createSentimentSummarySheet() {
            const summaryData = [['センチメント分析サマリー']];
            summaryData.push([]);
            
            const positive = sentimentDataList.filter(s => s.label === 'ポジティブ').length;
            const negative = sentimentDataList.filter(s => s.label === 'ネガティブ').length;
            const neutral = sentimentDataList.filter(s => s.label === 'ニュートラル').length;
            const total = sentimentDataList.length;
            
            summaryData.push(['項目', '件数', '割合']);
            summaryData.push(['総レビュー数', total, '100.0%']);
            summaryData.push(['ポジティブ', positive, `${(positive/total*100).toFixed(1)}%`]);
            summaryData.push(['ネガティブ', negative, `${(negative/total*100).toFixed(1)}%`]);
            summaryData.push(['ニュートラル', neutral, `${(neutral/total*100).toFixed(1)}%`]);
            
            summaryData.push([]);
            summaryData.push(['主な傾向']);
            
            if (positive > negative * 2) {
                summaryData.push(['全体的に好評価が多く、製品に対する満足度が高い傾向にあります。']);
            }
            if (negative > positive * 2) {
                summaryData.push(['改善が必要な点が多く見受けられます。']);
            }
            if (Math.abs(positive - negative) < total * 0.1) {
                summaryData.push(['評価が分かれており、個体差や好みの違いが大きいようです。']);
            }
            
            // 月別センチメント推移
            summaryData.push([]);
            summaryData.push(['月別センチメント推移']);
            
            const monthSentiment = {};
            for (let i = 1; i < processedData.length; i++) {
                const yearMonth = processedData[i][14];
                const sentiment = processedData[i][15];
                
                if (yearMonth && sentiment) {
                    if (!monthSentiment[yearMonth]) {
                        monthSentiment[yearMonth] = {
                            'ポジティブ': 0,
                            'ネガティブ': 0,
                            'ニュートラル': 0
                        };
                    }
                    
                    const sentimentMatch = sentiment.match(/ラベル: (\w+)/);
                    if (sentimentMatch) {
                        monthSentiment[yearMonth][sentimentMatch[1]]++;
                    }
                }
            }
            
            const sortedMonths = Object.keys(monthSentiment).sort();
            summaryData.push(['年月', 'ポジティブ', 'ネガティブ', 'ニュートラル']);
            
            sortedMonths.forEach(month => {
                summaryData.push([
                    month,
                    monthSentiment[month]['ポジティブ'],
                    monthSentiment[month]['ネガティブ'],
                    monthSentiment[month]['ニュートラル']
                ]);
            });
            
            return summaryData;
        }
    </script>
</body>
</html>