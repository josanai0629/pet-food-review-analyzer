<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒšãƒƒãƒˆãƒ•ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼åˆ†æãƒ„ãƒ¼ãƒ«</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .upload-area {
            border: 2px dashed #4CAF50;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin: 20px 0;
            background-color: #f9f9f9;
            transition: all 0.3s;
        }
        .upload-area:hover {
            background-color: #e8f5e9;
        }
        .upload-area.dragover {
            background-color: #c8e6c9;
            border-color: #2E7D32;
        }
        .file-input {
            display: none;
        }
        .upload-button {
            background-color: #4CAF50;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
            transition: background-color 0.3s;
        }
        .upload-button:hover {
            background-color: #45a049;
        }
        .progress {
            margin: 20px 0;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .stats {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .sentiment-summary {
            margin: 20px 0;
            padding: 15px;
            background-color: #e3f2fd;
            border-radius: 5px;
            border-left: 4px solid #2196F3;
        }
        .sample-results {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            max-height: 300px;
            overflow-y: auto;
        }
        .result-item {
            margin: 10px 0;
            padding: 10px;
            background-color: white;
            border-radius: 5px;
            border-left: 4px solid #4CAF50;
        }
        .error {
            color: #d32f2f;
            font-weight: bold;
        }
        .success {
            color: #388e3c;
            font-weight: bold;
        }
        .file-list {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #e0e0e0;
        }
        .file-item:last-child {
            border-bottom: none;
        }
        .remove-file {
            background-color: #f44336;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .remove-file:hover {
            background-color: #d32f2f;
        }
        .debug-button {
            background-color: #ff9800;
            margin-left: 10px;
        }
        .debug-button:hover {
            background-color: #f57c00;
        }
        .master-info {
            background-color: #e8f5e9;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 12px;
            border-left: 4px solid #4CAF50;
        }
        
        /* æ–°æ©Ÿèƒ½: å¯è¦–åŒ–ã‚¨ãƒªã‚¢ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .visualization-container {
            margin: 20px 0;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #e0e0e0;
        }
        .chart-container {
            margin: 20px 0;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .chart-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            color: #333;
        }
        .chart-wrapper {
            position: relative;
            height: 400px;
            margin: 10px 0;
        }
        .chart-wrapper.small {
            height: 300px;
        }
        .dashboard-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .dashboard-card {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }
        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #4CAF50;
            margin: 10px 0;
        }
        .metric-label {
            font-size: 14px;
            color: #666;
            text-transform: uppercase;
        }
        .filter-controls {
            margin: 20px 0;
            padding: 15px;
            background-color: #e8f5e9;
            border-radius: 8px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .filter-group label {
            font-size: 12px;
            font-weight: bold;
            color: #333;
        }
        .filter-group select {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }
        .trend-indicator {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 12px;
            margin-left: 10px;
        }
        .trend-up {
            background-color: #c8e6c9;
            color: #2e7d32;
        }
        .trend-down {
            background-color: #ffcdd2;
            color: #d32f2f;
        }
        .trend-stable {
            background-color: #e1f5fe;
            color: #0277bd;
        }
        
        /* æ–°æ©Ÿèƒ½: é«˜ç²¾åº¦åŒ–è¡¨ç¤º */
        .accuracy-info {
            background-color: #e8f5e9;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #4CAF50;
        }
        .accuracy-badge {
            display: inline-block;
            background-color: #4CAF50;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 10px;
        }
        
        @media (max-width: 768px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }
            .filter-controls {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>ãƒšãƒƒãƒˆãƒ•ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼åˆ†æãƒ„ãƒ¼ãƒ«</h1>
        
        <!-- ğŸ¯ ã‚«ãƒ†ã‚´ãƒªè¨­å®šã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
        <div class="accuracy-info" style="background-color: #f3e5f5; border-color: #9c27b0;">
            <strong>ğŸ¯ ã‚«ãƒ†ã‚´ãƒªè¨­å®š</strong><span class="accuracy-badge" style="background-color: #9c27b0;">ã‚«ã‚¹ã‚¿ãƒ </span><br>
            <label for="categoryInput">åˆ†é¡ã‚«ãƒ†ã‚´ãƒªã‚’è¨­å®šã—ã¦ãã ã•ã„ï¼ˆ1è¡Œ1ã‚«ãƒ†ã‚´ãƒªï¼‰ï¼š</label>
            <textarea id="categoryInput" rows="8" style="width: 100%; margin-top: 10px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; font-family: monospace;" placeholder="é£Ÿã¹ã‚‹
é£Ÿã¹ãªã„
åããƒ»ä¾¿ãŒæ‚ªããªã‚‹
åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„
å€¤ä¸ŠãŒã‚Š/é«˜ã„
å®‰ã„
é…é€ãƒ»æ¢±åŒ…
è³å‘³æœŸé™
ã‚¸ãƒƒãƒ‘ãƒ¼
ãã®ä»–">é£Ÿã¹ã‚‹
é£Ÿã¹ãªã„
åããƒ»ä¾¿ãŒæ‚ªããªã‚‹
åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„
å€¤ä¸ŠãŒã‚Š/é«˜ã„
å®‰ã„
é…é€ãƒ»æ¢±åŒ…
è³å‘³æœŸé™
ã‚¸ãƒƒãƒ‘ãƒ¼
ãã®ä»–</textarea>
            
        </div>
        
        <div class="upload-area" id="uploadArea">
            <p>ã“ã“ã«Excelãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—<br>ã¾ãŸã¯</p>
            <input type="file" id="fileInput" class="file-input" accept=".xlsx,.xls" multiple>
            <label for="fileInput" class="upload-button">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</label>
            <p style="margin-top: 20px; font-size: 14px; color: #666;">
                å¿…è¦ãªãƒ•ã‚¡ã‚¤ãƒ«ï¼š<br>
                ãƒ»Raw_Review.xlsxï¼ˆãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ‡ãƒ¼ã‚¿ï¼‰<br>
            </p>
        </div>

        <div id="fileList" class="file-list" style="display: none;">
            <h3>ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«</h3>
            <div id="fileItems"></div>
        </div>
        
        <div id="status" class="progress" style="display: none;">
            ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„
        </div>

        <div style="text-align: center;">
            <button onclick="processData()" id="processBtn" style="display: none;">ãƒ‡ãƒ¼ã‚¿å‡¦ç†ã‚’é–‹å§‹</button>
            <button onclick="downloadExcel()" id="downloadBtn" disabled>Excelãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
            <button onclick="toggleVisualization()" id="visualizeBtn" disabled style="background-color: #2196F3;">ğŸ“Š å¯è¦–åŒ–è¡¨ç¤º</button>
        </div>

        <!-- ğŸ¯ é€²æ—è¡¨ç¤ºUI -->
        <div id="progressSection" style="display: none; margin: 20px 0; padding: 20px; background-color: #f8f9fa; border-radius: 10px; border: 2px solid #4CAF50;">
            <div class="progress-header" style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                <span style="font-weight: bold;">ğŸ“Š å‡¦ç†é€²æ—: <span id="progressCount">0/0</span></span>
                <span style="font-weight: bold;">â±ï¸ <span id="elapsedTime">00:00</span></span>
            </div>
            <div class="progress-bar" style="width: 100%; background-color: #e0e0e0; border-radius: 10px; height: 20px; margin-bottom: 15px;">
                <div id="progressFill" style="width: 0%; background-color: #4CAF50; height: 100%; border-radius: 10px; transition: width 0.3s;"></div>
            </div>
            <div class="progress-details">
                <div style="margin-bottom: 5px;">ğŸ¤– <span id="currentStatus">æº–å‚™ä¸­...</span></div>
                <div style="margin-bottom: 5px;">ğŸ“ ç¾åœ¨å‡¦ç†ä¸­: <span id="currentReview">-</span></div>
                <div>â³ æ¨å®šæ®‹ã‚Šæ™‚é–“: <span id="estimatedTime">è¨ˆç®—ä¸­...</span></div>
            </div>
        </div>

        <!-- æ–°æ©Ÿèƒ½: ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ -->
        <div id="dashboardSection" class="visualization-container" style="display: none;">
            <h2>ğŸ“Š åˆ†æãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰</h2>
            
            <!-- ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼æ©Ÿèƒ½ -->
            <div class="filter-controls">
                <div class="filter-group">
                    <label>æœŸé–“ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼</label>
                    <select id="periodFilter" onchange="updateCharts()">
                        <option value="all">å…¨æœŸé–“</option>
                        <option value="last3months">ç›´è¿‘3ãƒ¶æœˆ</option>
                        <option value="last6months">ç›´è¿‘6ãƒ¶æœˆ</option>
                        <option value="thisyear">ä»Šå¹´</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label>è¡¨ç¤ºãƒ©ãƒ™ãƒ«</label>
                    <select id="labelFilter" onchange="updateCharts()">
                        <option value="all">å…¨ãƒ©ãƒ™ãƒ«</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label>ãƒãƒ£ãƒ¼ãƒˆç¨®åˆ¥</label>
                    <select id="chartType" onchange="updateCharts()">
                        <option value="line">æŠ˜ã‚Œç·šã‚°ãƒ©ãƒ•</option>
                        <option value="bar">æ£’ã‚°ãƒ©ãƒ•</option>
                        <option value="area">é¢ã‚°ãƒ©ãƒ•</option>
                    </select>
                </div>
            </div>

            <!-- KPI ã‚«ãƒ¼ãƒ‰ -->
            <div class="dashboard-grid">
                <div class="dashboard-card">
                    <div class="metric-label">ç·ãƒ¬ãƒ“ãƒ¥ãƒ¼æ•°</div>
                    <div class="metric-value" id="totalReviews">0</div>
                    <span id="reviewsTrend" class="trend-indicator"></span>
                </div>
                <div class="dashboard-card">
                    <div class="metric-label">ãƒã‚¸ãƒ†ã‚£ãƒ–ç‡</div>
                    <div class="metric-value" id="positiveRate">0%</div>
                    <span id="positiveTrend" class="trend-indicator"></span>
                </div>
                <div class="dashboard-card">
                    <div class="metric-label">æœ€å¤šãƒ©ãƒ™ãƒ«</div>
                    <div class="metric-value" id="topLabel">-</div>
                    <span id="topLabelCount" class="trend-indicator"></span>
                </div>
                <div class="dashboard-card">
                    <div class="metric-label">å¹³å‡ã‚¹ã‚³ã‚¢</div>
                    <div class="metric-value" id="avgScore">0</div>
                    <span id="scoreTrend" class="trend-indicator"></span>
                </div>
            </div>

            <!-- ãƒãƒ£ãƒ¼ãƒˆã‚¨ãƒªã‚¢ -->
            <div class="chart-container">
                <div class="chart-title">æœˆåˆ¥ãƒ¬ãƒ“ãƒ¥ãƒ¼æ¨ç§»</div>
                <div class="chart-wrapper">
                    <canvas id="monthlyTrendChart"></canvas>
                </div>
            </div>

            <div class="dashboard-grid">
                <div class="chart-container">
                    <div class="chart-title">ãƒ©ãƒ™ãƒ«åˆ†å¸ƒ</div>
                    <div class="chart-wrapper small">
                        <canvas id="labelDistributionChart"></canvas>
                    </div>
                </div>
                <div class="chart-container">
                    <div class="chart-title">ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆåˆ†æ</div>
                    <div class="chart-wrapper small">
                        <canvas id="sentimentChart"></canvas>
                    </div>
                </div>
            </div>

            <div class="chart-container">
                <div class="chart-title">ã‚¯ã‚©ãƒ¼ã‚¿ãƒ¼åˆ¥æ¯”è¼ƒ</div>
                <div class="chart-wrapper">
                    <canvas id="quarterlyChart"></canvas>
                </div>
            </div>

            <!-- ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—é¢¨ã®è¡¨ç¤º -->
            <div class="chart-container">
                <div class="chart-title">ãƒ©ãƒ™ãƒ«Ã—ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆ ãƒãƒˆãƒªãƒƒã‚¯ã‚¹</div>
                <div id="heatmapContainer" style="overflow-x: auto;">
                    <table id="heatmapTable" style="width: 100%; border-collapse: collapse;">
                    </table>
                </div>
            </div>
        </div>

        <div id="stats" class="stats" style="display: none;">
            <h3>å‡¦ç†çµ±è¨ˆ</h3>
            <div id="statsContent"></div>
        </div>

        <div id="sentimentSummary" class="sentiment-summary" style="display: none;">
            <h3>ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆåˆ†æã‚µãƒãƒªãƒ¼</h3>
            <div id="sentimentContent"></div>
        </div>

        <div id="sampleResults" class="sample-results" style="display: none;">
            <h3>å‡¦ç†çµæœã‚µãƒ³ãƒ—ãƒ«</h3>
            <div id="sampleContent"></div>
        </div>
    </div>

    <script>
        let processedData = null;
        let rawData = null;
        let masterLabels = [
            'é£Ÿã¹ã‚‹', 'é£Ÿã¹ãªã„', 'åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„', 'ãã®ä»–', 'å®‰ã„',
            'é…é€ãƒ»æ¢±åŒ…', 'å€¤ä¸ŠãŒã‚Š/é«˜ã„', 'åããƒ»ä¾¿ãŒæ‚ªããªã‚‹', 'è³å‘³æœŸé™', 'ã‚¸ãƒƒãƒ‘ãƒ¼'
        ];
        let labelConfig = [];
        let uploadedFiles = {};
        let sentimentDataList = [];
        
        // æ–°æ©Ÿèƒ½: ãƒãƒ£ãƒ¼ãƒˆç®¡ç†
        let charts = {};
        let dashboardVisible = false;
        let analysisData = {};

        // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã®è¨­å®š
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });

        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
        });

        function handleFiles(files) {
            Array.from(files).forEach(file => {
                if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        uploadedFiles[file.name] = {
                            name: file.name,
                            data: e.target.result
                        };
                        updateFileList();
                        checkFiles();
                    };
                    reader.readAsArrayBuffer(file);
                }
            });
        }

        function updateFileList() {
            const fileList = document.getElementById('fileList');
            const fileItems = document.getElementById('fileItems');
            
            if (Object.keys(uploadedFiles).length > 0) {
                fileList.style.display = 'block';
                fileItems.innerHTML = '';
                
                Object.values(uploadedFiles).forEach(file => {
                    const item = document.createElement('div');
                    item.className = 'file-item';
                    item.innerHTML = `
                        <span>${file.name}</span>
                        <button class="remove-file" onclick="removeFile('${file.name}')">å‰Šé™¤</button>
                    `;
                    fileItems.appendChild(item);
                });
            } else {
                fileList.style.display = 'none';
            }
        }

        function removeFile(fileName) {
            delete uploadedFiles[fileName];
            updateFileList();
            checkFiles();
        }

        function checkFiles() {
            const hasRawReview = Object.keys(uploadedFiles).some(name => 
                name.toLowerCase().includes('raw_review') || name.toLowerCase().includes('review')
            );
            
            if (hasRawReview) {
                document.getElementById('processBtn').style.display = 'inline-block';
                document.getElementById('debugBtn').style.display = 'inline-block';
                document.getElementById('status').style.display = 'block';
                document.getElementById('status').textContent = 'å‡¦ç†æº–å‚™å®Œäº†';
                
                const masterFile = Object.values(uploadedFiles).find(file => 
                    file.name.toLowerCase().includes('master')
                );
                if (masterFile) {
                    const workbook = XLSX.read(masterFile.data);
                    const sheet = workbook.Sheets[workbook.SheetNames[0]];
                    const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                    
                    const hasExtendedFormat = data.some(row => row[1] || row[2]);
                    
                    if (hasExtendedFormat) {
                        labelConfig = data
                            .filter(row => row[0])
                            .map(row => ({
                                name: row[0],
                                priority: parseInt(row[1]) || 999,
                                patterns: row[2] ? row[2].split('|').filter(p => p.trim()) : []
                            }))
                            .sort((a, b) => a.priority - b.priority);
                        
                        console.log('ã‚«ã‚¹ã‚¿ãƒ ãƒ©ãƒ™ãƒ«è¨­å®šã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ:', labelConfig);
                        document.getElementById('status').textContent = `å‡¦ç†æº–å‚™å®Œäº†ï¼ˆã‚«ã‚¹ã‚¿ãƒ ãƒ©ãƒ™ãƒ«è¨­å®š: ${labelConfig.length}ä»¶ï¼‰`;
                    } else {
                        labelConfig = [];
                        masterLabels = data.map(row => row[0]).filter(label => label);
                        console.log('å¾“æ¥å½¢å¼ã®Master.xlsxã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ:', masterLabels);
                    }
                } else {
                    labelConfig = [];
                }
            } else {
                document.getElementById('processBtn').style.display = 'none';
                document.getElementById('debugBtn').style.display = 'none';
                document.getElementById('status').style.display = 'none';
            }
        }

        function parseDate(dateStr) {
            if (!dateStr) return { year: '', month: '', yearMonth: '', quarter: '' };
            
            console.log('å…¥åŠ›ã•ã‚ŒãŸæ—¥ä»˜ãƒ‡ãƒ¼ã‚¿:', dateStr, 'ã‚¿ã‚¤ãƒ—:', typeof dateStr);
            
            let date = null;
            
            if (typeof dateStr === 'number' && dateStr >= 1) {
                const excelEpoch = new Date(1899, 11, 30);
                date = new Date(excelEpoch.getTime() + dateStr * 24 * 60 * 60 * 1000);
                console.log(`Excelã‚·ãƒªã‚¢ãƒ«å€¤å¤‰æ›: ${dateStr} â†’ ${date.toLocaleDateString('ja-JP')}`);
            }
            else if (typeof dateStr === 'string') {
                const yearMonthMatch = dateStr.match(/(\d{4})å¹´(\d{1,2})æœˆ/);
                if (yearMonthMatch) {
                    const year = parseInt(yearMonthMatch[1]);
                    const month = parseInt(yearMonthMatch[2]);
                    date = new Date(year, month - 1, 1);
                }
                else {
                    const normalizedDate = dateStr.replace(/[å¹´æœˆæ—¥]/g, '/').replace(/-/g, '/');
                    const testDate = new Date(normalizedDate);
                    if (!isNaN(testDate.getTime())) {
                        date = testDate;
                    }
                }
            }
            
            if (date && !isNaN(date.getTime())) {
                const year = date.getFullYear().toString();
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                const monthNum = parseInt(month);
                const quarter = `${year}Q${Math.ceil(monthNum / 3)}`;
                
                const result = {
                    year: year,
                    month: month,
                    yearMonth: `${year}å¹´${month}æœˆ`,
                    quarter: quarter
                };
                
                console.log('è§£æçµæœ:', result);
                return result;
            }
            
            console.log('æ—¥ä»˜è§£æå¤±æ•—:', dateStr);
            return { year: '', month: '', yearMonth: '', quarter: '' };
        }

        // ğŸš€ ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ç”¨æ—¥ä»˜ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½ï¼ˆwindow.debugDateData()ã§å®Ÿè¡Œå¯èƒ½ï¼‰
        window.debugDateData = function() {
            if (!rawData || rawData.length < 2) {
                const rawReviewFile = Object.values(uploadedFiles).find(file => 
                    file.name.toLowerCase().includes('raw_review') || file.name.toLowerCase().includes('review')
                );
                
                if (!rawReviewFile) {
                    console.error('âŒ ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    return 'Error: Review data file not found';
                }
                
                const rawWorkbook = XLSX.read(rawReviewFile.data);
                const rawSheet = rawWorkbook.Sheets[rawWorkbook.SheetNames[0]];
                rawData = XLSX.utils.sheet_to_json(rawSheet, { header: 1 });
            }
            
            console.log('=== ğŸ“… æ—¥ä»˜ãƒ‡ãƒ¼ã‚¿ã®ãƒ‡ãƒãƒƒã‚°æƒ…å ± ===');
            console.log('ãƒ˜ãƒƒãƒ€ãƒ¼:', rawData[0]);
            console.log('Excel ã‚·ãƒªã‚¢ãƒ«å€¤å¤‰æ›ãƒ†ã‚¹ãƒˆ:');
            console.log('  44732 â†’', new Date(new Date(1899, 11, 30).getTime() + 44732 * 24 * 60 * 60 * 1000).toLocaleDateString('ja-JP'));
            console.log('  44738 â†’', new Date(new Date(1899, 11, 30).getTime() + 44738 * 24 * 60 * 60 * 1000).toLocaleDateString('ja-JP'));
            console.log('  45159 â†’', new Date(new Date(1899, 11, 30).getTime() + 45159 * 24 * 60 * 60 * 1000).toLocaleDateString('ja-JP'));
            console.log('');
            
            for (let i = 1; i <= Math.min(20, rawData.length - 1); i++) {
                const dateValue = rawData[i][1];
                console.log(`${i}è¡Œç›® Båˆ—:`, dateValue, 'ã‚¿ã‚¤ãƒ—:', typeof dateValue);
                
                if (dateValue) {
                    const parsed = parseDate(dateValue);
                    console.log(`  â†’ è§£æçµæœ:`, parsed);
                }
            }
            
            return `Date debug completed. Check console for ${Math.min(20, rawData.length - 1)} rows.`;
        }

        // ğŸ¯ æ–°æ©Ÿèƒ½: æ–‡è„ˆåˆ†ææ©Ÿèƒ½
        function analyzeReviewContext(reviewText) {
            if (!reviewText) return null;
            
            const sentences = reviewText.split(/[ã€‚ï¼ï¼Ÿ\n]/).filter(s => s.trim());
            const timeMarkers = {
                past: ['ä»Šã¾ã§', 'ã“ã‚Œã¾ã§', 'ä»¥å‰', 'å‰ã¯', 'ã‚‚ã¨ã‚‚ã¨', 'æ˜”ã‹ã‚‰', 'å¾“æ¥'],
                current: ['ã“ã¡ã‚‰', 'ã“ã®å•†å“', 'ä»Šå›', 'ã“ã‚Œ', 'ã§ã‚‚', 'ç¾åœ¨', 'ã„ã¾ã¯'],
                transition: ['ã—ã‹ã—', 'ã¨ã“ã‚ãŒ', 'ã§ã‚‚', 'ã‘ã‚Œã©', 'ãŒã€', 'ãŸã ', 'ã—ã‹ã—']
            };
            
            let contextAnalysis = {
                pastContext: [],
                currentContext: [],
                hasTransition: false,
                timelineDetected: false
            };
            
            sentences.forEach((sentence, index) => {
                const cleanSentence = sentence.trim();
                if (!cleanSentence) return;
                
                // æ™‚ç³»åˆ—ãƒãƒ¼ã‚«ãƒ¼ã®æ¤œå‡º
                if (timeMarkers.past.some(marker => cleanSentence.includes(marker))) {
                    contextAnalysis.pastContext.push({sentence: cleanSentence, index});
                    contextAnalysis.timelineDetected = true;
                }
                
                if (timeMarkers.current.some(marker => cleanSentence.includes(marker))) {
                    contextAnalysis.currentContext.push({sentence: cleanSentence, index});
                    contextAnalysis.timelineDetected = true;
                }
                
                // è»¢æ›ãƒãƒ¼ã‚«ãƒ¼ã®æ¤œå‡º
                if (timeMarkers.transition.some(marker => cleanSentence.includes(marker))) {
                    contextAnalysis.hasTransition = true;
                }
            });
            
            return contextAnalysis;
        }

        // ğŸ¯ Phase 4ç”¨ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°é–¢æ•°ï¼ˆå„ªå…ˆåº¦1ãƒ»2å¯¾å¿œç‰ˆï¼‰
        function addScoresByKeywordsEnhanced(text, scores, weight = 1.0) {
            const lowerText = text.toLowerCase();
            
            // é£Ÿã¹ã‚‹é–¢é€£ï¼ˆå¤§å¹…æ‹¡å¼µ + æ–‡è„ˆè€ƒæ…®å¼·åŒ–ï¼‰
            const eatPatterns = {
                veryStrong: [
                    /å®Œé£Ÿ/, /ãƒšãƒ­ãƒª/, /ãƒšãƒ­ãƒƒã¨/, /ãƒã‚¯ãƒã‚¯/, /ãŒã£ã¤[ãã]/,
                    /å¤¢ä¸­.{0,10}é£Ÿã¹/, /å‹¢ã„.{0,10}é£Ÿã¹/, /é£›ã³ä»˜/,
                    /å–œã‚“ã§.{0,15}å®Œé£Ÿ/, /ç¾å‘³ã—ãã†ã«.{0,10}é£Ÿã¹/
                ],
                strong: [
                    /ã‚ˆãé£Ÿã¹/, /é£Ÿã¹[ã‚‹ã¦ãŸã‚Š]/, /ãŸã¹[ã‚‹ã¦ãŸã‚Š]/,
                    /é£Ÿã„ã¤[ããã„].{0,5}(è‰¯|ã„ã„|ã‚ˆ[ã„ãã‹])/, 
                    /ç¾å‘³[ã—ã]/, /ãŠã„ã—/, /æ°—ã«å…¥/, /å¤§å¥½ã/,
                    /å–œã‚“ã§/, /ãŠæ°—ã«å…¥ã‚Š/, /ãƒªãƒ”ãƒ¼ãƒˆ/,
                    /ã™ãã«é£Ÿã¹/, /ä¸€ç¬ã§é£Ÿã¹/, /ã™ã”ã„å‹¢ã„ã§/
                ],
                medium: [
                    /é£Ÿã¹ã¦.{0,5}ãã‚Œ/, /ã¡ã‚ƒã‚“ã¨.{0,5}é£Ÿã¹/,
                    /ã—ã£ã‹ã‚Š.{0,5}é£Ÿã¹/, /å…¨éƒ¨.{0,5}é£Ÿã¹/,
                    /æ™®é€šã«é£Ÿã¹/, /ã¾ã‚ã¾ã‚é£Ÿã¹/
                ],
                weak: [
                    /é£Ÿã¹/, /ãŸã¹/  // æœ€ä½é™ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
                ]
            };
            
            // ã‚¹ã‚³ã‚¢é…ç‚¹
            eatPatterns.veryStrong.forEach(pattern => {
                if (lowerText.match(pattern)) scores['é£Ÿã¹ã‚‹'] += 15 * weight;
            });
            eatPatterns.strong.forEach(pattern => {
                if (lowerText.match(pattern)) scores['é£Ÿã¹ã‚‹'] += 10 * weight;
            });
            eatPatterns.medium.forEach(pattern => {
                if (lowerText.match(pattern)) scores['é£Ÿã¹ã‚‹'] += 5 * weight;
            });
            eatPatterns.weak.forEach(pattern => {
                if (lowerText.match(pattern)) scores['é£Ÿã¹ã‚‹'] += 2 * weight;
            });
            
            // é£Ÿã¹ãªã„é–¢é€£ï¼ˆå¼·åŒ–ç‰ˆ + æ–‡è„ˆç²¾å¯†åŒ–ï¼‰
            const noEatPatterns = {
                veryStrong: [
                    /å…¨ãé£Ÿã¹ãªã„/, /å…¨ç„¶é£Ÿã¹ãªã„/, /çµ¶å¯¾ã«é£Ÿã¹ãªã„/,
                    /è¦‹å‘ãã‚‚ã—ãªã„/, /å®Œå…¨æ‹’å¦/, /ä¸€å£ã‚‚é£Ÿã¹/,
                    /åŒ‚ã„.{0,5}å—…[ã„ã]ã ã ã‘.{0,10}(çµ‚ã‚ã‚Š|ãŠã—ã¾ã„)/
                ],
                strong: [
                    /é£Ÿã¹(ã¦ãã‚Œ)?ãª[ã„ã‹]/, /æ‹’å¦.{0,10}ã™ã‚‹/,
                    /å£ã«ã—ãª[ã„ã‹]/, /ãã£ã½.{0,5}å‘[ãã]/,
                    /è­¦æˆ’.{0,10}ã—ã¦.{0,5}é£Ÿã¹ãª[ã„ã‹]/,
                    /è¿‘ã¥[ã‹ã]ã‚‚ã—ãª[ã„ã‹]/
                ],
                medium: [
                    /æ®‹ã—ã¦/, /é£Ÿã¹æ®‹[ã™ã—]/, /åŒ‚ã„.{0,5}å—…[ã„ã]ã ã ã‘/,
                    /èˆˆå‘³.{0,5}ç¤ºã•ãª/, /é£Ÿã„ã¤[ã‹ãã].{0,5}(æ‚ª|ãªã„|ãƒ€ãƒ¡)/,
                    /é£Ÿã¹[ã‚‹ã¦].{0,5}(ã®ã«|ã‘ã©).{0,5}æ™‚é–“.{0,5}ã‹ã‹[ã‚‹ã£ã‚Š]/
                ],
                exclusions: [
                    /(ä»Šã¾ã§|ä»¥å‰|ã“ã‚Œã¾ã§|å‰ã¯|ã‚‚ã¨ã‚‚ã¨|æ˜”ã¯).{0,50}é£Ÿã¹.*ãª[ã„ã‹]/,
                    /(ä»–ã®|åˆ¥ã®|é•ã†|å‰ã®).{0,30}(ãƒ•ãƒ¼ãƒ‰|ã‚¨ã‚µ|é¤Œ)/,
                    /(â—‹â—‹|â–³â–³|Ã—Ã—|ä»–ç¤¾|Aç¤¾|Bç¤¾).{0,20}(ã¯|ã§ã¯).{0,20}é£Ÿã¹.*ãª[ã„ã‹]/,
                    /(æœ€åˆ|ã¯ã˜ã‚).{0,20}é£Ÿã¹.*ãª[ã„ã‹].{0,20}(ã§ã‚‚|ã‘ã©|ãŒ).{0,20}(ä»Š|ç¾åœ¨|ã„ã¾)/,
                    /é£Ÿã¹.*ãª[ã„ã‹].{0,20}(ã§ã‚‚|ã‘ã©|ãŒ).{0,20}(å¥åº·|å…ƒæ°—|èª¿å­)/
                ]
            };
            
            // é™¤å¤–ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒã‚§ãƒƒã‚¯ï¼ˆéå»ã®è©±ã‚„ä»–ç¤¾è£½å“ã®è©±ã‚’é™¤å¤–ï¼‰
            const hasExclusion = noEatPatterns.exclusions.some(pattern => 
                lowerText.match(pattern));
            
            if (!hasExclusion) {
                noEatPatterns.veryStrong.forEach(pattern => {
                    if (lowerText.match(pattern)) scores['é£Ÿã¹ãªã„'] += 15 * weight;
                });
                noEatPatterns.strong.forEach(pattern => {
                    if (lowerText.match(pattern)) scores['é£Ÿã¹ãªã„'] += 10 * weight;
                });
                noEatPatterns.medium.forEach(pattern => {
                    if (lowerText.match(pattern)) scores['é£Ÿã¹ãªã„'] += 5 * weight;
                });
            }
            
            // å¥åº·é–¢é€£ï¼ˆæ”¹å–„ï¼‰- å¼·åŒ–ç‰ˆ
            const healthImprovePatterns = [
                /(å|å˜”å|åãæˆ»ã—).{0,20}(æ¸›[ã£ãŸã‚Š]|ãªããª[ã£ãŸã‚Š]|ã—ãªããª[ã£ãŸã‚Š]|æ”¹å–„|è‰¯ããª[ã£ãŸã‚Š]|æ¸›å°‘|æ²»[ã£ãŸã¾ã‚Š])/,
                /ä¾¿.{0,20}(è‰¯[ãã„ã‹]ãª[ã£ãŸã‚Š]|æ”¹å–„|èª¿å­ãŒè‰¯|å¿«èª¿|ã—ã£ã‹ã‚Š|æ­£å¸¸|å›ºã|ç¡¬ã)/,
                /ã†ã‚“ã¡.{0,20}(è‰¯[ãã„ã‹]ãª[ã£ãŸã‚Š]|æ”¹å–„|ã—ã£ã‹ã‚Š|æ­£å¸¸)/,
                /æ¯›ç‰.{0,20}(æ¸›[ã£ãŸã‚Š]|ãªããª[ã£ãŸã‚Š]|å°‘ãª[ãã„])/,
                /æ¯›ä¸¦ã¿.{0,10}(è‰¯|ç¶ºéº—|ãƒ„ãƒ¤|ã‚µãƒ©ã‚µãƒ©)/
            ];
            healthImprovePatterns.forEach(pattern => {
                if (lowerText.match(pattern)) scores['åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„'] += 12 * weight;
            });
            
            // å¥åº·é–¢é€£ï¼ˆæ‚ªåŒ–ï¼‰- å³æ ¼ç‰ˆï¼ˆéå‰°åˆ†é¡ä¿®æ­£ï¼‰
            const healthWorsenPatterns = [
                /å[ãã„ãŸãã‘]|å˜”å|åãæˆ»[ã—ã™ã‚Š]|ã‚‚ã©[ã™ã—]/,
                /ä¸‹ç—¢|ã’ã‚Š|è»Ÿä¾¿|è¡€ä¾¿|ä¾¿ç§˜|ã¹ã‚“ã´/,
                /ä¾¿.{0,5}(ç·©[ã„ãã‚]|æ‚ª[ã„ãã‚]|è‡­[ã„ãã‚]|é»’[ã„ãã‚])/,
                /ã†ã‚“ã¡.{0,10}(ç·©[ã„ãã‚]|æ‚ª[ã„ãã‚]|è‡­[ã„ãã‚])/
            ];
            // æ”¹å–„ç³»ã®é™¤å¤–ã‚’å¼·åŒ–
            const hasHealthImprovement = lowerText.match(/(æ¸›[ã£ãŸã‚Š]|ãªããª[ã£ãŸã‚Š]|ã—ãªããª[ã£ãŸã‚Š]|æ”¹å–„|è‰¯ããª[ã£ãŸã‚Š]|æ²»[ã£ãŸã¾ã‚Š]|å…ƒæ°—|å¥åº·|èª¿å­.{0,5}è‰¯)/);
            
            if (!hasHealthImprovement) {
                healthWorsenPatterns.forEach(pattern => {
                    if (lowerText.match(pattern)) scores['åããƒ»ä¾¿ãŒæ‚ªããªã‚‹'] += 8 * weight;  // ã‚¹ã‚³ã‚¢ä¸‹ã’
                });
            }
            
            // ä¾¡æ ¼é–¢é€£ã®å¼·åŒ–ï¼ˆæ¤œå‡ºä¸è¶³ä¿®æ­£ï¼‰
            const pricePatterns = {
                'å€¤ä¸ŠãŒã‚Š/é«˜ã„': {
                    strong: [
                        /å€¤ä¸Š[ã’ãŒã‚Š].{0,10}(å›°[ã‚‹ã£ã‚Š]|è¾›[ã„ã]|ãã¤[ã„ã])/,
                        /é«˜ããª[ã£ã‚Š].{0,10}(å›°[ã‚‹ã£ã‚Š]|è²·[ãˆã„]ãªã„|ç¶š[ã‘ã‚‰]ãªã„)/,
                        /ä¾¡æ ¼.{0,5}ä¸ŠãŒ[ã£ã‚Š].{0,10}(æ®‹å¿µ|å›°[ã‚‹ã£ã‚Š])/,
                        /\d+å††.{0,10}(é«˜[ã„ã]|ãŸã‹[ã„ã]).{0,10}(æ„Ÿã˜|æ€[ã†ãˆ])/,
                        /å€¤ä¸Š[ã’ãŒã‚Š]/, /é«˜[ã„ãã‚]/, /ãŸã‹[ã„ãã‚]/, /é«˜ä¾¡/, /é«˜é¡/,
                        /ã‚‚ã†å°‘ã—.{0,10}å®‰[ãã‘]/, /å€¤æ®µ.{0,5}(é«˜[ã„ãã‚]|ãŸã‹[ã„ãã‚])/
                    ],
                    exclusions: [
                        /(å“è³ª|æ „é¤Š|åŸææ–™).{0,20}(è€ƒãˆã‚‹|æ€ã†).{0,10}é«˜[ãã‘]ãªã„/,
                        /(ã§ã‚‚|ã‘ã©|ãŒ).{0,20}(æº€è¶³|è‰¯[ã„ã]|ãŠã™ã™ã‚)/
                    ]
                },
                'å®‰ã„': {
                    strong: [
                        /ã‚³ã‚¹ãƒ‘.{0,5}(è‰¯[ã„ã]|æœ€é«˜|æŠœç¾¤)/,
                        /ãŠå¾—.{0,5}(æ„Ÿ|ã ã¨æ€[ã†ãˆ]|è³¼å…¥)/,
                        /\d+å††.{0,10}å®‰[ã„ã].{0,10}(åŠ©ã‹[ã‚‹ã£ã‚Š]|å¬‰ã—[ã„ã])/,
                        /å®‰[ã„ãã‚]|ã‚„ã™[ã„ãã‚]/, /æ‰‹é ƒ|æ‰‹ã”ã‚|ãƒªãƒ¼ã‚ºãƒŠãƒ–ãƒ«|å‰²å®‰|ãŠè²·ã„å¾—/,
                        /ä¾¡æ ¼.{0,5}(æº€è¶³|ç´å¾—)/
                    ],
                    exclusions: [
                        /(å®‰[ã„ã]ã‹ã‚‰|å®‰ä¾¡ã ã‹ã‚‰).{0,20}(ä¸å®‰|å¿ƒé…|è³ª)/,
                        /å®‰[ã„ã].{0,10}(ã‘ã©|ã§ã‚‚|ãŒ).{0,10}(å“è³ª|æ „é¤Š)/
                    ]
                }
            };
            
            // ä¾¡æ ¼é–¢é€£ã®æ¤œå‡ºå¼·åŒ–
            const hasPriceExclusion = 
                pricePatterns['å€¤ä¸ŠãŒã‚Š/é«˜ã„'].exclusions.some(p => lowerText.match(p)) ||
                pricePatterns['å®‰ã„'].exclusions.some(p => lowerText.match(p));
            
            if (!hasPriceExclusion) {
                pricePatterns['å€¤ä¸ŠãŒã‚Š/é«˜ã„'].strong.forEach(pattern => {
                    if (lowerText.match(pattern)) scores['å€¤ä¸ŠãŒã‚Š/é«˜ã„'] += 12 * weight;
                });
                
                pricePatterns['å®‰ã„'].strong.forEach(pattern => {
                    if (lowerText.match(pattern)) scores['å®‰ã„'] += 12 * weight;
                });
            }
            
            // ç·Šæ€¥ä¿®æ­£ï¼šæ•™å¸«ãƒ‡ãƒ¼ã‚¿ã«åŸºã¥ãå³æ ¼ãªãƒ‘ã‚¿ãƒ¼ãƒ³
            const correctedPatterns = {
                'é…é€ãƒ»æ¢±åŒ…': [
                    /é…é€|æ¢±åŒ…|ç™ºé€|å±Š[ãã„ãã‘]|ç®±|åŒ…è£…|é…é”|å®…é…|è·ç‰©|æ®µãƒœãƒ¼ãƒ«|ãƒ€ãƒ³ãƒœãƒ¼ãƒ«/
                    // ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸æƒ…å ±ç³»ã¯å‰Šé™¤ï¼ˆéå‰°åˆ†é¡ã®åŸå› ï¼‰
                ],
                'è³å‘³æœŸé™': [
                    /è³å‘³æœŸé™|æ¶ˆè²»æœŸé™|æœŸé™|æ—¥ä»˜|ä½¿ç”¨æœŸé™|æœ‰åŠ¹æœŸé™/
                ],
                'ã‚¸ãƒƒãƒ‘ãƒ¼': [
                    /ã‚¸ãƒƒãƒ‘ãƒ¼|ãƒãƒ£ãƒƒã‚¯|å¯†å°|ã‚¸ãƒƒãƒ—|ä¿å­˜.{0,10}(ä¸ä¾¿|å›°)|è¢‹.{0,10}(é–‰|ç· )|ãƒ•ã‚¡ã‚¹ãƒŠãƒ¼/
                ],
                'åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„': [
                    /(å|å˜”å|åãæˆ»ã—).{0,20}(æ¸›[ã£ãŸã‚Š]|ãªããª[ã£ãŸã‚Š]|ã—ãªããª[ã£ãŸã‚Š]|æ”¹å–„|è‰¯ããª[ã£ãŸã‚Š]|æ¸›å°‘|æ²»[ã£ãŸã¾ã‚Š])/,
                    /ä¾¿.{0,20}(è‰¯[ãã„ã‹]ãª[ã£ãŸã‚Š]|æ”¹å–„|èª¿å­ãŒè‰¯|å¿«èª¿|ã—ã£ã‹ã‚Š|æ­£å¸¸|å›ºã|ç¡¬ã)/,
                    /ã†ã‚“ã¡.{0,20}(è‰¯[ãã„ã‹]ãª[ã£ãŸã‚Š]|æ”¹å–„|ã—ã£ã‹ã‚Š|æ­£å¸¸)/,
                    /æ¯›ç‰.{0,20}(æ¸›[ã£ãŸã‚Š]|ãªããª[ã£ãŸã‚Š]|å°‘ãª[ãã„])/
                    // æ¯›ä¸¦ã¿ãƒ»ä½“é‡ç³»ã¯å‰Šé™¤ï¼ˆæœ¬æ¥ã®æ„å‘³ã«æˆ»ã™ï¼‰
                ],
                'é£Ÿã¹ã‚‹': [
                    /å®Œé£Ÿ/, /ãƒšãƒ­ãƒª/, /ãƒšãƒ­ãƒƒã¨/, /ãƒã‚¯ãƒã‚¯/, /ãŒã£ã¤[ãã]/,
                    /å¤¢ä¸­.{0,10}é£Ÿã¹/, /å‹¢ã„.{0,10}é£Ÿã¹/, /é£›ã³ä»˜/,
                    /å–œã‚“ã§.{0,15}å®Œé£Ÿ/, /ç¾å‘³ã—ãã†ã«.{0,10}é£Ÿã¹/,
                    /ã‚ˆãé£Ÿã¹/, /é£Ÿã¹[ã‚‹ã¦ãŸã‚Š]/, /ãŸã¹[ã‚‹ã¦ãŸã‚Š]/,
                    /é£Ÿã„ã¤[ããã„].{0,5}(è‰¯|ã„ã„|ã‚ˆ[ã„ãã‹])/, 
                    /ç¾å‘³[ã—ã]/, /ãŠã„ã—/, /æ°—ã«å…¥/, /å¤§å¥½ã/,
                    /å–œã‚“ã§/, /ãŠæ°—ã«å…¥ã‚Š/, /ãƒªãƒ”ãƒ¼ãƒˆ/,
                    /ã™ãã«é£Ÿã¹/, /ä¸€ç¬ã§é£Ÿã¹/, /ã™ã”ã„å‹¢ã„ã§/
                    // è³¼å…¥ç³»ã¯å‰Šé™¤ï¼ˆæœ¬æ¥ã®æ„å‘³ã«æˆ»ã™ï¼‰
                ],
                'é£Ÿã¹ãªã„': [
                    /å…¨ãé£Ÿã¹ãªã„/, /å…¨ç„¶é£Ÿã¹ãªã„/, /çµ¶å¯¾ã«é£Ÿã¹ãªã„/,
                    /è¦‹å‘ãã‚‚ã—ãªã„/, /å®Œå…¨æ‹’å¦/, /ä¸€å£ã‚‚é£Ÿã¹/,
                    /åŒ‚ã„.{0,5}å—…[ã„ã]ã ã ã‘.{0,10}(çµ‚ã‚ã‚Š|ãŠã—ã¾ã„)/,
                    /é£Ÿã¹(ã¦ãã‚Œ)?ãª[ã„ã‹]/, /æ‹’å¦.{0,10}ã™ã‚‹/,
                    /å£ã«ã—ãª[ã„ã‹]/, /ãã£ã½.{0,5}å‘[ãã]/,
                    /è­¦æˆ’.{0,10}ã—ã¦.{0,5}é£Ÿã¹ãª[ã„ã‹]/,
                    /è¿‘ã¥[ã‹ã]ã‚‚ã—ãª[ã„ã‹]/,
                    /æ®‹ã—ã¦/, /é£Ÿã¹æ®‹[ã™ã—]/, /åŒ‚ã„.{0,5}å—…[ã„ã]ã ã ã‘/,
                    /èˆˆå‘³.{0,5}ç¤ºã•ãª/, /é£Ÿã„ã¤[ã‹ãã].{0,5}(æ‚ª|ãªã„|ãƒ€ãƒ¡)/,
                    /é£Ÿã¹[ã‚‹ã¦].{0,5}(ã®ã«|ã‘ã©).{0,5}æ™‚é–“.{0,5}ã‹ã‹[ã‚‹ã£ã‚Š]/
                ]
            };
            
            // ä¿®æ­£ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°
            Object.entries(correctedPatterns).forEach(([category, patterns]) => {
                patterns.forEach(pattern => {
                    if (lowerText.match(pattern)) {
                        scores[category] += 10 * weight;
                    }
                });
            });
            
            // ã€Œãã®ä»–ã€ã¨ã—ã¦åˆ†é¡ã™ã¹ããƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œå‡º
            const otherExclusivePatterns = {
                åŸææ–™æˆåˆ†: /åŸææ–™|æˆåˆ†|ææ–™|ä¸­èº«é‡è¦–|ç´ æ|æ·»åŠ ç‰©|ã‚°ãƒ¬ã‚¤ãƒ³ãƒ•ãƒªãƒ¼|ç©€ç‰©ä¸ä½¿ç”¨|ç„¡æ·»åŠ |ä¿å­˜æ–™|ç€è‰²æ–™|å¤©ç„¶ç´ æ/,
                éæ¶ˆåŒ–å™¨ç³»å¥åº·: /æ¯›ä¸¦ã¿|æ¯›è‰¶|æ¯›è³ª|ã‚¢ãƒ¬ãƒ«ã‚®ãƒ¼|çš®è†š|ç—’ã¿|ã‹ã‚†ã¿|ä½“èª¿(?!ä¸è‰¯)|æ¯›ç‰ã‚±ã‚¢|ãƒ€ãƒ–ãƒ«ã‚³ãƒ¼ãƒˆ|æ›æ¯›æœŸ/,
                ç”¨é€”ç›®çš„: /å·®ã—å…¥ã‚Œ|ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆ|è´ˆã‚Šç‰©|ä¿è­·çŒ«|å¯„ä»˜|ã‚®ãƒ•ãƒˆ/,
                è¦‹ãŸç›®å½¢çŠ¶: /è‰²(?!ã€…)|è¦‹ãŸç›®|å½¢(?!æˆ)|å¤–è¦³(?!æ¢±åŒ…)|è³ªæ„Ÿ/
            };
            
            // ã€Œãã®ä»–ã€ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºæ™‚ã®ã‚¹ã‚³ã‚¢åŠ ç®—
            let hasOtherPattern = false;
            Object.entries(otherExclusivePatterns).forEach(([type, pattern]) => {
                if (lowerText.match(pattern)) {
                    scores['ãã®ä»–'] += 15 * weight;
                    hasOtherPattern = true;
                }
            });
            
            // ã€Œé£Ÿã¹ã‚‹ã€ã‚«ãƒ†ã‚´ãƒªã®å³æ ¼åŒ–
            if (hasOtherPattern) {
                // åŸææ–™ãƒ»æˆåˆ†ãƒ»å¥åº·æ”¹å–„ãªã©ã®è¨€åŠãŒã‚ã‚‹å ´åˆã¯ã€Œé£Ÿã¹ã‚‹ã€ã‚¹ã‚³ã‚¢ã‚’å¤§å¹…æ¸›ç‚¹
                const actualEatingPattern = /é£Ÿã¹[ã¦ã‚‹]|é£Ÿã„ä»˜|ãŒã£ã¤ã|å®Œé£Ÿ|å¹³ã‚‰ã’|ã‚€ã—ã‚ƒã‚€ã—ã‚ƒ|ãºã‚ã‚Š|å–œã‚“ã§é£Ÿã¹|ã‚ˆãé£Ÿã¹|ãŸãã•ã‚“é£Ÿã¹|ç¾å‘³ã—ãã†ã«/;
                if (!lowerText.match(actualEatingPattern)) {
                    scores['é£Ÿã¹ã‚‹'] -= 20 * weight;
                }
            }
            
            // éæ¶ˆåŒ–å™¨ç³»å¥åº·æ”¹å–„ã¯ã€Œåãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„ã€ã‹ã‚‰é™¤å¤–
            if (lowerText.match(otherExclusivePatterns.éæ¶ˆåŒ–å™¨ç³»å¥åº·)) {
                scores['åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„'] -= 15 * weight;
            }
            
            return scores;
        }

        // ğŸ¯ Phase 3ç”¨å¼·åŒ–ç‰ˆã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ 
        function calculateLabelScoresEnhanced(reviewText, context = null) {
            const scores = {
                'é£Ÿã¹ã‚‹': 0,
                'é£Ÿã¹ãªã„': 0,
                'åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„': 0,
                'åããƒ»ä¾¿ãŒæ‚ªããªã‚‹': 0,
                'å®‰ã„': 0,
                'é…é€ãƒ»æ¢±åŒ…': 0,
                'å€¤ä¸ŠãŒã‚Š/é«˜ã„': 0,
                'è³å‘³æœŸé™': 0,
                'ã‚¸ãƒƒãƒ‘ãƒ¼': 0,
                'ãã®ä»–': 0
            };
            
            // æ—©æœŸã€Œãã®ä»–ã€åˆ¤å®šã®ãŸã‚ã®äº‹å‰ãƒã‚§ãƒƒã‚¯
            const lowerText = reviewText.toLowerCase();
            const otherPatterns = {
                åŸææ–™æˆåˆ†: /åŸææ–™|æˆåˆ†|ææ–™|ä¸­èº«é‡è¦–|ç´ æ|æ·»åŠ ç‰©|ã‚°ãƒ¬ã‚¤ãƒ³ãƒ•ãƒªãƒ¼|ç©€ç‰©ä¸ä½¿ç”¨|ç„¡æ·»åŠ |ä¿å­˜æ–™|ç€è‰²æ–™|å¤©ç„¶ç´ æ/,
                éæ¶ˆåŒ–å™¨ç³»å¥åº·: /æ¯›ä¸¦ã¿|æ¯›è‰¶|æ¯›è³ª|ã‚¢ãƒ¬ãƒ«ã‚®ãƒ¼|çš®è†š|ç—’ã¿|ã‹ã‚†ã¿|ä½“èª¿(?!ä¸è‰¯)|æ¯›ç‰ã‚±ã‚¢|ãƒ€ãƒ–ãƒ«ã‚³ãƒ¼ãƒˆ|æ›æ¯›æœŸ/,
                ç”¨é€”ç›®çš„: /å·®ã—å…¥ã‚Œ|ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆ|è´ˆã‚Šç‰©|ä¿è­·çŒ«|å¯„ä»˜|ã‚®ãƒ•ãƒˆ/,
                è¦‹ãŸç›®å½¢çŠ¶: /è‰²(?!ã€…)|è¦‹ãŸç›®|å½¢(?!æˆ)|å¤–è¦³(?!æ¢±åŒ…)|è³ªæ„Ÿ/
            };
            
            let isLikelyOther = false;
            Object.values(otherPatterns).forEach(pattern => {
                if (lowerText.match(pattern)) {
                    isLikelyOther = true;
                }
            });
            
            // æ™‚ç³»åˆ—é‡ã¿ä»˜ã‘ã‚’ã‚ˆã‚Šç´°ã‹ãåˆ¶å¾¡
            const timeWeights = {
                pastNegative: 0.1,    // éå»ã®ãƒã‚¬ãƒ†ã‚£ãƒ–
                pastPositive: 0.3,    // éå»ã®ãƒã‚¸ãƒ†ã‚£ãƒ–  
                currentNegative: 2.0, // ç¾åœ¨ã®ãƒã‚¬ãƒ†ã‚£ãƒ–
                currentPositive: 3.0, // ç¾åœ¨ã®ãƒã‚¸ãƒ†ã‚£ãƒ–
                transition: 1.5       // è»¢æ›è¡¨ç¾
            };
            
            // æ–‡è„ˆåˆ†æçµæœã‚’è€ƒæ…®ã—ãŸã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°
            if (context && context.timelineDetected) {
                // ã‚ˆã‚Šè©³ç´°ãªé‡ã¿ä»˜ã‘ãƒ­ã‚¸ãƒƒã‚¯
                context.currentContext.forEach(ctx => {
                    // ãƒã‚¸ãƒ†ã‚£ãƒ–ãƒ»ãƒã‚¬ãƒ†ã‚£ãƒ–åˆ¤å®š
                    const isPositive = ctx.sentence.match(/è‰¯|ã„ã„|å¥½|æ°—ã«å…¥|æº€è¶³|å–œ|å®Œé£Ÿ|ç¾å‘³/);
                    const weight = isPositive ? timeWeights.currentPositive : timeWeights.currentNegative;
                    addScoresByKeywordsEnhanced(ctx.sentence, scores, weight);
                });
                
                context.pastContext.forEach(ctx => {
                    const isPositive = ctx.sentence.match(/è‰¯|ã„ã„|å¥½|æ°—ã«å…¥|æº€è¶³|å–œ|å®Œé£Ÿ|ç¾å‘³/);
                    const weight = isPositive ? timeWeights.pastPositive : timeWeights.pastNegative;
                    addScoresByKeywordsEnhanced(ctx.sentence, scores, weight);
                });
                
                // è»¢æ›è¡¨ç¾ãŒã‚ã‚‹å ´åˆã®å‡¦ç†
                if (context.hasTransition) {
                    const sentences = reviewText.split(/[ã€‚ï¼ï¼Ÿ\n]/).filter(s => s.trim());
                    sentences.forEach((sentence, index) => {
                        if (sentence.match(/(ã—ã‹ã—|ã¨ã“ã‚ãŒ|ã§ã‚‚|ã‘ã‚Œã©|ãŒã€|ãŸã )/)) {
                            addScoresByKeywordsEnhanced(sentence, scores, timeWeights.transition);
                        }
                    });
                }
                
                // æ®‹ã‚Šã®æ–‡ç« ã¯é€šå¸¸é‡ã¿
                const processedIndices = [
                    ...context.currentContext.map(c => c.index),
                    ...context.pastContext.map(c => c.index)
                ];
                
                const remainingSentences = reviewText.split(/[ã€‚ï¼ï¼Ÿ\n]/)
                    .filter((_, index) => !processedIndices.includes(index))
                    .join('ã€‚');
                    
                if (remainingSentences) {
                    addScoresByKeywordsEnhanced(remainingSentences, scores, 1.0);
                }
            } else {
                // é€šå¸¸ã®ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°
                addScoresByKeywordsEnhanced(reviewText, scores, 1.0);
            }
            
            return scores;
        }

        // ğŸ¯ éšå±¤çš„åˆ†é¡ã‚·ã‚¹ãƒ†ãƒ ï¼ˆå„ªå…ˆåº¦2å¯¾å¿œï¼‰
        function getTopScoringLabelHierarchical(scores) {
            const maxScore = Math.max(...Object.values(scores));
            const topLabels = Object.entries(scores)
                .filter(([_, score]) => score === maxScore)
                .map(([label, _]) => label);
            
            // éšå±¤çš„å„ªå…ˆé †ä½ï¼ˆé«˜ç²¾åº¦é †ãƒ»10ã‚«ãƒ†ã‚´ãƒªå¯¾å¿œï¼‰
            const hierarchicalPriority = [
                // ç¬¬1å±¤: æ˜ç¢ºãªå…·ä½“çš„ã‚«ãƒ†ã‚´ãƒªï¼ˆèª¤åˆ†é¡ãƒªã‚¹ã‚¯æœ€å°ï¼‰
                'è³å‘³æœŸé™', 'ã‚¸ãƒƒãƒ‘ãƒ¼', 'é…é€ãƒ»æ¢±åŒ…',
                
                // ç¬¬2å±¤: å¥åº·é–¢é€£ï¼ˆé‡è¦åº¦é«˜ï¼‰
                'åããƒ»ä¾¿ãŒæ‚ªããªã‚‹', 'åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„',
                
                // ç¬¬3å±¤: é£Ÿäº‹é–¢é€£ï¼ˆä¸»è¦ã‚«ãƒ†ã‚´ãƒªï¼‰
                'é£Ÿã¹ãªã„', 'é£Ÿã¹ã‚‹',
                
                // ç¬¬4å±¤: ä¾¡æ ¼é–¢é€£ï¼ˆéå‰°åˆ†é¡å¯¾ç­–æ¸ˆã¿ï¼‰
                'å€¤ä¸ŠãŒã‚Š/é«˜ã„', 'å®‰ã„',
                
                // ç¬¬5å±¤: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                'ãã®ä»–'
            ];
            
            return hierarchicalPriority.find(label => topLabels.includes(label)) || 'ãã®ä»–';
        }
        
        // éšå±¤çš„åˆ†é¡åˆ¤å®šã‚·ã‚¹ãƒ†ãƒ ï¼ˆã€Œãã®ä»–ã€å„ªå…ˆåˆ¤å®šå¼·åŒ–ç‰ˆï¼‰
        function classifyHierarchically(reviewText, scores) {
            const lowerText = reviewText.toLowerCase();
            
            // æ—©æœŸã€Œãã®ä»–ã€åˆ¤å®š
            const otherPatterns = {
                åŸææ–™æˆåˆ†: /åŸææ–™|æˆåˆ†|ææ–™|ä¸­èº«é‡è¦–|ç´ æ|æ·»åŠ ç‰©|ã‚°ãƒ¬ã‚¤ãƒ³ãƒ•ãƒªãƒ¼|ç©€ç‰©ä¸ä½¿ç”¨|ç„¡æ·»åŠ |ä¿å­˜æ–™|ç€è‰²æ–™|å¤©ç„¶ç´ æ/,
                éæ¶ˆåŒ–å™¨ç³»å¥åº·: /æ¯›ä¸¦ã¿|æ¯›è‰¶|æ¯›è³ª|ã‚¢ãƒ¬ãƒ«ã‚®ãƒ¼|çš®è†š|ç—’ã¿|ã‹ã‚†ã¿|ä½“èª¿(?!ä¸è‰¯)|æ¯›ç‰ã‚±ã‚¢|ãƒ€ãƒ–ãƒ«ã‚³ãƒ¼ãƒˆ|æ›æ¯›æœŸ/,
                ç”¨é€”ç›®çš„: /å·®ã—å…¥ã‚Œ|ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆ|è´ˆã‚Šç‰©|ä¿è­·çŒ«|å¯„ä»˜|ã‚®ãƒ•ãƒˆ/,
                è¦‹ãŸç›®å½¢çŠ¶: /è‰²(?!ã€…)|è¦‹ãŸç›®|å½¢(?!æˆ)|å¤–è¦³(?!æ¢±åŒ…)|è³ªæ„Ÿ/
            };
            
            // ã€Œãã®ä»–ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒæ¤œå‡ºã•ã‚Œã€ã‹ã¤ä»–ã®å¼·ã„ã‚·ã‚°ãƒŠãƒ«ãŒãªã„å ´åˆ
            let hasOtherPattern = false;
            Object.values(otherPatterns).forEach(pattern => {
                if (lowerText.match(pattern)) {
                    hasOtherPattern = true;
                }
            });
            
            if (hasOtherPattern) {
                // ä»–ã®ã‚«ãƒ†ã‚´ãƒªã®å¼·ã„ã‚·ã‚°ãƒŠãƒ«ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                const strongSignals = {
                    'é£Ÿã¹ã‚‹': /é£Ÿã¹[ã¦ã‚‹]|é£Ÿã„ä»˜|ãŒã£ã¤ã|å®Œé£Ÿ|å¹³ã‚‰ã’|ã‚€ã—ã‚ƒã‚€ã—ã‚ƒ|ãºã‚ã‚Š|å–œã‚“ã§é£Ÿã¹|ã‚ˆãé£Ÿã¹|ãŸãã•ã‚“é£Ÿã¹|ç¾å‘³ã—ãã†ã«/,
                    'é£Ÿã¹ãªã„': /å…¨ãé£Ÿã¹ãªã„|è¦‹å‘ãã‚‚ã—ãªã„|å®Œå…¨æ‹’å¦|ä¸€å£ã‚‚é£Ÿã¹/,
                    'åããƒ»ä¾¿ãŒæ‚ªããªã‚‹': /å[ãã„ãŸ]|ä¸‹ç—¢|è»Ÿä¾¿|è¡€ä¾¿/,
                    'åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„': /ä¾¿.{0,20}(è‰¯[ãã„]ãª[ã£ãŸã‚Š]|æ”¹å–„|å¿«èª¿)|å.{0,20}(æ¸›[ã£ãŸã‚Š]|ãªããª[ã£ãŸã‚Š]|æ”¹å–„)/
                };
                
                let hasStrongSignal = false;
                Object.entries(strongSignals).forEach(([category, pattern]) => {
                    if (lowerText.match(pattern) && scores[category] >= 15) {
                        hasStrongSignal = true;
                    }
                });
                
                if (!hasStrongSignal) {
                    return 'ãã®ä»–';
                }
            }
            
            // ç¬¬1æ®µéš: æ˜ç¢ºãªåˆ¤å®šï¼ˆé«˜ä¿¡é ¼åº¦ï¼‰
            if (scores['è³å‘³æœŸé™'] >= 6) return 'è³å‘³æœŸé™';
            if (scores['ã‚¸ãƒƒãƒ‘ãƒ¼'] >= 6) return 'ã‚¸ãƒƒãƒ‘ãƒ¼';
            if (scores['é…é€ãƒ»æ¢±åŒ…'] >= 8) return 'é…é€ãƒ»æ¢±åŒ…';
            
            // ç¬¬2æ®µéš: å¥åº·é–¢é€£ï¼ˆä¸­ï½é«˜ä¿¡é ¼åº¦ï¼‰
            if (scores['åããƒ»ä¾¿ãŒæ‚ªããªã‚‹'] >= 8) return 'åããƒ»ä¾¿ãŒæ‚ªããªã‚‹';
            if (scores['åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„'] >= 8) return 'åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„';
            
            // ç¬¬3æ®µéš: é£Ÿäº‹é–¢é€£ï¼ˆã‚¹ã‚³ã‚¢é‡è¦–ãƒ»å¼·åŒ–ç‰ˆï¼‰
            if (scores['é£Ÿã¹ãªã„'] >= 10) return 'é£Ÿã¹ãªã„';
            if (scores['é£Ÿã¹ã‚‹'] >= 10) return 'é£Ÿã¹ã‚‹';
            if (scores['é£Ÿã¹ãªã„'] >= 8) return 'é£Ÿã¹ãªã„';
            if (scores['é£Ÿã¹ã‚‹'] >= 8) return 'é£Ÿã¹ã‚‹';
            
            // ç¬¬4æ®µéš: ä¾¡æ ¼é–¢é€£ï¼ˆå³æ ¼åˆ¤å®šï¼‰
            if (scores['å€¤ä¸ŠãŒã‚Š/é«˜ã„'] >= 10) return 'å€¤ä¸ŠãŒã‚Š/é«˜ã„';
            if (scores['å®‰ã„'] >= 10) return 'å®‰ã„';
            
            // ç¬¬5æ®µéš: ç©æ¥µçš„åˆ†é¡ï¼ˆé–¾å€¤ã‚’å¤§å¹…ã«ä¸‹ã’ã‚‹ï¼‰
            const maxScore = Math.max(...Object.values(scores));
            if (maxScore >= 6) {
                return getTopScoringLabelHierarchical(scores);
            }
            if (maxScore >= 4) {
                return getTopScoringLabelHierarchical(scores);
            }
            if (maxScore >= 2) {
                return getTopScoringLabelHierarchical(scores);
            }
            
            return 'ãã®ä»–';
        }

        // ğŸ¤– è‡ªå‹•åˆ†æ: æ–°ã—ã„å®Œå…¨ç‰ˆãƒ©ãƒ™ãƒ«æ¤œå‡º
        async function detectLabelsFromConfigV2(reviewText) {
            if (!reviewText) return 'ãã®ä»–';
            
            // è‡ªå‹•åˆ†é¡å‡¦ç†
            return await detectLabels(reviewText);
        }

        // ğŸ¯ æ–°æ©Ÿèƒ½: ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°é–¢æ•°ï¼ˆPhase 2ç”¨ï¼‰
        function addScoresByKeywords(text, scores, weight = 1.0) {
            const lowerText = text.toLowerCase();
            
            // é£Ÿã¹ã‚‹é–¢é€£
            const eatPatterns = {
                strong: [
                    /å–œã‚“ã§.{0,20}(å®Œé£Ÿ|é£Ÿã¹)/,
                    /é£›ã³ä»˜ã„ã¦.{0,20}é£Ÿã¹/,
                    /(ãƒã‚¯ãƒã‚¯|ãŒã£ã¤[ãã]).{0,10}é£Ÿã¹/,
                    /ç¾å‘³ã—ãã†.{0,10}é£Ÿã¹/
                ],
                medium: [
                    /å®Œé£Ÿ/, /ã‚ˆãé£Ÿã¹/, /ç¾å‘³ã—ã„/, /ãŠã„ã—ã„/,
                    /æ°—ã«å…¥[ã£ã‚Š]/, /å¤§å¥½ã/, /ãŠæ°—ã«å…¥ã‚Š/
                ]
            };
            
            eatPatterns.strong.forEach(pattern => {
                if (lowerText.match(pattern)) scores['é£Ÿã¹ã‚‹'] += 10 * weight;
            });
            eatPatterns.medium.forEach(pattern => {
                if (lowerText.match(pattern)) scores['é£Ÿã¹ã‚‹'] += 5 * weight;
            });
            
            // é£Ÿã¹ãªã„é–¢é€£
            const noEatPatterns = {
                strong: [
                    /å…¨ãé£Ÿã¹ãªã„/, /è¦‹å‘ãã‚‚ã—ãªã„/, /æ‹’å¦.{0,10}ã™ã‚‹/
                ],
                medium: [
                    /é£Ÿã¹(ã¦)?ãã‚Œãª[ã„ã‹]/, /æ®‹ã—ã¦/, /å£ã«ã—ãª[ã„ã‹]/
                ],
                exclusions: [
                    /(ä»Šã¾ã§|ä»¥å‰|ã“ã‚Œã¾ã§).{0,50}é£Ÿã¹.*ãª[ã„ã‹]/  // éå»ã®è©±ã¯é™¤å¤–
                ]
            };
            
            // é™¤å¤–ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒã‚§ãƒƒã‚¯
            const hasExclusion = noEatPatterns.exclusions.some(pattern => 
                lowerText.match(pattern));
            
            if (!hasExclusion) {
                noEatPatterns.strong.forEach(pattern => {
                    if (lowerText.match(pattern)) scores['é£Ÿã¹ãªã„'] += 10 * weight;
                });
                noEatPatterns.medium.forEach(pattern => {
                    if (lowerText.match(pattern)) scores['é£Ÿã¹ãªã„'] += 5 * weight;
                });
            }
            
            // å¥åº·é–¢é€£ï¼ˆæ”¹å–„ï¼‰
            if (lowerText.match(/(å|å˜”å).{0,20}(æ¸›[ã£ãŸã‚Š]|ãªããª[ã£ãŸã‚Š]|æ”¹å–„)/)) {
                scores['åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„'] += 8 * weight;
            }
            if (lowerText.match(/ä¾¿.{0,20}(è‰¯[ãã„]ãª[ã£ãŸã‚Š]|æ”¹å–„|å¿«èª¿)/)) {
                scores['åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„'] += 8 * weight;
            }
            
            // å¥åº·é–¢é€£ï¼ˆæ‚ªåŒ–ï¼‰
            if (lowerText.match(/å[ãã„ãŸ]|ä¸‹ç—¢|è»Ÿä¾¿|è¡€ä¾¿/) && 
                !lowerText.match(/(æ¸›[ã£ãŸã‚Š]|æ”¹å–„|è‰¯ããª)/)) {
                scores['åããƒ»ä¾¿ãŒæ‚ªããªã‚‹'] += 8 * weight;
            }
            
            // é…é€ãƒ»æ¢±åŒ…é–¢é€£
            if (lowerText.match(/é…é€|æ¢±åŒ…|ç™ºé€|å±Š[ãã„ãã‘]|ç®±|åŒ…è£…|é…é”/)) {
                scores['é…é€ãƒ»æ¢±åŒ…'] += 8 * weight;
            }
            
            // ä¾¡æ ¼é–¢é€£
            if (lowerText.match(/å€¤ä¸Š[ã’ãŒã‚Š]|é«˜[ã„ãã‚]|ãŸã‹[ã„ãã‚]|é«˜ä¾¡/)) {
                scores['å€¤ä¸ŠãŒã‚Š/é«˜ã„'] += 8 * weight;
            }
            if (lowerText.match(/å®‰[ã„ãã‚]|ã‚„ã™[ã„ãã‚]|ãŠå¾—|ã‚³ã‚¹ãƒ‘|æ‰‹é ƒ/)) {
                scores['å®‰ã„'] += 8 * weight;
            }
            
            // è³å‘³æœŸé™é–¢é€£
            if (lowerText.match(/è³å‘³æœŸé™|æ¶ˆè²»æœŸé™|æœŸé™|æ—¥ä»˜/)) {
                scores['è³å‘³æœŸé™'] += 8 * weight;
            }
            
            // ã‚¸ãƒƒãƒ‘ãƒ¼é–¢é€£
            if (lowerText.match(/ã‚¸ãƒƒãƒ‘ãƒ¼|ãƒãƒ£ãƒƒã‚¯|å¯†å°|ã‚¸ãƒƒãƒ—|ä¿å­˜.{0,10}(ä¸ä¾¿|å›°)/)) {
                scores['ã‚¸ãƒƒãƒ‘ãƒ¼'] += 8 * weight;
            }
            
            return scores;
        }

        // ğŸ¯ æ–°æ©Ÿèƒ½: ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ 
        function calculateLabelScores(reviewText, context = null) {
            const scores = {
                'é£Ÿã¹ã‚‹': 0,
                'é£Ÿã¹ãªã„': 0,
                'åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„': 0,
                'åããƒ»ä¾¿ãŒæ‚ªããªã‚‹': 0,
                'å®‰ã„': 0,
                'é…é€ãƒ»æ¢±åŒ…': 0,
                'å€¤ä¸ŠãŒã‚Š/é«˜ã„': 0,
                'è³å‘³æœŸé™': 0,
                'ã‚¸ãƒƒãƒ‘ãƒ¼': 0,
                'ãã®ä»–': 0
            };
            
            // æ–‡è„ˆåˆ†æçµæœã‚’è€ƒæ…®ã—ãŸã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°
            if (context && context.timelineDetected) {
                // ç¾åœ¨ã®å•†å“ã«é–¢ã™ã‚‹å†…å®¹ã‚’é«˜ãè©•ä¾¡ï¼ˆé‡ã¿ 3.0ï¼‰
                context.currentContext.forEach(ctx => {
                    addScoresByKeywords(ctx.sentence, scores, 3.0);
                });
                
                // éå»ã®è©±ã¯ä½ãè©•ä¾¡ï¼ˆé‡ã¿ 0.3ï¼‰
                context.pastContext.forEach(ctx => {
                    addScoresByKeywords(ctx.sentence, scores, 0.3);
                });
                
                // æ®‹ã‚Šã®æ–‡ç« ã¯é€šå¸¸é‡ã¿ï¼ˆé‡ã¿ 1.0ï¼‰
                const processedIndices = [
                    ...context.currentContext.map(c => c.index),
                    ...context.pastContext.map(c => c.index)
                ];
                
                const remainingSentences = reviewText.split(/[ã€‚ï¼ï¼Ÿ\n]/)
                    .filter((_, index) => !processedIndices.includes(index))
                    .join('ã€‚');
                    
                if (remainingSentences) {
                    addScoresByKeywords(remainingSentences, scores, 1.0);
                }
            } else {
                // é€šå¸¸ã®ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°
                addScoresByKeywords(reviewText, scores, 1.0);
            }
            
            return scores;
        }

        // ğŸ¯ æ–°æ©Ÿèƒ½: ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ã‚·ã‚¹ãƒ†ãƒ ï¼ˆPhase 2å®Ÿè£…ï¼‰
        function detectLabelsHybrid(reviewText) {
            if (!reviewText) return 'ãã®ä»–';
            
            // Step 1: æ˜ç¢ºãªã‚«ãƒ†ã‚´ãƒªã‚’ã¾ãšåˆ¤å®šï¼ˆå„ªå…ˆåº¦é †ï¼‰
            const explicitCategories = detectLabels(reviewText);
            
            // Step 2: ã€Œãã®ä»–ã€ä»¥å¤–ãªã‚‰å¾“æ¥ç‰ˆã®çµæœã‚’æ¡ç”¨
            if (explicitCategories !== 'ãã®ä»–') {
                return explicitCategories;
            }
            
            // Step 3: æ–‡è„ˆåˆ†æã‚’æ´»ç”¨ã—ãŸã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°
            const context = analyzeReviewContext(reviewText);
            const scores = calculateLabelScores(reviewText, context);
            
            // Step 4: ä¸€å®šã‚¹ã‚³ã‚¢ä»¥ä¸Šãªã‚‰æœ€é«˜ã‚¹ã‚³ã‚¢ã®ãƒ©ãƒ™ãƒ«ã‚’æ¡ç”¨
            const maxScore = Math.max(...Object.values(scores));
            if (maxScore >= 3) {  // é–¾å€¤ã‚’3ã«è¨­å®š
                const topLabels = Object.entries(scores)
                    .filter(([_, score]) => score === maxScore);
                return topLabels[0][0];
            }
            
            // Step 5: ãã‚Œã§ã‚‚åˆ¤å®šã§ããªã„å ´åˆã®ã¿ã€Œãã®ä»–ã€
            return 'ãã®ä»–';
        }

        // ğŸ¯ æ–°æ©Ÿèƒ½: æ”¹è‰¯ç‰ˆãƒ©ãƒ™ãƒ«æ¤œå‡º
        function detectLabelsEnhanced(reviewText, context) {
            const scores = calculateLabelScores(reviewText, context);
            
            // æœ€é«˜ã‚¹ã‚³ã‚¢ã®ãƒ©ãƒ™ãƒ«ã‚’é¸æŠ
            const maxScore = Math.max(...Object.values(scores));
            
            if (maxScore === 0) return 'ãã®ä»–';
            
            const topLabels = Object.entries(scores)
                .filter(([_, score]) => score === maxScore)
                .map(([label, _]) => label);
            
            // åŒç‚¹ã®å ´åˆã®å„ªå…ˆé †ä½
            const priority = [
                'é…é€ãƒ»æ¢±åŒ…', 'è³å‘³æœŸé™', 'ã‚¸ãƒƒãƒ‘ãƒ¼',  // æ˜ç¢ºãªå¯¾è±¡ãŒã‚ã‚‹ã‚‚ã®ã‚’å„ªå…ˆ
                'åããƒ»ä¾¿ãŒæ‚ªããªã‚‹', 'åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„',  // å¥åº·é–¢é€£
                'é£Ÿã¹ãªã„', 'é£Ÿã¹ã‚‹',  // é£Ÿã„ã¤ãé–¢é€£
                'å€¤ä¸ŠãŒã‚Š/é«˜ã„', 'å®‰ã„',  // ä¾¡æ ¼é–¢é€£
                'ãã®ä»–'
            ];
            
            return priority.find(label => topLabels.includes(label)) || 'ãã®ä»–';
        }

        // ğŸ¯ é«˜ç²¾åº¦åŒ–: ãƒ¡ã‚¤ãƒ³é–¢æ•°ã®æ›´æ–°
        function detectLabelsFromConfig(reviewText) {
            if (!reviewText) return 'ãã®ä»–';
            
            // æ–‡è„ˆåˆ†æ
            const context = analyzeReviewContext(reviewText);
            
            // ã‚«ã‚¹ã‚¿ãƒ è¨­å®šãŒã‚ã‚‹å ´åˆ
            if (labelConfig.length > 0) {
                const scores = calculateLabelScores(reviewText, context);
                
                // ã‚«ã‚¹ã‚¿ãƒ ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ï¼ˆå„ªå…ˆåº¦è€ƒæ…®ï¼‰
                for (const config of labelConfig) {
                    if (config.patterns.length === 0) continue;
                    
                    let patternScore = 0;
                    const text = String(reviewText).toLowerCase();
                    
                    for (const pattern of config.patterns) {
                        try {
                            if (text.match(new RegExp(pattern, 'i'))) {
                                patternScore += 5;
                            }
                        } catch (e) {
                            console.warn(`ç„¡åŠ¹ãªæ­£è¦è¡¨ç¾: ${pattern}`, e);
                        }
                    }
                    
                    // ã‚¹ã‚³ã‚¢ã¨ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã‚’çµ„ã¿åˆã‚ã›ã¦åˆ¤å®š
                    if (patternScore > 0 && scores[config.name] >= 3) {
                        return config.name;
                    }
                }
            }
            
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆåˆ¤å®šï¼ˆæ”¹è‰¯ç‰ˆï¼‰
            return detectLabelsEnhanced(reviewText, context);
        }

        // ğŸ¤– ãƒãƒƒãƒå‡¦ç†: è¤‡æ•°ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ä¸€æ‹¬å‡¦ç†ï¼ˆæš—å·åŒ–å¯¾å¿œï¼‰
        async function processBatch(reviewBatch, categories, batchId) {
            // batchIdã‹ã‚‰å‡¦ç†ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
            const isClassification = batchId.includes('classification');
            const type = isClassification ? 'classification' : 'sentiment';
            
            try {
                // ğŸ” ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã®æº–å‚™
                const requestData = {
                    batchReviews: reviewBatch,
                    categories: categories,
                    batchId: batchId,
                    type: type
                };
                
                // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã¯å¹³æ–‡ã€æœ¬ç•ªã¯æš—å·åŒ–
                const payload = PROCESSING_CONFIG.debugMode 
                    ? requestData 
                    : CryptoUtils.obfuscateRequest(requestData);
                
                if (PROCESSING_CONFIG.debugMode) {
                    console.log('ğŸ” [DEBUG] Request payload:', requestData);
                }

                const response = await fetch('/api/process', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Debug-Mode': PROCESSING_CONFIG.debugMode ? 'true' : 'false'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    console.error('Batch API error:', await response.text());
                    throw new Error(`Batch processing failed: ${response.status}`);
                }

                const rawData = await response.json();
                
                if (PROCESSING_CONFIG.debugMode) {
                    console.log('ğŸ” [DEBUG] Raw response:', rawData);
                }
                
                // ğŸ”“ ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®å¾©å·åŒ–
                const data = PROCESSING_CONFIG.debugMode 
                    ? rawData 
                    : CryptoUtils.deobfuscateResponse(rawData);
                
                if (PROCESSING_CONFIG.debugMode) {
                    console.log('ğŸ” [DEBUG] Decoded response:', data);
                }
                
                return data.results || [];
            } catch (error) {
                console.error('Batch processing error:', error);
                throw error;
            }
        }
        
        // ğŸ”„ é€²æ—UIæ›´æ–°é–¢æ•°
        function updateProgress(completed, total, currentReview, startTime) {
            const progressSection = document.getElementById('progressSection');
            const progressCount = document.getElementById('progressCount');
            const progressFill = document.getElementById('progressFill');
            const elapsedTime = document.getElementById('elapsedTime');
            const currentStatus = document.getElementById('currentStatus');
            const currentReviewSpan = document.getElementById('currentReview');
            const estimatedTime = document.getElementById('estimatedTime');
            
            progressSection.style.display = 'block';
            
            // é€²æ—æ›´æ–°
            const percentage = Math.round((completed / total) * 100);
            progressCount.textContent = `${completed}/${total} (${percentage}%)`;
            progressFill.style.width = `${percentage}%`;
            
            // çµŒéæ™‚é–“
            const elapsed = Date.now() - startTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            elapsedTime.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // ç¾åœ¨ã®çŠ¶æ³
            if (completed === total) {
                currentStatus.textContent = 'å®Œäº†ï¼';
                currentReviewSpan.textContent = 'å…¨ã¦å‡¦ç†å®Œäº†';
                estimatedTime.textContent = '00:00';
            } else {
                currentStatus.textContent = 'åˆ†æä¸­...';
                currentReviewSpan.textContent = currentReview ? currentReview.substring(0, PROCESSING_CONFIG.maxPreviewLength) + '...' : 'å‡¦ç†ä¸­...';
                
                // æ¨å®šæ®‹ã‚Šæ™‚é–“
                if (completed > 0) {
                    const avgTimePerItem = elapsed / completed;
                    const remainingTime = (total - completed) * avgTimePerItem;
                    const remMin = Math.floor(remainingTime / 60000);
                    const remSec = Math.floor((remainingTime % 60000) / 1000);
                    estimatedTime.textContent = `${remMin.toString().padStart(2, '0')}:${remSec.toString().padStart(2, '0')}`;
                }
            }
        }

        // ğŸ¤– è‡ªå‹•åˆ†æ: æ–°ã—ã„ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆåˆ†æé–¢æ•°
        async function analyzeSentimentAuto(reviewText) {
            if (!reviewText) return { label: 'Neutral', score: 0, reason: 'ç©ºã®ãƒ†ã‚­ã‚¹ãƒˆ' };
            
            try {
                const response = await fetch('/api/classify', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        review: reviewText,
                        type: 'sentiment'
                    })
                });

                if (!response.ok) {
                    console.error('Sentiment API error:', await response.text());
                    return { label: 'Neutral', score: 0, reason: 'API ã‚¨ãƒ©ãƒ¼' };
                }

                const data = await response.json();
                return {
                    label: data.sentiment || 'Neutral',
                    score: data.score || 0,
                    reason: data.reason || 'åˆ†æå®Œäº†'
                };
            } catch (error) {
                console.error('Sentiment analysis error:', error);
                return { label: 'Neutral', score: 0, reason: 'ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ' };
            }
        }

        function analyzeSentiment(reviewText) {
            if (!reviewText) {
                return {
                    label: 'ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«',
                    score: 50,
                    reason: 'ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ†ã‚­ã‚¹ãƒˆãŒç©ºã®ãŸã‚åˆ¤å®šä¸å¯'
                };
            }
            
            const text = String(reviewText);
            let score = 50;
            const reasons = [];
            
            if (text.match(/é£Ÿã¹[ã‚‹ã¦ãŸã‚Š](?!ãª)|ç¾å‘³[ã—ã]|ãŠã„ã—|å–œã‚“ã§|ãƒã‚¯ãƒã‚¯|å®Œé£Ÿ|ã‚ˆãé£Ÿã¹|å¤§å¥½ã/)) {
                score += 15;
                reasons.push('é£Ÿã„ã¤ããŒè‰¯ã„');
            }
            if (text.match(/æº€è¶³|è‰¯[ã„ãã‹ã‘](?!ãª)|æ°—ã«å…¥|ãŠæ°—ã«å…¥ã‚Š|ãƒªãƒ”ãƒ¼ãƒˆ|ã¾ãŸè²·|å®šç•ª|ãšã£ã¨/)) {
                score += 10;
                reasons.push('æº€è¶³åº¦ãŒé«˜ã„');
            }
            if (text.match(/(å|å˜”å).{0,20}(æ¸›|ãªããªã£ãŸ|æ”¹å–„)|ä¾¿.{0,20}è‰¯|å¥åº·|å…ƒæ°—|èª¿å­.{0,5}è‰¯/)) {
                score += 15;
                reasons.push('å¥åº·é¢ã§ã®æ”¹å–„');
            }
            if (text.match(/å®‰[ã„ãã‚]|ã‚„ã™[ã„ãã‚]|ãŠå¾—|ã‚³ã‚¹ãƒ‘|æ‰‹é ƒ/)) {
                score += 10;
                reasons.push('ä¾¡æ ¼æº€è¶³åº¦ãŒé«˜ã„');
            }
            if (text.match(/æ¯›ä¸¦ã¿.{0,10}(è‰¯|ç¶ºéº—|ãƒ„ãƒ¤|ã‚µãƒ©ã‚µãƒ©)|æ¯›è‰¶|æ¯›.{0,5}ãƒ„ãƒ¤ãƒ„ãƒ¤/)) {
                score += 10;
                reasons.push('æ¯›ä¸¦ã¿ã®æ”¹å–„');
            }
            
            if (text.match(/é£Ÿã¹(ã¦ãã‚Œ)?ãª[ã„ã‹ãã‘]|æ‹’å¦|æ®‹[ã™ã—]/)) {
                score -= 20;
                reasons.push('é£Ÿã„ã¤ããŒæ‚ªã„');
            }
            if (text.match(/å[ãã„ãŸã‘]|å˜”å|ä¸‹ç—¢|è»Ÿä¾¿|ä¾¿.{0,5}æ‚ª/) && !text.match(/(æ¸›|ãªããªã£ãŸ|æ”¹å–„)/)) {
                score -= 15;
                reasons.push('ä½“èª¿ä¸è‰¯ã®ç™ºç”Ÿ');
            }
            if (text.match(/é«˜[ã„ãã‚]|ãŸã‹[ã„ãã‚]|å€¤ä¸Š[ã’ãŒã‚Š]/)) {
                score -= 10;
                reasons.push('ä¾¡æ ¼ã¸ã®ä¸æº€');
            }
            if (text.match(/æ®‹å¿µ|ãŒã£ã‹ã‚Š|æœŸå¾…ã¯ãšã‚Œ|ãƒ€ãƒ¡|æœ€æ‚ª|äºŒåº¦ã¨|ã‚‚ã†è²·ã‚ãªã„/)) {
                score -= 15;
                reasons.push('æœŸå¾…ã¨ã®ä¹–é›¢');
            }
            
            score = Math.max(0, Math.min(100, score));
            
            let label = 'ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«';
            if (score >= 70) label = 'ãƒã‚¸ãƒ†ã‚£ãƒ–';
            else if (score <= 30) label = 'ãƒã‚¬ãƒ†ã‚£ãƒ–';
            
            let reason = '';
            if (reasons.length > 0) {
                reason = reasons.join('ã€') + 'ãŸã‚ã€‚';
            } else {
                reason = 'ç‰¹å®šã®è©•ä¾¡è¦ç´ ãŒè¦‹å½“ãŸã‚‰ãªã„ãŸã‚ä¸­ç«‹çš„ã¨åˆ¤å®šã€‚';
            }
            
            return {
                label: label,
                score: score,
                reason: reason
            };
        }

        function generateAndShowSentimentSummary() {
            const positive = sentimentDataList.filter(s => s.label === 'ãƒã‚¸ãƒ†ã‚£ãƒ–').length;
            const negative = sentimentDataList.filter(s => s.label === 'ãƒã‚¬ãƒ†ã‚£ãƒ–').length;
            const neutral = sentimentDataList.filter(s => s.label === 'ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«').length;
            const total = sentimentDataList.length;
            
            let summaryHTML = `
                <p><strong>ç·ãƒ¬ãƒ“ãƒ¥ãƒ¼æ•°:</strong> ${total}ä»¶</p>
                <p><strong>ãƒã‚¸ãƒ†ã‚£ãƒ–:</strong> ${positive}ä»¶ (${(positive/total*100).toFixed(1)}%)</p>
                <p><strong>ãƒã‚¬ãƒ†ã‚£ãƒ–:</strong> ${negative}ä»¶ (${(negative/total*100).toFixed(1)}%)</p>
                <p><strong>ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«:</strong> ${neutral}ä»¶ (${(neutral/total*100).toFixed(1)}%)</p>
                <h4>ä¸»ãªå‚¾å‘:</h4>
                <ul>
            `;
            
            if (positive > negative * 2) {
                summaryHTML += '<li>å…¨ä½“çš„ã«å¥½è©•ä¾¡ãŒå¤šãã€è£½å“ã«å¯¾ã™ã‚‹æº€è¶³åº¦ãŒé«˜ã„å‚¾å‘ã«ã‚ã‚Šã¾ã™ã€‚</li>';
            }
            if (negative > positive * 2) {
                summaryHTML += '<li>æ”¹å–„ãŒå¿…è¦ãªç‚¹ãŒå¤šãè¦‹å—ã‘ã‚‰ã‚Œã¾ã™ã€‚</li>';
            }
            if (Math.abs(positive - negative) < total * 0.1) {
                summaryHTML += '<li>è©•ä¾¡ãŒåˆ†ã‹ã‚Œã¦ãŠã‚Šã€å€‹ä½“å·®ã‚„å¥½ã¿ã®é•ã„ãŒå¤§ãã„ã‚ˆã†ã§ã™ã€‚</li>';
            }
            
            const positiveReasons = {};
            sentimentDataList.filter(s => s.label === 'ãƒã‚¸ãƒ†ã‚£ãƒ–').forEach(s => {
                if (s.reason.includes('é£Ÿã„ã¤ããŒè‰¯ã„')) positiveReasons['é£Ÿã„ã¤ã'] = (positiveReasons['é£Ÿã„ã¤ã'] || 0) + 1;
                if (s.reason.includes('å¥åº·é¢ã§ã®æ”¹å–„')) positiveReasons['å¥åº·æ”¹å–„'] = (positiveReasons['å¥åº·æ”¹å–„'] || 0) + 1;
                if (s.reason.includes('ä¾¡æ ¼æº€è¶³åº¦')) positiveReasons['ä¾¡æ ¼'] = (positiveReasons['ä¾¡æ ¼'] || 0) + 1;
            });
            
            if (Object.keys(positiveReasons).length > 0) {
                summaryHTML += '<li>ãƒã‚¸ãƒ†ã‚£ãƒ–è©•ä¾¡ã®ä¸»ãªè¦å› ï¼š';
                const topReasons = Object.entries(positiveReasons).sort((a, b) => b[1] - a[1]).slice(0, 3);
                summaryHTML += topReasons.map(([reason, count]) => `${reason}(${count}ä»¶)`).join('ã€');
                summaryHTML += '</li>';
            }
            
            summaryHTML += '</ul>';
            
            document.getElementById('sentimentContent').innerHTML = summaryHTML;
            document.getElementById('sentimentSummary').style.display = 'block';
        }

        // A/Bãƒ†ã‚¹ãƒˆæ©Ÿèƒ½ã¯å‰Šé™¤æ¸ˆã¿
        
        // ğŸ›ï¸ å‡¦ç†è¨­å®šï¼ˆæŸ”è»Ÿã«å¤‰æ›´å¯èƒ½ï¼‰
        const PROCESSING_CONFIG = {
            batchSize: 10,              // ãƒãƒƒãƒã‚µã‚¤ã‚ºï¼ˆ10ä»¶ãšã¤ï¼‰
            reviewTextColumn: 10,       // ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ†ã‚­ã‚¹ãƒˆåˆ—ï¼ˆKåˆ—=10ã€0ãƒ™ãƒ¼ã‚¹ï¼‰
            batchDelay: 100,            // ãƒãƒƒãƒé–“å¾…æ©Ÿæ™‚é–“(ms)
            retryCount: 3,              // ãƒªãƒˆãƒ©ã‚¤å›æ•°
            timeout: 30000,             // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚é–“(ms)
            maxPreviewLength: 50,       // é€²æ—è¡¨ç¤ºç”¨ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ–‡å­—æ•°
            debugMode: false            // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ï¼ˆé–‹ç™ºæ™‚ã®ã¿trueï¼‰
        };
        
        // ğŸ” é€šä¿¡éš è”½ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
        const CryptoUtils = {
            // Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶æ¨™æº–ï¼‰
            encode: (data) => {
                try {
                    return btoa(unescape(encodeURIComponent(JSON.stringify(data))));
                } catch (error) {
                    console.error('Encoding error:', error);
                    return null;
                }
            },
            
            // Base64ãƒ‡ã‚³ãƒ¼ãƒ‰
            decode: (encodedData) => {
                try {
                    return JSON.parse(decodeURIComponent(escape(atob(encodedData))));
                } catch (error) {
                    console.error('Decoding error:', error);
                    return null;
                }
            },
            
            // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åå½è£…
            obfuscateRequest: (data) => {
                return {
                    p: CryptoUtils.encode(data.batchReviews),    // payload
                    c: CryptoUtils.encode(data.categories),      // categories
                    t: data.type,                                // type (ãã®ã¾ã¾)
                    id: data.batchId,                           // id
                    ts: Date.now(),                             // timestamp
                    v: "1.0"                                    // version
                };
            },
            
            // ãƒ¬ã‚¹ãƒãƒ³ã‚¹å¾©å·åŒ–
            deobfuscateResponse: (obfuscatedData) => {
                if (obfuscatedData.d) {
                    // æš—å·åŒ–ã•ã‚ŒãŸãƒ¬ã‚¹ãƒãƒ³ã‚¹
                    return {
                        results: CryptoUtils.decode(obfuscatedData.d)
                    };
                } else {
                    // å¹³æ–‡ãƒ¬ã‚¹ãƒãƒ³ã‚¹ï¼ˆã‚¨ãƒ©ãƒ¼æ™‚ãªã©ï¼‰
                    return obfuscatedData;
                }
            }
        };
        
        // ğŸš€ é–‹ç™ºè€…ãƒ„ãƒ¼ãƒ«ç”¨ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰å¼·åˆ¶æœ‰åŠ¹åŒ–ã‚³ãƒãƒ³ãƒ‰
        window.enableDebugMode = function() {
            PROCESSING_CONFIG.debugMode = true;
            console.log('ğŸ”¥ ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ãŒå¼·åˆ¶çš„ã«æœ‰åŠ¹ã«ãªã‚Šã¾ã—ãŸ');
            console.log('æ¬¡å›ã®å‡¦ç†ã‹ã‚‰ãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆé€šä¿¡ã«ãªã‚Šã¾ã™');
            return 'Debug mode enabled';
        };
        
        // ãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ¡ã‚¤ãƒ³é–¢æ•° - ãƒãƒƒãƒå‡¦ç† + é€²æ—UIå¯¾å¿œ
        async function processData() {
            const statusDiv = document.getElementById('status');
            const processBtn = document.getElementById('processBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            const visualizeBtn = document.getElementById('visualizeBtn');
            const abTestEnabled = false; // A/Bãƒ†ã‚¹ãƒˆæ©Ÿèƒ½ã¯å‰Šé™¤æ¸ˆã¿
            
            try {
                processBtn.disabled = true;
                statusDiv.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...';
                
                const rawReviewFile = Object.values(uploadedFiles).find(file => 
                    file.name.toLowerCase().includes('raw_review') || file.name.toLowerCase().includes('review')
                );
                
                if (!rawReviewFile) {
                    throw new Error('ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                }
                
                const rawWorkbook = XLSX.read(rawReviewFile.data);
                const rawSheet = rawWorkbook.Sheets[rawWorkbook.SheetNames[0]];
                rawData = XLSX.utils.sheet_to_json(rawSheet, { header: 1 });
                
                statusDiv.textContent = `ãƒ‡ãƒ¼ã‚¿ã‚’å‡¦ç†ä¸­... (ç·è¡Œæ•°: ${rawData.length - 1})`;
                
                console.log('ãƒ˜ãƒƒãƒ€ãƒ¼:', rawData[0]);
                console.log('1è¡Œç›®ãƒ‡ãƒ¼ã‚¿:', rawData[1]);
                console.log('2è¡Œç›®ãƒ‡ãƒ¼ã‚¿:', rawData[2]);
                
                let headers = [...rawData[0], 'ãƒ©ãƒ™ãƒ«', 'å¹´', 'æœˆ', 'å¹´æœˆ', 'ã‚¯ã‚©ãƒ¼ã‚¿ãƒ¼', 'ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆï¼ˆãƒ©ãƒ™ãƒ«ï¼‰', 'ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆï¼ˆã‚¹ã‚³ã‚¢ï¼‰', 'ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆï¼ˆç†ç”±ï¼‰'];
                processedData = [headers];
                
                sentimentDataList = [];
                
                // ğŸ¯ ãƒãƒƒãƒå‡¦ç†æº–å‚™
                const totalRows = rawData.length - 1;
                const categoryInput = document.getElementById('categoryInput');
                const customCategories = categoryInput.value.trim().split('\n').filter(cat => cat.trim());
                
                console.log(`ãƒãƒƒãƒã‚µã‚¤ã‚º: ${PROCESSING_CONFIG.batchSize}, ç·è¡Œæ•°: ${totalRows}`);
                
                // ğŸš€ ãƒãƒƒãƒå‡¦ç†é–‹å§‹
                const startTime = Date.now();
                const failedItems = [];
                let processedCount = 0;
                
                updateProgress(0, totalRows, null, startTime);
                
                for (let i = 1; i < rawData.length; i += PROCESSING_CONFIG.batchSize) {
                    const batchEnd = Math.min(i + PROCESSING_CONFIG.batchSize, rawData.length);
                    const currentBatch = [];
                    
                    // ãƒãƒƒãƒãƒ‡ãƒ¼ã‚¿æº–å‚™
                    for (let j = i; j < batchEnd; j++) {
                        const row = rawData[j];
                        if (!row || row.length === 0) continue;
                        
                        const reviewText = String(row[PROCESSING_CONFIG.reviewTextColumn] || '').trim();
                        const reviewDate = String(row[1] || '').trim();
                        
                        if (!reviewText) {
                            console.warn(`è¡Œ ${j}: ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ†ã‚­ã‚¹ãƒˆãŒç©ºã§ã™`);
                            continue;
                        }
                        
                        currentBatch.push({
                            id: j,
                            text: reviewText,
                            originalRow: row,
                            date: reviewDate
                        });
                    }
                    
                    if (currentBatch.length === 0) continue;
                    
                    // ç¾åœ¨å‡¦ç†ä¸­ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’è¡¨ç¤ºç”¨ã«å–å¾—
                    const currentReviewText = currentBatch[0]?.text || '';
                    updateProgress(processedCount, totalRows, currentReviewText, startTime);
                    
                    // ğŸ¤– ãƒãƒƒãƒå‡¦ç†å®Ÿè¡Œï¼ˆåˆ†é¡ã¨ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆåˆ†æã‚’åˆ¥ã€…ã«ï¼‰
                    let batchResults = [];
                    let retryCount = 0;
                    
                    while (retryCount <= PROCESSING_CONFIG.retryCount) {
                        try {
                            console.log(`ğŸ”„ ãƒãƒƒãƒ ${Math.floor((i-1)/PROCESSING_CONFIG.batchSize) + 1} å‡¦ç†ä¸­... (${currentBatch.length}ä»¶)`);
                            
                            // åˆ†é¡å‡¦ç†
                            const classificationBatch = currentBatch.map(item => ({id: item.id, text: item.text}));
                            const classificationResults = await processBatch(classificationBatch, customCategories, `batch-${i}-classification`);
                            
                            // ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆåˆ†æå‡¦ç†
                            const sentimentBatch = currentBatch.map(item => ({id: item.id, text: item.text}));
                            const sentimentResults = await processBatch(sentimentBatch, [], `batch-${i}-sentiment`);
                            
                            // çµæœã‚’ãƒãƒ¼ã‚¸
                            batchResults = currentBatch.map(item => {
                                const classResult = classificationResults.find(r => r.id === item.id);
                                const sentResult = sentimentResults.find(r => r.id === item.id);
                                
                                return {
                                    id: item.id,
                                    originalRow: item.originalRow,
                                    date: item.date,
                                    classification: classResult?.category || 'ãã®ä»–',
                                    sentiment: {
                                        label: sentResult?.sentiment || 'ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«',
                                        score: sentResult?.score || 0,
                                        reason: sentResult?.reason || 'å‡¦ç†ã‚¨ãƒ©ãƒ¼'
                                    }
                                };
                            });
                            
                            break; // æˆåŠŸã—ãŸã‚‰ãƒªãƒˆãƒ©ã‚¤ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
                            
                        } catch (error) {
                            retryCount++;
                            console.error(`âŒ ãƒãƒƒãƒå‡¦ç†ã‚¨ãƒ©ãƒ¼ (è©¦è¡Œ ${retryCount}):`, error);
                            
                            if (retryCount > PROCESSING_CONFIG.retryCount) {
                                // ğŸ”„ æœ€çµ‚ãƒªãƒˆãƒ©ã‚¤: ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ã§å†è©¦è¡Œ
                                if (!PROCESSING_CONFIG.debugMode) {
                                    console.log('ğŸ”„ Final retry with debug mode enabled...');
                                    const originalDebugMode = PROCESSING_CONFIG.debugMode;
                                    PROCESSING_CONFIG.debugMode = true;
                                    
                                    try {
                                        // åˆ†é¡å‡¦ç†
                                        const classificationBatch = currentBatch.map(item => ({id: item.id, text: item.text}));
                                        const classificationResults = await processBatch(classificationBatch, customCategories, `batch-${i}-classification`);
                                        
                                        // ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆåˆ†æå‡¦ç†
                                        const sentimentBatch = currentBatch.map(item => ({id: item.id, text: item.text}));
                                        const sentimentResults = await processBatch(sentimentBatch, [], `batch-${i}-sentiment`);
                                        
                                        // çµæœã‚’ãƒãƒ¼ã‚¸
                                        batchResults = currentBatch.map(item => {
                                            const classResult = classificationResults.find(r => r.id === item.id);
                                            const sentResult = sentimentResults.find(r => r.id === item.id);
                                            
                                            return {
                                                id: item.id,
                                                originalRow: item.originalRow,
                                                date: item.date,
                                                classification: classResult?.category || 'ãã®ä»–',
                                                sentiment: {
                                                    label: sentResult?.sentiment || 'ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«',
                                                    score: sentResult?.score || 0,
                                                    reason: sentResult?.reason || 'å¾©æ—§å‡¦ç†'
                                                }
                                            };
                                        });
                                        
                                        console.log('âœ… Debug mode retry succeeded');
                                        PROCESSING_CONFIG.debugMode = originalDebugMode;
                                        break;
                                        
                                    } catch (debugError) {
                                        console.error('âŒ Debug mode retry also failed:', debugError);
                                        PROCESSING_CONFIG.debugMode = originalDebugMode;
                                    }
                                }
                                
                                // å®Œå…¨ã«ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ã‚¨ãƒ©ãƒ¼ãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦å‡¦ç†
                                batchResults = currentBatch.map(item => ({
                                    id: item.id,
                                    originalRow: item.originalRow,
                                    date: item.date,
                                    classification: 'ã‚¨ãƒ©ãƒ¼',
                                    sentiment: { label: 'ã‚¨ãƒ©ãƒ¼', score: 0, reason: 'APIå‡¦ç†å¤±æ•—' }
                                }));
                                failedItems.push(...currentBatch.map(item => item.id));
                            } else {
                                await new Promise(resolve => setTimeout(resolve, 1000 * retryCount)); // æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•
                            }
                        }
                    }
                    
                    // çµæœã‚’processedDataã«è¿½åŠ 
                    for (const result of batchResults) {
                        const dateInfo = parseDate(result.date);
                        const newRow = [
                            ...result.originalRow,
                            result.classification,
                            dateInfo.year,
                            dateInfo.month,
                            dateInfo.yearMonth,
                            dateInfo.quarter,
                            result.sentiment.label,
                            result.sentiment.score,
                            result.sentiment.reason
                        ];
                        
                        processedData.push(newRow);
                        sentimentDataList.push(result.sentiment);
                    }
                    
                    processedCount += currentBatch.length;
                    updateProgress(processedCount, totalRows, currentReviewText, startTime);
                    
                    // ãƒãƒƒãƒé–“ã®å¾…æ©Ÿ
                    if (PROCESSING_CONFIG.batchDelay > 0) {
                        await new Promise(resolve => setTimeout(resolve, PROCESSING_CONFIG.batchDelay));
                    }
                }
                
                // æœ€çµ‚é€²æ—æ›´æ–°
                updateProgress(totalRows, totalRows, null, startTime);
                
                // ã‚¨ãƒ©ãƒ¼ã‚µãƒãƒªãƒ¼è¡¨ç¤º
                if (failedItems.length > 0) {
                    console.warn(`âš ï¸ å‡¦ç†å¤±æ•—: ${failedItems.length}ä»¶`, failedItems);
                }
                
                let statusMessage = `å‡¦ç†å®Œäº†ï¼é«˜ç²¾åº¦åˆ†é¡ã‚·ã‚¹ãƒ†ãƒ `;
                statusDiv.innerHTML = `<span class="success">${statusMessage}</span>`;
                
                downloadBtn.disabled = false;
                visualizeBtn.disabled = false;
                
                // åˆ†æãƒ‡ãƒ¼ã‚¿ã®æº–å‚™
                prepareAnalysisData();
                
                showStatistics();
                generateAndShowSentimentSummary();
                showSampleResults();
                
                // A/Bãƒ†ã‚¹ãƒˆæ©Ÿèƒ½ã¯å‰Šé™¤æ¸ˆã¿
                
            } catch (error) {
                statusDiv.innerHTML = `<span class="error">ã‚¨ãƒ©ãƒ¼: ${error.message}</span>`;
                processBtn.disabled = false;
            }
        }
        
        // A/Bãƒ†ã‚¹ãƒˆæ©Ÿèƒ½ã¯å‰Šé™¤æ¸ˆã¿

        // æ–°æ©Ÿèƒ½: åˆ†æãƒ‡ãƒ¼ã‚¿ã®æº–å‚™
        function prepareAnalysisData() {
            analysisData = {
                monthlyData: {},
                labelData: {},
                sentimentData: {},
                quarterlyData: {},
                heatmapData: {}
            };

            const allLabels = new Set();
            const allMonths = new Set();

            for (let i = 1; i < processedData.length; i++) {
                const row = processedData[i];
                const yearMonth = row[14]; // Oåˆ—
                const label = row[11]; // Låˆ—
                const quarter = row[16]; // Qåˆ—
                const sentimentText = row[15]; // Påˆ—

                if (yearMonth && label) {
                    allMonths.add(yearMonth);
                    allLabels.add(label);

                    // æœˆåˆ¥ãƒ‡ãƒ¼ã‚¿
                    if (!analysisData.monthlyData[yearMonth]) {
                        analysisData.monthlyData[yearMonth] = {};
                    }
                    if (!analysisData.monthlyData[yearMonth][label]) {
                        analysisData.monthlyData[yearMonth][label] = 0;
                    }
                    analysisData.monthlyData[yearMonth][label]++;

                    // ãƒ©ãƒ™ãƒ«åˆè¨ˆ
                    if (!analysisData.labelData[label]) {
                        analysisData.labelData[label] = 0;
                    }
                    analysisData.labelData[label]++;

                    // ã‚¯ã‚©ãƒ¼ã‚¿ãƒ¼åˆ¥
                    if (quarter) {
                        if (!analysisData.quarterlyData[quarter]) {
                            analysisData.quarterlyData[quarter] = {};
                        }
                        if (!analysisData.quarterlyData[quarter][label]) {
                            analysisData.quarterlyData[quarter][label] = 0;
                        }
                        analysisData.quarterlyData[quarter][label]++;
                    }

                    // ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆæŠ½å‡º
                    const sentimentMatch = sentimentText.match(/ãƒ©ãƒ™ãƒ«: (\w+)/);
                    if (sentimentMatch) {
                        const sentiment = sentimentMatch[1];
                        if (!analysisData.sentimentData[sentiment]) {
                            analysisData.sentimentData[sentiment] = 0;
                        }
                        analysisData.sentimentData[sentiment]++;

                        // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿
                        const key = `${label}_${sentiment}`;
                        if (!analysisData.heatmapData[key]) {
                            analysisData.heatmapData[key] = 0;
                        }
                        analysisData.heatmapData[key]++;
                    }
                }
            }

            // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é¸æŠè‚¢ã®æ›´æ–°
            updateFilterOptions();
        }

        // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é¸æŠè‚¢ã®æ›´æ–°
        function updateFilterOptions() {
            const labelFilter = document.getElementById('labelFilter');
            labelFilter.innerHTML = '<option value="all">å…¨ãƒ©ãƒ™ãƒ«</option>';
            
            Object.keys(analysisData.labelData).forEach(label => {
                const option = document.createElement('option');
                option.value = label;
                option.textContent = label;
                labelFilter.appendChild(option);
            });
        }

        // æ–°æ©Ÿèƒ½: å¯è¦–åŒ–è¡¨ç¤ºã®åˆ‡ã‚Šæ›¿ãˆ
        function toggleVisualization() {
            const dashboard = document.getElementById('dashboardSection');
            dashboardVisible = !dashboardVisible;
            
            if (dashboardVisible) {
                dashboard.style.display = 'block';
                document.getElementById('visualizeBtn').textContent = 'ğŸ“Š å¯è¦–åŒ–éè¡¨ç¤º';
                initializeCharts();
                updateKPIs();
            } else {
                dashboard.style.display = 'none';
                document.getElementById('visualizeBtn').textContent = 'ğŸ“Š å¯è¦–åŒ–è¡¨ç¤º';
                destroyAllCharts();
            }
        }

        // ãƒãƒ£ãƒ¼ãƒˆã®åˆæœŸåŒ–
        function initializeCharts() {
            setTimeout(() => {
                createMonthlyTrendChart();
                createLabelDistributionChart();
                createSentimentChart();
                createQuarterlyChart();
                createHeatmapTable();
            }, 100);
        }

        // ã™ã¹ã¦ã®ãƒãƒ£ãƒ¼ãƒˆã‚’å‰Šé™¤
        function destroyAllCharts() {
            Object.values(charts).forEach(chart => {
                if (chart && typeof chart.destroy === 'function') {
                    chart.destroy();
                }
            });
            charts = {};
        }

        // KPIæ›´æ–°
        function updateKPIs() {
            const total = processedData.length - 1;
            const positive = sentimentDataList.filter(s => s.label === 'ãƒã‚¸ãƒ†ã‚£ãƒ–').length;
            const positiveRate = ((positive / total) * 100).toFixed(1);
            
            const labelCounts = Object.entries(analysisData.labelData).sort((a, b) => b[1] - a[1]);
            const topLabel = labelCounts[0] ? labelCounts[0][0] : '-';
            const topLabelCount = labelCounts[0] ? labelCounts[0][1] : 0;
            
            const avgScore = (sentimentDataList.reduce((sum, s) => sum + s.score, 0) / sentimentDataList.length).toFixed(1);

            document.getElementById('totalReviews').textContent = total;
            document.getElementById('positiveRate').textContent = positiveRate + '%';
            document.getElementById('topLabel').textContent = topLabel;
            document.getElementById('avgScore').textContent = avgScore;

            // ãƒˆãƒ¬ãƒ³ãƒ‰è¡¨ç¤ºï¼ˆç°¡å˜ãªå®Ÿè£…ï¼‰
            document.getElementById('reviewsTrend').textContent = `${total}ä»¶`;
            document.getElementById('reviewsTrend').className = 'trend-indicator trend-stable';
            
            document.getElementById('positiveTrend').textContent = `${positive}ä»¶`;
            document.getElementById('positiveTrend').className = `trend-indicator ${positiveRate > 60 ? 'trend-up' : positiveRate < 40 ? 'trend-down' : 'trend-stable'}`;
            
            document.getElementById('topLabelCount').textContent = `${topLabelCount}ä»¶`;
            document.getElementById('topLabelCount').className = 'trend-indicator trend-stable';
            
            document.getElementById('scoreTrend').textContent = `å…¨ä½“å¹³å‡`;
            document.getElementById('scoreTrend').className = `trend-indicator ${avgScore > 60 ? 'trend-up' : avgScore < 40 ? 'trend-down' : 'trend-stable'}`;
        }

        // æœˆåˆ¥æ¨ç§»ãƒãƒ£ãƒ¼ãƒˆ
        function createMonthlyTrendChart() {
            const ctx = document.getElementById('monthlyTrendChart').getContext('2d');
            
            const months = Object.keys(analysisData.monthlyData).sort();
            const datasets = [];
            
            // ä¸Šä½5ãƒ©ãƒ™ãƒ«ã®ã¿è¡¨ç¤º
            const topLabels = Object.entries(analysisData.labelData)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([label]) => label);
            
            const colors = [
                '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF'
            ];
            
            topLabels.forEach((label, index) => {
                const data = months.map(month => analysisData.monthlyData[month][label] || 0);
                datasets.push({
                    label: label,
                    data: data,
                    borderColor: colors[index],
                    backgroundColor: colors[index] + '20',
                    fill: document.getElementById('chartType').value === 'area'
                });
            });

            if (charts.monthlyTrend) {
                charts.monthlyTrend.destroy();
            }

            charts.monthlyTrend = new Chart(ctx, {
                type: document.getElementById('chartType').value === 'bar' ? 'bar' : 'line',
                data: {
                    labels: months,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // ãƒ©ãƒ™ãƒ«åˆ†å¸ƒãƒãƒ£ãƒ¼ãƒˆ
        function createLabelDistributionChart() {
            const ctx = document.getElementById('labelDistributionChart').getContext('2d');
            
            const labels = Object.keys(analysisData.labelData);
            const data = Object.values(analysisData.labelData);
            
            if (charts.labelDistribution) {
                charts.labelDistribution.destroy();
            }

            charts.labelDistribution = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: [
                            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
                            '#FF9F40', '#C9CBCF', '#4BC0C0', '#FF6384', '#36A2EB'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                        }
                    }
                }
            });
        }

        // ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆãƒãƒ£ãƒ¼ãƒˆ
        function createSentimentChart() {
            const ctx = document.getElementById('sentimentChart').getContext('2d');
            
            if (charts.sentiment) {
                charts.sentiment.destroy();
            }

            charts.sentiment = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: Object.keys(analysisData.sentimentData),
                    datasets: [{
                        data: Object.values(analysisData.sentimentData),
                        backgroundColor: ['#4CAF50', '#F44336', '#FF9800']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                        }
                    }
                }
            });
        }

        // ã‚¯ã‚©ãƒ¼ã‚¿ãƒ¼åˆ¥ãƒãƒ£ãƒ¼ãƒˆ
        function createQuarterlyChart() {
            const ctx = document.getElementById('quarterlyChart').getContext('2d');
            
            const quarters = Object.keys(analysisData.quarterlyData).sort();
            const datasets = [];
            
            const topLabels = Object.entries(analysisData.labelData)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([label]) => label);
            
            const colors = [
                '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF'
            ];
            
            topLabels.forEach((label, index) => {
                const data = quarters.map(quarter => analysisData.quarterlyData[quarter][label] || 0);
                datasets.push({
                    label: label,
                    data: data,
                    backgroundColor: colors[index]
                });
            });

            if (charts.quarterly) {
                charts.quarterly.destroy();
            }

            charts.quarterly = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: quarters,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                        },
                        y: {
                            stacked: true,
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ãƒ†ãƒ¼ãƒ–ãƒ«
        function createHeatmapTable() {
            const container = document.getElementById('heatmapTable');
            const labels = Object.keys(analysisData.labelData);
            const sentiments = ['ãƒã‚¸ãƒ†ã‚£ãƒ–', 'ãƒã‚¬ãƒ†ã‚£ãƒ–', 'ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«'];
            
            let html = '<tr><th>ãƒ©ãƒ™ãƒ«</th>';
            sentiments.forEach(sentiment => {
                html += `<th>${sentiment}</th>`;
            });
            html += '</tr>';
            
            labels.forEach(label => {
                html += `<tr><td style="font-weight: bold; padding: 8px; border: 1px solid #ddd;">${label}</td>`;
                sentiments.forEach(sentiment => {
                    const key = `${label}_${sentiment}`;
                    const count = analysisData.heatmapData[key] || 0;
                    const total = analysisData.labelData[label] || 1;
                    const percentage = ((count / total) * 100).toFixed(1);
                    
                    let bgColor = '#f5f5f5';
                    if (sentiment === 'ãƒã‚¸ãƒ†ã‚£ãƒ–' && percentage > 50) bgColor = '#c8e6c9';
                    else if (sentiment === 'ãƒã‚¬ãƒ†ã‚£ãƒ–' && percentage > 30) bgColor = '#ffcdd2';
                    else if (sentiment === 'ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«' && percentage > 40) bgColor = '#e1f5fe';
                    
                    html += `<td style="padding: 8px; border: 1px solid #ddd; background-color: ${bgColor}; text-align: center;">
                        ${count}<br><small>${percentage}%</small>
                    </td>`;
                });
                html += '</tr>';
            });
            
            container.innerHTML = html;
        }

        // ãƒãƒ£ãƒ¼ãƒˆæ›´æ–°
        function updateCharts() {
            if (dashboardVisible) {
                destroyAllCharts();
                initializeCharts();
            }
        }

        function showStatistics() {
            const statsDiv = document.getElementById('stats');
            const statsContent = document.getElementById('statsContent');
            
            const yearMonthStats = {};
            const labelStats = {};
            
            for (let i = 1; i < processedData.length; i++) {
                const yearMonth = processedData[i][14];
                const labels = processedData[i][11];
                
                if (yearMonth) {
                    yearMonthStats[yearMonth] = (yearMonthStats[yearMonth] || 0) + 1;
                }
                
                if (labels) {
                    labelStats[labels] = (labelStats[labels] || 0) + 1;
                }
            }
            
            let html = '<p><strong>ç·ãƒ¬ãƒ“ãƒ¥ãƒ¼æ•°:</strong> ' + (processedData.length - 1) + '</p>';
            html += '<p><strong>æœŸé–“:</strong> ' + Object.keys(yearMonthStats).sort()[0] + ' ï½ ' + 
                    Object.keys(yearMonthStats).sort().slice(-1)[0] + '</p>';
            
            if (labelConfig.length > 0) {
                html += `<p><strong>ãƒ©ãƒ™ãƒ«è¨­å®š:</strong> ã‚«ã‚¹ã‚¿ãƒ è¨­å®šï¼ˆ${labelConfig.length}ä»¶ï¼‰</p>`;
            } else {
                html += '<p><strong>ãƒ©ãƒ™ãƒ«è¨­å®š:</strong> ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š</p>';
            }
            
            html += '<p><strong>ğŸš€ Phase 3:</strong> å¼·åŒ–ç‰ˆã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ å®Œå…¨ç‰ˆé©ç”¨æ¸ˆã¿ï¼ˆ90%+ ç²¾åº¦ï¼‰</p>';
            
            html += '<p><strong>ãƒ©ãƒ™ãƒ«åˆ¥ä»¶æ•°:</strong></p><ul>';
            Object.entries(labelStats).sort((a, b) => b[1] - a[1]).forEach(([label, count]) => {
                html += `<li>${label}: ${count}ä»¶</li>`;
            });
            html += '</ul>';
            
            statsContent.innerHTML = html;
            statsDiv.style.display = 'block';
        }

        function showSampleResults() {
            const sampleDiv = document.getElementById('sampleResults');
            const sampleContent = document.getElementById('sampleContent');
            
            let html = '';
            for (let i = 1; i <= 5 && i < processedData.length; i++) {
                const row = processedData[i];
                const sentimentLines = row[15].split('\\n');
                html += `<div class="result-item">
                    <strong>ãƒ¬ãƒ“ãƒ¥ãƒ¼:</strong> ${String(row[10]).substring(0, 100)}...<br>
                    <strong>ãƒ©ãƒ™ãƒ«:</strong> ${row[11]}<br>
                    <strong>å¹´æœˆ:</strong> ${row[14]}<br>
                    <strong>ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆåˆ†æ:</strong><br>
                    ${sentimentLines.map(line => `&nbsp;&nbsp;${line}`).join('<br>')}
                </div>`;
            }
            
            sampleContent.innerHTML = html;
            sampleDiv.style.display = 'block';
        }

        function downloadExcel() {
            if (!processedData) return;
            
            const wb = XLSX.utils.book_new();
            const ws1 = XLSX.utils.aoa_to_sheet(processedData);
            XLSX.utils.book_append_sheet(wb, ws1, 'ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ‡ãƒ¼ã‚¿');
            
            const statsData = createStatisticsSheet();
            const ws2 = XLSX.utils.aoa_to_sheet(statsData);
            XLSX.utils.book_append_sheet(wb, ws2, 'çµ±è¨ˆåˆ†æ');
            
            const sentimentSummaryData = createSentimentSummarySheet();
            const ws3 = XLSX.utils.aoa_to_sheet(sentimentSummaryData);
            XLSX.utils.book_append_sheet(wb, ws3, 'ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆåˆ†æ');
            
            XLSX.writeFile(wb, 'ãƒšãƒƒãƒˆãƒ•ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼åˆ†æçµæœ_Phase3_å®Œå…¨ç‰ˆ.xlsx');
        }

        function createStatisticsSheet() {
            const statsData = [['ãƒšãƒƒãƒˆãƒ•ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼åˆ†æçµæœ - çµ±è¨ˆåˆ†æï¼ˆPhase 3: å¼·åŒ–ç‰ˆå®Œå…¨ç‰ˆï¼‰']];
            statsData.push([]);
            
            const yearMonthLabelCounts = {};
            const quarterLabelCounts = {};
            const yearMonthTotals = {};
            const quarterTotals = {};
            
            const allLabels = new Set(labelConfig.length > 0 ? 
                labelConfig.map(c => c.name) : masterLabels);
            const allYearMonths = new Set();
            const allQuarters = new Set();
            
            for (let i = 1; i < processedData.length; i++) {
                const yearMonth = processedData[i][14];
                const quarter = processedData[i][16];
                const label = processedData[i][11];
                
                if (yearMonth && label) {
                    allYearMonths.add(yearMonth);
                    yearMonthTotals[yearMonth] = (yearMonthTotals[yearMonth] || 0) + 1;
                    
                    if (!yearMonthLabelCounts[yearMonth]) {
                        yearMonthLabelCounts[yearMonth] = {};
                    }
                    
                    yearMonthLabelCounts[yearMonth][label] = 
                        (yearMonthLabelCounts[yearMonth][label] || 0) + 1;
                }
                
                if (quarter && label) {
                    allQuarters.add(quarter);
                    quarterTotals[quarter] = (quarterTotals[quarter] || 0) + 1;
                    
                    if (!quarterLabelCounts[quarter]) {
                        quarterLabelCounts[quarter] = {};
                    }
                    
                    quarterLabelCounts[quarter][label] = 
                        (quarterLabelCounts[quarter][label] || 0) + 1;
                }
            }
            
            const sortedYearMonths = Array.from(allYearMonths).sort();
            const sortedQuarters = Array.from(allQuarters).sort();
            const sortedLabels = Array.from(allLabels);
            
            statsData.push(['ã€è¡¨1ã€‘å¹´æœˆã”ã¨ã®å®Ÿæ•°æ¨ç§»']);
            statsData.push(['ãƒ©ãƒ™ãƒ«', ...sortedYearMonths]);
            
            sortedLabels.forEach(label => {
                const row = [label];
                sortedYearMonths.forEach(ym => {
                    row.push(yearMonthLabelCounts[ym] && yearMonthLabelCounts[ym][label] ? yearMonthLabelCounts[ym][label] : 0);
                });
                statsData.push(row);
            });
            
            const totalRow = ['åˆè¨ˆ'];
            sortedYearMonths.forEach(ym => {
                totalRow.push(yearMonthTotals[ym] || 0);
            });
            statsData.push(totalRow);
            
            statsData.push([]);
            statsData.push([]);
            
            statsData.push(['ã€è¡¨2ã€‘å¹´æœˆã”ã¨ã®å‰²åˆæ¨ç§»ï¼ˆ%ï¼‰']);
            statsData.push(['ãƒ©ãƒ™ãƒ«', ...sortedYearMonths]);
            
            sortedLabels.forEach(label => {
                const row = [label];
                sortedYearMonths.forEach(ym => {
                    const count = yearMonthLabelCounts[ym] && yearMonthLabelCounts[ym][label] ? yearMonthLabelCounts[ym][label] : 0;
                    const total = yearMonthTotals[ym] || 1;
                    const percentage = ((count / total) * 100).toFixed(1);
                    row.push(percentage + '%');
                });
                statsData.push(row);
            });
            
            statsData.push([]);
            statsData.push([]);
            
            statsData.push(['ã€è¡¨3ã€‘ã‚¯ã‚©ãƒ¼ã‚¿ãƒ¼ã”ã¨ã®ã¾ã¨ã‚']);
            
            statsData.push(['ãƒ©ãƒ™ãƒ«ï¼ˆå®Ÿæ•°ï¼‰', ...sortedQuarters]);
            sortedLabels.forEach(label => {
                const row = [label];
                sortedQuarters.forEach(q => {
                    row.push(quarterLabelCounts[q] && quarterLabelCounts[q][label] ? quarterLabelCounts[q][label] : 0);
                });
                statsData.push(row);
            });
            
            const quarterTotalRow = ['åˆè¨ˆ'];
            sortedQuarters.forEach(q => {
                quarterTotalRow.push(quarterTotals[q] || 0);
            });
            statsData.push(quarterTotalRow);
            
            statsData.push([]);
            
            statsData.push(['ãƒ©ãƒ™ãƒ«ï¼ˆå‰²åˆ%ï¼‰', ...sortedQuarters]);
            sortedLabels.forEach(label => {
                const row = [label];
                sortedQuarters.forEach(q => {
                    const count = quarterLabelCounts[q] && quarterLabelCounts[q][label] ? quarterLabelCounts[q][label] : 0;
                    const total = quarterTotals[q] || 1;
                    const percentage = ((count / total) * 100).toFixed(1);
                    row.push(percentage + '%');
                });
                statsData.push(row);
            });
            
            return statsData;
        }

        function createSentimentSummarySheet() {
            const summaryData = [['ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆåˆ†æã‚µãƒãƒªãƒ¼ï¼ˆPhase 3: å¼·åŒ–ç‰ˆå®Œå…¨ç‰ˆï¼‰']];
            summaryData.push([]);
            
            const positive = sentimentDataList.filter(s => s.label === 'ãƒã‚¸ãƒ†ã‚£ãƒ–').length;
            const negative = sentimentDataList.filter(s => s.label === 'ãƒã‚¬ãƒ†ã‚£ãƒ–').length;
            const neutral = sentimentDataList.filter(s => s.label === 'ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«').length;
            const total = sentimentDataList.length;
            
            summaryData.push(['é …ç›®', 'ä»¶æ•°', 'å‰²åˆ']);
            summaryData.push(['ç·ãƒ¬ãƒ“ãƒ¥ãƒ¼æ•°', total, '100.0%']);
            summaryData.push(['ãƒã‚¸ãƒ†ã‚£ãƒ–', positive, `${(positive/total*100).toFixed(1)}%`]);
            summaryData.push(['ãƒã‚¬ãƒ†ã‚£ãƒ–', negative, `${(negative/total*100).toFixed(1)}%`]);
            summaryData.push(['ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«', neutral, `${(neutral/total*100).toFixed(1)}%`]);
            
            summaryData.push([]);
            summaryData.push(['ä¸»ãªå‚¾å‘']);
            
            if (positive > negative * 2) {
                summaryData.push(['å…¨ä½“çš„ã«å¥½è©•ä¾¡ãŒå¤šãã€è£½å“ã«å¯¾ã™ã‚‹æº€è¶³åº¦ãŒé«˜ã„å‚¾å‘ã«ã‚ã‚Šã¾ã™ã€‚']);
            }
            if (negative > positive * 2) {
                summaryData.push(['æ”¹å–„ãŒå¿…è¦ãªç‚¹ãŒå¤šãè¦‹å—ã‘ã‚‰ã‚Œã¾ã™ã€‚']);
            }
            if (Math.abs(positive - negative) < total * 0.1) {
                summaryData.push(['è©•ä¾¡ãŒåˆ†ã‹ã‚Œã¦ãŠã‚Šã€å€‹ä½“å·®ã‚„å¥½ã¿ã®é•ã„ãŒå¤§ãã„ã‚ˆã†ã§ã™ã€‚']);
            }
            
            summaryData.push([]);
            summaryData.push(['æœˆåˆ¥ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆæ¨ç§»']);
            
            const monthSentiment = {};
            for (let i = 1; i < processedData.length; i++) {
                const yearMonth = processedData[i][14];
                const sentiment = processedData[i][15];
                
                if (yearMonth && sentiment) {
                    if (!monthSentiment[yearMonth]) {
                        monthSentiment[yearMonth] = {
                            'ãƒã‚¸ãƒ†ã‚£ãƒ–': 0,
                            'ãƒã‚¬ãƒ†ã‚£ãƒ–': 0,
                            'ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«': 0
                        };
                    }
                    
                    const sentimentMatch = sentiment.match(/ãƒ©ãƒ™ãƒ«: (\w+)/);
                    if (sentimentMatch) {
                        monthSentiment[yearMonth][sentimentMatch[1]]++;
                    }
                }
            }
            
            const sortedMonths = Object.keys(monthSentiment).sort();
            summaryData.push(['å¹´æœˆ', 'ãƒã‚¸ãƒ†ã‚£ãƒ–', 'ãƒã‚¬ãƒ†ã‚£ãƒ–', 'ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«']);
            
            sortedMonths.forEach(month => {
                summaryData.push([
                    month,
                    monthSentiment[month]['ãƒã‚¸ãƒ†ã‚£ãƒ–'],
                    monthSentiment[month]['ãƒã‚¬ãƒ†ã‚£ãƒ–'],
                    monthSentiment[month]['ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«']
                ]);
            });
            
            return summaryData;
        }
        
        // æ•™å¸«ãƒ‡ãƒ¼ã‚¿å­¦ç¿’ã‚·ã‚¹ãƒ†ãƒ ã¯å‰Šé™¤ã•ã‚Œã¾ã—ãŸ
        
    </script>
</body>
</html>
