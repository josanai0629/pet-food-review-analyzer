<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒšãƒƒãƒˆãƒ•ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼åˆ†æãƒ„ãƒ¼ãƒ«</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .upload-area {
            border: 2px dashed #4CAF50;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin: 20px 0;
            background-color: #f9f9f9;
            transition: all 0.3s;
        }
        .upload-area:hover {
            background-color: #e8f5e9;
        }
        .upload-area.dragover {
            background-color: #c8e6c9;
            border-color: #2E7D32;
        }
        .file-input {
            display: none;
        }
        .upload-button {
            background-color: #4CAF50;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
            transition: background-color 0.3s;
        }
        .upload-button:hover {
            background-color: #45a049;
        }
        .progress {
            margin: 20px 0;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .stats {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .sentiment-summary {
            margin: 20px 0;
            padding: 15px;
            background-color: #e3f2fd;
            border-radius: 5px;
            border-left: 4px solid #2196F3;
        }
        .sample-results {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            max-height: 300px;
            overflow-y: auto;
        }
        .result-item {
            margin: 10px 0;
            padding: 10px;
            background-color: white;
            border-radius: 5px;
            border-left: 4px solid #4CAF50;
        }
        .error {
            color: #d32f2f;
            font-weight: bold;
        }
        .success {
            color: #388e3c;
            font-weight: bold;
        }
        .file-list {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #e0e0e0;
        }
        .file-item:last-child {
            border-bottom: none;
        }
        .remove-file {
            background-color: #f44336;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .remove-file:hover {
            background-color: #d32f2f;
        }
        .debug-button {
            background-color: #ff9800;
            margin-left: 10px;
        }
        .debug-button:hover {
            background-color: #f57c00;
        }
        .master-info {
            background-color: #e8f5e9;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 12px;
            border-left: 4px solid #4CAF50;
        }
        
        /* æ–°æ©Ÿèƒ½: å¯è¦–åŒ–ã‚¨ãƒªã‚¢ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .visualization-container {
            margin: 20px 0;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #e0e0e0;
        }
        .chart-container {
            margin: 20px 0;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .chart-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            color: #333;
        }
        .chart-wrapper {
            position: relative;
            height: 400px;
            margin: 10px 0;
        }
        .chart-wrapper.small {
            height: 300px;
        }
        .dashboard-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .dashboard-card {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }
        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #4CAF50;
            margin: 10px 0;
        }
        .metric-label {
            font-size: 14px;
            color: #666;
            text-transform: uppercase;
        }
        .filter-controls {
            margin: 20px 0;
            padding: 15px;
            background-color: #e8f5e9;
            border-radius: 8px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .filter-group label {
            font-size: 12px;
            font-weight: bold;
            color: #333;
        }
        .filter-group select {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }
        .trend-indicator {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 12px;
            margin-left: 10px;
        }
        .trend-up {
            background-color: #c8e6c9;
            color: #2e7d32;
        }
        .trend-down {
            background-color: #ffcdd2;
            color: #d32f2f;
        }
        .trend-stable {
            background-color: #e1f5fe;
            color: #0277bd;
        }
        
        /* æ–°æ©Ÿèƒ½: é«˜ç²¾åº¦åŒ–è¡¨ç¤º */
        .accuracy-info {
            background-color: #e8f5e9;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #4CAF50;
        }
        .accuracy-badge {
            display: inline-block;
            background-color: #4CAF50;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 10px;
        }
        
        @media (max-width: 768px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }
            .filter-controls {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>ãƒšãƒƒãƒˆãƒ•ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼åˆ†æãƒ„ãƒ¼ãƒ«</h1>
        
        <div class="accuracy-info">
            <strong>ğŸ¤– OpenAI APIçµ±åˆç‰ˆ - é«˜ç²¾åº¦åˆ†é¡ã‚·ã‚¹ãƒ†ãƒ </strong><span class="accuracy-badge">OpenAIçµ±åˆ</span><br>
            GPT-4o-mini ã«ã‚ˆã‚‹æ–‡è„ˆç†è§£ã¨ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºå¯èƒ½ãªã‚«ãƒ†ã‚´ãƒªåˆ†é¡
        </div>
        
        <!-- ğŸ¯ ã‚«ãƒ†ã‚´ãƒªè¨­å®šã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
        <div class="accuracy-info" style="background-color: #f3e5f5; border-color: #9c27b0;">
            <strong>ğŸ¯ ã‚«ãƒ†ã‚´ãƒªè¨­å®š</strong><span class="accuracy-badge" style="background-color: #9c27b0;">ã‚«ã‚¹ã‚¿ãƒ </span><br>
            <label for="categoryInput">åˆ†é¡ã‚«ãƒ†ã‚´ãƒªã‚’è¨­å®šã—ã¦ãã ã•ã„ï¼ˆ1è¡Œ1ã‚«ãƒ†ã‚´ãƒªï¼‰ï¼š</label>
            <textarea id="categoryInput" rows="8" style="width: 100%; margin-top: 10px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; font-family: monospace;" placeholder="é£Ÿã¹ã‚‹
é£Ÿã¹ãªã„
åããƒ»ä¾¿ãŒæ‚ªããªã‚‹
åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„
å€¤ä¸ŠãŒã‚Š/é«˜ã„
å®‰ã„
é…é€ãƒ»æ¢±åŒ…
è³å‘³æœŸé™
ã‚¸ãƒƒãƒ‘ãƒ¼
ãã®ä»–">é£Ÿã¹ã‚‹
é£Ÿã¹ãªã„
åããƒ»ä¾¿ãŒæ‚ªããªã‚‹
åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„
å€¤ä¸ŠãŒã‚Š/é«˜ã„
å®‰ã„
é…é€ãƒ»æ¢±åŒ…
è³å‘³æœŸé™
ã‚¸ãƒƒãƒ‘ãƒ¼
ãã®ä»–</textarea>
            
        </div>
        
        <!-- A/Bãƒ†ã‚¹ãƒˆæ©Ÿèƒ½ -->
        <div class="accuracy-info" style="background-color: #e3f2fd; border-color: #2196F3;">
            <strong>ğŸ§ª A/Bãƒ†ã‚¹ãƒˆæ©Ÿèƒ½</strong><span class="accuracy-badge" style="background-color: #2196F3;">NEW</span><br>
            <label><input type="checkbox" id="enableAbTest"> A/Bãƒ†ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã‚’æœ‰åŠ¹åŒ–ï¼ˆå¾“æ¥ç‰ˆã¨ã®æ¯”è¼ƒï¼‰</label>
        </div>
        
        <div class="upload-area" id="uploadArea">
            <p>ã“ã“ã«Excelãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—<br>ã¾ãŸã¯</p>
            <input type="file" id="fileInput" class="file-input" accept=".xlsx,.xls" multiple>
            <label for="fileInput" class="upload-button">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</label>
            <p style="margin-top: 20px; font-size: 14px; color: #666;">
                å¿…è¦ãªãƒ•ã‚¡ã‚¤ãƒ«ï¼š<br>
                1. Raw_Review.xlsxï¼ˆãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ‡ãƒ¼ã‚¿ï¼‰<br>
                2. Master.xlsxï¼ˆãƒ©ãƒ™ãƒ«ãƒã‚¹ã‚¿ãƒ¼ï¼‰â€»ã‚ªãƒ—ã‚·ãƒ§ãƒ³
            </p>
            <div class="master-info">
                <strong>ğŸ¯ Master.xlsxã®æ–°å½¢å¼ï¼ˆæ‹¡å¼µæ©Ÿèƒ½ï¼‰ï¼š</strong><br>
                Aåˆ—ï¼šãƒ©ãƒ™ãƒ«åã€Båˆ—ï¼šå„ªå…ˆåº¦ï¼ˆæ•°å€¤ï¼‰ã€Cåˆ—ï¼šåˆ¤å®šãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆ|åŒºåˆ‡ã‚Šï¼‰<br>
                ä¾‹ï¼šA1=ã€Œé…é€ãƒ»æ¢±åŒ…ã€ã€B1=1ã€C1=ã€Œé…é€|æ¢±åŒ…|ç™ºé€|å±Šã|ç®±ã€<br>
                â€»å¾“æ¥å½¢å¼ï¼ˆAåˆ—ã®ã¿ï¼‰ã§ã‚‚å‹•ä½œã—ã¾ã™
            </div>
        </div>

        <div id="fileList" class="file-list" style="display: none;">
            <h3>ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«</h3>
            <div id="fileItems"></div>
        </div>
        
        <div id="status" class="progress" style="display: none;">
            ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„
        </div>

        <div style="text-align: center;">
            <button onclick="processData()" id="processBtn" style="display: none;">ãƒ‡ãƒ¼ã‚¿å‡¦ç†ã‚’é–‹å§‹</button>
            <button onclick="debugDateData()" id="debugBtn" class="debug-button" style="display: none;">æ—¥ä»˜ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ‡ãƒãƒƒã‚°</button>
            <button onclick="downloadExcel()" id="downloadBtn" disabled>Excelãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
            <button onclick="toggleVisualization()" id="visualizeBtn" disabled style="background-color: #2196F3;">ğŸ“Š å¯è¦–åŒ–è¡¨ç¤º</button>
        </div>

        <!-- æ–°æ©Ÿèƒ½: ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ -->
        <div id="dashboardSection" class="visualization-container" style="display: none;">
            <h2>ğŸ“Š åˆ†æãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰</h2>
            
            <!-- ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼æ©Ÿèƒ½ -->
            <div class="filter-controls">
                <div class="filter-group">
                    <label>æœŸé–“ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼</label>
                    <select id="periodFilter" onchange="updateCharts()">
                        <option value="all">å…¨æœŸé–“</option>
                        <option value="last3months">ç›´è¿‘3ãƒ¶æœˆ</option>
                        <option value="last6months">ç›´è¿‘6ãƒ¶æœˆ</option>
                        <option value="thisyear">ä»Šå¹´</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label>è¡¨ç¤ºãƒ©ãƒ™ãƒ«</label>
                    <select id="labelFilter" onchange="updateCharts()">
                        <option value="all">å…¨ãƒ©ãƒ™ãƒ«</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label>ãƒãƒ£ãƒ¼ãƒˆç¨®åˆ¥</label>
                    <select id="chartType" onchange="updateCharts()">
                        <option value="line">æŠ˜ã‚Œç·šã‚°ãƒ©ãƒ•</option>
                        <option value="bar">æ£’ã‚°ãƒ©ãƒ•</option>
                        <option value="area">é¢ã‚°ãƒ©ãƒ•</option>
                    </select>
                </div>
            </div>

            <!-- KPI ã‚«ãƒ¼ãƒ‰ -->
            <div class="dashboard-grid">
                <div class="dashboard-card">
                    <div class="metric-label">ç·ãƒ¬ãƒ“ãƒ¥ãƒ¼æ•°</div>
                    <div class="metric-value" id="totalReviews">0</div>
                    <span id="reviewsTrend" class="trend-indicator"></span>
                </div>
                <div class="dashboard-card">
                    <div class="metric-label">ãƒã‚¸ãƒ†ã‚£ãƒ–ç‡</div>
                    <div class="metric-value" id="positiveRate">0%</div>
                    <span id="positiveTrend" class="trend-indicator"></span>
                </div>
                <div class="dashboard-card">
                    <div class="metric-label">æœ€å¤šãƒ©ãƒ™ãƒ«</div>
                    <div class="metric-value" id="topLabel">-</div>
                    <span id="topLabelCount" class="trend-indicator"></span>
                </div>
                <div class="dashboard-card">
                    <div class="metric-label">å¹³å‡ã‚¹ã‚³ã‚¢</div>
                    <div class="metric-value" id="avgScore">0</div>
                    <span id="scoreTrend" class="trend-indicator"></span>
                </div>
            </div>

            <!-- ãƒãƒ£ãƒ¼ãƒˆã‚¨ãƒªã‚¢ -->
            <div class="chart-container">
                <div class="chart-title">æœˆåˆ¥ãƒ¬ãƒ“ãƒ¥ãƒ¼æ¨ç§»</div>
                <div class="chart-wrapper">
                    <canvas id="monthlyTrendChart"></canvas>
                </div>
            </div>

            <div class="dashboard-grid">
                <div class="chart-container">
                    <div class="chart-title">ãƒ©ãƒ™ãƒ«åˆ†å¸ƒ</div>
                    <div class="chart-wrapper small">
                        <canvas id="labelDistributionChart"></canvas>
                    </div>
                </div>
                <div class="chart-container">
                    <div class="chart-title">ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆåˆ†æ</div>
                    <div class="chart-wrapper small">
                        <canvas id="sentimentChart"></canvas>
                    </div>
                </div>
            </div>

            <div class="chart-container">
                <div class="chart-title">ã‚¯ã‚©ãƒ¼ã‚¿ãƒ¼åˆ¥æ¯”è¼ƒ</div>
                <div class="chart-wrapper">
                    <canvas id="quarterlyChart"></canvas>
                </div>
            </div>

            <!-- ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—é¢¨ã®è¡¨ç¤º -->
            <div class="chart-container">
                <div class="chart-title">ãƒ©ãƒ™ãƒ«Ã—ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆ ãƒãƒˆãƒªãƒƒã‚¯ã‚¹</div>
                <div id="heatmapContainer" style="overflow-x: auto;">
                    <table id="heatmapTable" style="width: 100%; border-collapse: collapse;">
                    </table>
                </div>
            </div>
        </div>

        <div id="stats" class="stats" style="display: none;">
            <h3>å‡¦ç†çµ±è¨ˆ</h3>
            <div id="statsContent"></div>
        </div>

        <div id="sentimentSummary" class="sentiment-summary" style="display: none;">
            <h3>ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆåˆ†æã‚µãƒãƒªãƒ¼</h3>
            <div id="sentimentContent"></div>
        </div>

        <div id="sampleResults" class="sample-results" style="display: none;">
            <h3>å‡¦ç†çµæœã‚µãƒ³ãƒ—ãƒ«</h3>
            <div id="sampleContent"></div>
        </div>
    </div>

    <script>
        let processedData = null;
        let rawData = null;
        let masterLabels = [
            'é£Ÿã¹ã‚‹', 'é£Ÿã¹ãªã„', 'åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„', 'ãã®ä»–', 'å®‰ã„',
            'é…é€ãƒ»æ¢±åŒ…', 'å€¤ä¸ŠãŒã‚Š/é«˜ã„', 'åããƒ»ä¾¿ãŒæ‚ªããªã‚‹', 'è³å‘³æœŸé™', 'ã‚¸ãƒƒãƒ‘ãƒ¼'
        ];
        let labelConfig = [];
        let uploadedFiles = {};
        let sentimentDataList = [];
        
        // æ–°æ©Ÿèƒ½: ãƒãƒ£ãƒ¼ãƒˆç®¡ç†
        let charts = {};
        let dashboardVisible = false;
        let analysisData = {};

        // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã®è¨­å®š
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });

        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
        });

        function handleFiles(files) {
            Array.from(files).forEach(file => {
                if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        uploadedFiles[file.name] = {
                            name: file.name,
                            data: e.target.result
                        };
                        updateFileList();
                        checkFiles();
                    };
                    reader.readAsArrayBuffer(file);
                }
            });
        }

        function updateFileList() {
            const fileList = document.getElementById('fileList');
            const fileItems = document.getElementById('fileItems');
            
            if (Object.keys(uploadedFiles).length > 0) {
                fileList.style.display = 'block';
                fileItems.innerHTML = '';
                
                Object.values(uploadedFiles).forEach(file => {
                    const item = document.createElement('div');
                    item.className = 'file-item';
                    item.innerHTML = `
                        <span>${file.name}</span>
                        <button class="remove-file" onclick="removeFile('${file.name}')">å‰Šé™¤</button>
                    `;
                    fileItems.appendChild(item);
                });
            } else {
                fileList.style.display = 'none';
            }
        }

        function removeFile(fileName) {
            delete uploadedFiles[fileName];
            updateFileList();
            checkFiles();
        }

        function checkFiles() {
            const hasRawReview = Object.keys(uploadedFiles).some(name => 
                name.toLowerCase().includes('raw_review') || name.toLowerCase().includes('review')
            );
            
            if (hasRawReview) {
                document.getElementById('processBtn').style.display = 'inline-block';
                document.getElementById('debugBtn').style.display = 'inline-block';
                document.getElementById('status').style.display = 'block';
                document.getElementById('status').textContent = 'å‡¦ç†æº–å‚™å®Œäº†';
                
                const masterFile = Object.values(uploadedFiles).find(file => 
                    file.name.toLowerCase().includes('master')
                );
                if (masterFile) {
                    const workbook = XLSX.read(masterFile.data);
                    const sheet = workbook.Sheets[workbook.SheetNames[0]];
                    const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                    
                    const hasExtendedFormat = data.some(row => row[1] || row[2]);
                    
                    if (hasExtendedFormat) {
                        labelConfig = data
                            .filter(row => row[0])
                            .map(row => ({
                                name: row[0],
                                priority: parseInt(row[1]) || 999,
                                patterns: row[2] ? row[2].split('|').filter(p => p.trim()) : []
                            }))
                            .sort((a, b) => a.priority - b.priority);
                        
                        console.log('ã‚«ã‚¹ã‚¿ãƒ ãƒ©ãƒ™ãƒ«è¨­å®šã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ:', labelConfig);
                        document.getElementById('status').textContent = `å‡¦ç†æº–å‚™å®Œäº†ï¼ˆã‚«ã‚¹ã‚¿ãƒ ãƒ©ãƒ™ãƒ«è¨­å®š: ${labelConfig.length}ä»¶ï¼‰`;
                    } else {
                        labelConfig = [];
                        masterLabels = data.map(row => row[0]).filter(label => label);
                        console.log('å¾“æ¥å½¢å¼ã®Master.xlsxã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ:', masterLabels);
                    }
                } else {
                    labelConfig = [];
                }
            } else {
                document.getElementById('processBtn').style.display = 'none';
                document.getElementById('debugBtn').style.display = 'none';
                document.getElementById('status').style.display = 'none';
            }
        }

        function parseDate(dateStr) {
            if (!dateStr) return { year: '', month: '', yearMonth: '', quarter: '' };
            
            console.log('å…¥åŠ›ã•ã‚ŒãŸæ—¥ä»˜ãƒ‡ãƒ¼ã‚¿:', dateStr, 'ã‚¿ã‚¤ãƒ—:', typeof dateStr);
            
            let date = null;
            
            if (typeof dateStr === 'number' && dateStr > 25569) {
                const excelEpoch = new Date(1899, 11, 30);
                date = new Date(excelEpoch.getTime() + dateStr * 24 * 60 * 60 * 1000);
            }
            else if (typeof dateStr === 'string') {
                const yearMonthMatch = dateStr.match(/(\d{4})å¹´(\d{1,2})æœˆ/);
                if (yearMonthMatch) {
                    const year = parseInt(yearMonthMatch[1]);
                    const month = parseInt(yearMonthMatch[2]);
                    date = new Date(year, month - 1, 1);
                }
                else {
                    const normalizedDate = dateStr.replace(/[å¹´æœˆæ—¥]/g, '/').replace(/-/g, '/');
                    const testDate = new Date(normalizedDate);
                    if (!isNaN(testDate.getTime())) {
                        date = testDate;
                    }
                }
            }
            
            if (date && !isNaN(date.getTime())) {
                const year = date.getFullYear().toString();
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                const monthNum = parseInt(month);
                const quarter = `${year}Q${Math.ceil(monthNum / 3)}`;
                
                const result = {
                    year: year,
                    month: month,
                    yearMonth: `${year}å¹´${month}æœˆ`,
                    quarter: quarter
                };
                
                console.log('è§£æçµæœ:', result);
                return result;
            }
            
            console.log('æ—¥ä»˜è§£æå¤±æ•—:', dateStr);
            return { year: '', month: '', yearMonth: '', quarter: '' };
        }

        function debugDateData() {
            if (!rawData || rawData.length < 2) {
                const rawReviewFile = Object.values(uploadedFiles).find(file => 
                    file.name.toLowerCase().includes('raw_review') || file.name.toLowerCase().includes('review')
                );
                
                if (!rawReviewFile) {
                    alert('ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    return;
                }
                
                const rawWorkbook = XLSX.read(rawReviewFile.data);
                const rawSheet = rawWorkbook.Sheets[rawWorkbook.SheetNames[0]];
                rawData = XLSX.utils.sheet_to_json(rawSheet, { header: 1 });
            }
            
            console.log('=== æ—¥ä»˜ãƒ‡ãƒ¼ã‚¿ã®ãƒ‡ãƒãƒƒã‚°æƒ…å ± ===');
            console.log('ãƒ˜ãƒƒãƒ€ãƒ¼:', rawData[0]);
            
            for (let i = 1; i <= Math.min(10, rawData.length - 1); i++) {
                const dateValue = rawData[i][1];
                console.log(`${i}è¡Œç›® Båˆ—:`, dateValue, 'ã‚¿ã‚¤ãƒ—:', typeof dateValue);
                
                if (dateValue) {
                    const parsed = parseDate(dateValue);
                    console.log(`  â†’ è§£æçµæœ:`, parsed);
                }
            }
            
            alert('ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚F12ã‚’æŠ¼ã—ã¦Consoleã‚¿ãƒ–ã‚’è¦‹ã¦ãã ã•ã„ã€‚');
        }

        // ğŸ¯ æ–°æ©Ÿèƒ½: æ–‡è„ˆåˆ†ææ©Ÿèƒ½
        function analyzeReviewContext(reviewText) {
            if (!reviewText) return null;
            
            const sentences = reviewText.split(/[ã€‚ï¼ï¼Ÿ\n]/).filter(s => s.trim());
            const timeMarkers = {
                past: ['ä»Šã¾ã§', 'ã“ã‚Œã¾ã§', 'ä»¥å‰', 'å‰ã¯', 'ã‚‚ã¨ã‚‚ã¨', 'æ˜”ã‹ã‚‰', 'å¾“æ¥'],
                current: ['ã“ã¡ã‚‰', 'ã“ã®å•†å“', 'ä»Šå›', 'ã“ã‚Œ', 'ã§ã‚‚', 'ç¾åœ¨', 'ã„ã¾ã¯'],
                transition: ['ã—ã‹ã—', 'ã¨ã“ã‚ãŒ', 'ã§ã‚‚', 'ã‘ã‚Œã©', 'ãŒã€', 'ãŸã ', 'ã—ã‹ã—']
            };
            
            let contextAnalysis = {
                pastContext: [],
                currentContext: [],
                hasTransition: false,
                timelineDetected: false
            };
            
            sentences.forEach((sentence, index) => {
                const cleanSentence = sentence.trim();
                if (!cleanSentence) return;
                
                // æ™‚ç³»åˆ—ãƒãƒ¼ã‚«ãƒ¼ã®æ¤œå‡º
                if (timeMarkers.past.some(marker => cleanSentence.includes(marker))) {
                    contextAnalysis.pastContext.push({sentence: cleanSentence, index});
                    contextAnalysis.timelineDetected = true;
                }
                
                if (timeMarkers.current.some(marker => cleanSentence.includes(marker))) {
                    contextAnalysis.currentContext.push({sentence: cleanSentence, index});
                    contextAnalysis.timelineDetected = true;
                }
                
                // è»¢æ›ãƒãƒ¼ã‚«ãƒ¼ã®æ¤œå‡º
                if (timeMarkers.transition.some(marker => cleanSentence.includes(marker))) {
                    contextAnalysis.hasTransition = true;
                }
            });
            
            return contextAnalysis;
        }

        // ğŸ¯ Phase 4ç”¨ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°é–¢æ•°ï¼ˆå„ªå…ˆåº¦1ãƒ»2å¯¾å¿œç‰ˆï¼‰
        function addScoresByKeywordsEnhanced(text, scores, weight = 1.0) {
            const lowerText = text.toLowerCase();
            
            // é£Ÿã¹ã‚‹é–¢é€£ï¼ˆå¤§å¹…æ‹¡å¼µ + æ–‡è„ˆè€ƒæ…®å¼·åŒ–ï¼‰
            const eatPatterns = {
                veryStrong: [
                    /å®Œé£Ÿ/, /ãƒšãƒ­ãƒª/, /ãƒšãƒ­ãƒƒã¨/, /ãƒã‚¯ãƒã‚¯/, /ãŒã£ã¤[ãã]/,
                    /å¤¢ä¸­.{0,10}é£Ÿã¹/, /å‹¢ã„.{0,10}é£Ÿã¹/, /é£›ã³ä»˜/,
                    /å–œã‚“ã§.{0,15}å®Œé£Ÿ/, /ç¾å‘³ã—ãã†ã«.{0,10}é£Ÿã¹/
                ],
                strong: [
                    /ã‚ˆãé£Ÿã¹/, /é£Ÿã¹[ã‚‹ã¦ãŸã‚Š]/, /ãŸã¹[ã‚‹ã¦ãŸã‚Š]/,
                    /é£Ÿã„ã¤[ããã„].{0,5}(è‰¯|ã„ã„|ã‚ˆ[ã„ãã‹])/, 
                    /ç¾å‘³[ã—ã]/, /ãŠã„ã—/, /æ°—ã«å…¥/, /å¤§å¥½ã/,
                    /å–œã‚“ã§/, /ãŠæ°—ã«å…¥ã‚Š/, /ãƒªãƒ”ãƒ¼ãƒˆ/,
                    /ã™ãã«é£Ÿã¹/, /ä¸€ç¬ã§é£Ÿã¹/, /ã™ã”ã„å‹¢ã„ã§/
                ],
                medium: [
                    /é£Ÿã¹ã¦.{0,5}ãã‚Œ/, /ã¡ã‚ƒã‚“ã¨.{0,5}é£Ÿã¹/,
                    /ã—ã£ã‹ã‚Š.{0,5}é£Ÿã¹/, /å…¨éƒ¨.{0,5}é£Ÿã¹/,
                    /æ™®é€šã«é£Ÿã¹/, /ã¾ã‚ã¾ã‚é£Ÿã¹/
                ],
                weak: [
                    /é£Ÿã¹/, /ãŸã¹/  // æœ€ä½é™ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
                ]
            };
            
            // ã‚¹ã‚³ã‚¢é…ç‚¹
            eatPatterns.veryStrong.forEach(pattern => {
                if (lowerText.match(pattern)) scores['é£Ÿã¹ã‚‹'] += 15 * weight;
            });
            eatPatterns.strong.forEach(pattern => {
                if (lowerText.match(pattern)) scores['é£Ÿã¹ã‚‹'] += 10 * weight;
            });
            eatPatterns.medium.forEach(pattern => {
                if (lowerText.match(pattern)) scores['é£Ÿã¹ã‚‹'] += 5 * weight;
            });
            eatPatterns.weak.forEach(pattern => {
                if (lowerText.match(pattern)) scores['é£Ÿã¹ã‚‹'] += 2 * weight;
            });
            
            // é£Ÿã¹ãªã„é–¢é€£ï¼ˆå¼·åŒ–ç‰ˆ + æ–‡è„ˆç²¾å¯†åŒ–ï¼‰
            const noEatPatterns = {
                veryStrong: [
                    /å…¨ãé£Ÿã¹ãªã„/, /å…¨ç„¶é£Ÿã¹ãªã„/, /çµ¶å¯¾ã«é£Ÿã¹ãªã„/,
                    /è¦‹å‘ãã‚‚ã—ãªã„/, /å®Œå…¨æ‹’å¦/, /ä¸€å£ã‚‚é£Ÿã¹/,
                    /åŒ‚ã„.{0,5}å—…[ã„ã]ã ã ã‘.{0,10}(çµ‚ã‚ã‚Š|ãŠã—ã¾ã„)/
                ],
                strong: [
                    /é£Ÿã¹(ã¦ãã‚Œ)?ãª[ã„ã‹]/, /æ‹’å¦.{0,10}ã™ã‚‹/,
                    /å£ã«ã—ãª[ã„ã‹]/, /ãã£ã½.{0,5}å‘[ãã]/,
                    /è­¦æˆ’.{0,10}ã—ã¦.{0,5}é£Ÿã¹ãª[ã„ã‹]/,
                    /è¿‘ã¥[ã‹ã]ã‚‚ã—ãª[ã„ã‹]/
                ],
                medium: [
                    /æ®‹ã—ã¦/, /é£Ÿã¹æ®‹[ã™ã—]/, /åŒ‚ã„.{0,5}å—…[ã„ã]ã ã ã‘/,
                    /èˆˆå‘³.{0,5}ç¤ºã•ãª/, /é£Ÿã„ã¤[ã‹ãã].{0,5}(æ‚ª|ãªã„|ãƒ€ãƒ¡)/,
                    /é£Ÿã¹[ã‚‹ã¦].{0,5}(ã®ã«|ã‘ã©).{0,5}æ™‚é–“.{0,5}ã‹ã‹[ã‚‹ã£ã‚Š]/
                ],
                exclusions: [
                    /(ä»Šã¾ã§|ä»¥å‰|ã“ã‚Œã¾ã§|å‰ã¯|ã‚‚ã¨ã‚‚ã¨|æ˜”ã¯).{0,50}é£Ÿã¹.*ãª[ã„ã‹]/,
                    /(ä»–ã®|åˆ¥ã®|é•ã†|å‰ã®).{0,30}(ãƒ•ãƒ¼ãƒ‰|ã‚¨ã‚µ|é¤Œ)/,
                    /(â—‹â—‹|â–³â–³|Ã—Ã—|ä»–ç¤¾|Aç¤¾|Bç¤¾).{0,20}(ã¯|ã§ã¯).{0,20}é£Ÿã¹.*ãª[ã„ã‹]/,
                    /(æœ€åˆ|ã¯ã˜ã‚).{0,20}é£Ÿã¹.*ãª[ã„ã‹].{0,20}(ã§ã‚‚|ã‘ã©|ãŒ).{0,20}(ä»Š|ç¾åœ¨|ã„ã¾)/,
                    /é£Ÿã¹.*ãª[ã„ã‹].{0,20}(ã§ã‚‚|ã‘ã©|ãŒ).{0,20}(å¥åº·|å…ƒæ°—|èª¿å­)/
                ]
            };
            
            // é™¤å¤–ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒã‚§ãƒƒã‚¯ï¼ˆéå»ã®è©±ã‚„ä»–ç¤¾è£½å“ã®è©±ã‚’é™¤å¤–ï¼‰
            const hasExclusion = noEatPatterns.exclusions.some(pattern => 
                lowerText.match(pattern));
            
            if (!hasExclusion) {
                noEatPatterns.veryStrong.forEach(pattern => {
                    if (lowerText.match(pattern)) scores['é£Ÿã¹ãªã„'] += 15 * weight;
                });
                noEatPatterns.strong.forEach(pattern => {
                    if (lowerText.match(pattern)) scores['é£Ÿã¹ãªã„'] += 10 * weight;
                });
                noEatPatterns.medium.forEach(pattern => {
                    if (lowerText.match(pattern)) scores['é£Ÿã¹ãªã„'] += 5 * weight;
                });
            }
            
            // å¥åº·é–¢é€£ï¼ˆæ”¹å–„ï¼‰- å¼·åŒ–ç‰ˆ
            const healthImprovePatterns = [
                /(å|å˜”å|åãæˆ»ã—).{0,20}(æ¸›[ã£ãŸã‚Š]|ãªããª[ã£ãŸã‚Š]|ã—ãªããª[ã£ãŸã‚Š]|æ”¹å–„|è‰¯ããª[ã£ãŸã‚Š]|æ¸›å°‘|æ²»[ã£ãŸã¾ã‚Š])/,
                /ä¾¿.{0,20}(è‰¯[ãã„ã‹]ãª[ã£ãŸã‚Š]|æ”¹å–„|èª¿å­ãŒè‰¯|å¿«èª¿|ã—ã£ã‹ã‚Š|æ­£å¸¸|å›ºã|ç¡¬ã)/,
                /ã†ã‚“ã¡.{0,20}(è‰¯[ãã„ã‹]ãª[ã£ãŸã‚Š]|æ”¹å–„|ã—ã£ã‹ã‚Š|æ­£å¸¸)/,
                /æ¯›ç‰.{0,20}(æ¸›[ã£ãŸã‚Š]|ãªããª[ã£ãŸã‚Š]|å°‘ãª[ãã„])/,
                /æ¯›ä¸¦ã¿.{0,10}(è‰¯|ç¶ºéº—|ãƒ„ãƒ¤|ã‚µãƒ©ã‚µãƒ©)/
            ];
            healthImprovePatterns.forEach(pattern => {
                if (lowerText.match(pattern)) scores['åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„'] += 12 * weight;
            });
            
            // å¥åº·é–¢é€£ï¼ˆæ‚ªåŒ–ï¼‰- å³æ ¼ç‰ˆï¼ˆéå‰°åˆ†é¡ä¿®æ­£ï¼‰
            const healthWorsenPatterns = [
                /å[ãã„ãŸãã‘]|å˜”å|åãæˆ»[ã—ã™ã‚Š]|ã‚‚ã©[ã™ã—]/,
                /ä¸‹ç—¢|ã’ã‚Š|è»Ÿä¾¿|è¡€ä¾¿|ä¾¿ç§˜|ã¹ã‚“ã´/,
                /ä¾¿.{0,5}(ç·©[ã„ãã‚]|æ‚ª[ã„ãã‚]|è‡­[ã„ãã‚]|é»’[ã„ãã‚])/,
                /ã†ã‚“ã¡.{0,10}(ç·©[ã„ãã‚]|æ‚ª[ã„ãã‚]|è‡­[ã„ãã‚])/
            ];
            // æ”¹å–„ç³»ã®é™¤å¤–ã‚’å¼·åŒ–
            const hasHealthImprovement = lowerText.match(/(æ¸›[ã£ãŸã‚Š]|ãªããª[ã£ãŸã‚Š]|ã—ãªããª[ã£ãŸã‚Š]|æ”¹å–„|è‰¯ããª[ã£ãŸã‚Š]|æ²»[ã£ãŸã¾ã‚Š]|å…ƒæ°—|å¥åº·|èª¿å­.{0,5}è‰¯)/);
            
            if (!hasHealthImprovement) {
                healthWorsenPatterns.forEach(pattern => {
                    if (lowerText.match(pattern)) scores['åããƒ»ä¾¿ãŒæ‚ªããªã‚‹'] += 8 * weight;  // ã‚¹ã‚³ã‚¢ä¸‹ã’
                });
            }
            
            // ä¾¡æ ¼é–¢é€£ã®å¼·åŒ–ï¼ˆæ¤œå‡ºä¸è¶³ä¿®æ­£ï¼‰
            const pricePatterns = {
                'å€¤ä¸ŠãŒã‚Š/é«˜ã„': {
                    strong: [
                        /å€¤ä¸Š[ã’ãŒã‚Š].{0,10}(å›°[ã‚‹ã£ã‚Š]|è¾›[ã„ã]|ãã¤[ã„ã])/,
                        /é«˜ããª[ã£ã‚Š].{0,10}(å›°[ã‚‹ã£ã‚Š]|è²·[ãˆã„]ãªã„|ç¶š[ã‘ã‚‰]ãªã„)/,
                        /ä¾¡æ ¼.{0,5}ä¸ŠãŒ[ã£ã‚Š].{0,10}(æ®‹å¿µ|å›°[ã‚‹ã£ã‚Š])/,
                        /\d+å††.{0,10}(é«˜[ã„ã]|ãŸã‹[ã„ã]).{0,10}(æ„Ÿã˜|æ€[ã†ãˆ])/,
                        /å€¤ä¸Š[ã’ãŒã‚Š]/, /é«˜[ã„ãã‚]/, /ãŸã‹[ã„ãã‚]/, /é«˜ä¾¡/, /é«˜é¡/,
                        /ã‚‚ã†å°‘ã—.{0,10}å®‰[ãã‘]/, /å€¤æ®µ.{0,5}(é«˜[ã„ãã‚]|ãŸã‹[ã„ãã‚])/
                    ],
                    exclusions: [
                        /(å“è³ª|æ „é¤Š|åŸææ–™).{0,20}(è€ƒãˆã‚‹|æ€ã†).{0,10}é«˜[ãã‘]ãªã„/,
                        /(ã§ã‚‚|ã‘ã©|ãŒ).{0,20}(æº€è¶³|è‰¯[ã„ã]|ãŠã™ã™ã‚)/
                    ]
                },
                'å®‰ã„': {
                    strong: [
                        /ã‚³ã‚¹ãƒ‘.{0,5}(è‰¯[ã„ã]|æœ€é«˜|æŠœç¾¤)/,
                        /ãŠå¾—.{0,5}(æ„Ÿ|ã ã¨æ€[ã†ãˆ]|è³¼å…¥)/,
                        /\d+å††.{0,10}å®‰[ã„ã].{0,10}(åŠ©ã‹[ã‚‹ã£ã‚Š]|å¬‰ã—[ã„ã])/,
                        /å®‰[ã„ãã‚]|ã‚„ã™[ã„ãã‚]/, /æ‰‹é ƒ|æ‰‹ã”ã‚|ãƒªãƒ¼ã‚ºãƒŠãƒ–ãƒ«|å‰²å®‰|ãŠè²·ã„å¾—/,
                        /ä¾¡æ ¼.{0,5}(æº€è¶³|ç´å¾—)/
                    ],
                    exclusions: [
                        /(å®‰[ã„ã]ã‹ã‚‰|å®‰ä¾¡ã ã‹ã‚‰).{0,20}(ä¸å®‰|å¿ƒé…|è³ª)/,
                        /å®‰[ã„ã].{0,10}(ã‘ã©|ã§ã‚‚|ãŒ).{0,10}(å“è³ª|æ „é¤Š)/
                    ]
                }
            };
            
            // ä¾¡æ ¼é–¢é€£ã®æ¤œå‡ºå¼·åŒ–
            const hasPriceExclusion = 
                pricePatterns['å€¤ä¸ŠãŒã‚Š/é«˜ã„'].exclusions.some(p => lowerText.match(p)) ||
                pricePatterns['å®‰ã„'].exclusions.some(p => lowerText.match(p));
            
            if (!hasPriceExclusion) {
                pricePatterns['å€¤ä¸ŠãŒã‚Š/é«˜ã„'].strong.forEach(pattern => {
                    if (lowerText.match(pattern)) scores['å€¤ä¸ŠãŒã‚Š/é«˜ã„'] += 12 * weight;
                });
                
                pricePatterns['å®‰ã„'].strong.forEach(pattern => {
                    if (lowerText.match(pattern)) scores['å®‰ã„'] += 12 * weight;
                });
            }
            
            // ç·Šæ€¥ä¿®æ­£ï¼šæ•™å¸«ãƒ‡ãƒ¼ã‚¿ã«åŸºã¥ãå³æ ¼ãªãƒ‘ã‚¿ãƒ¼ãƒ³
            const correctedPatterns = {
                'é…é€ãƒ»æ¢±åŒ…': [
                    /é…é€|æ¢±åŒ…|ç™ºé€|å±Š[ãã„ãã‘]|ç®±|åŒ…è£…|é…é”|å®…é…|è·ç‰©|æ®µãƒœãƒ¼ãƒ«|ãƒ€ãƒ³ãƒœãƒ¼ãƒ«/
                    // ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸æƒ…å ±ç³»ã¯å‰Šé™¤ï¼ˆéå‰°åˆ†é¡ã®åŸå› ï¼‰
                ],
                'è³å‘³æœŸé™': [
                    /è³å‘³æœŸé™|æ¶ˆè²»æœŸé™|æœŸé™|æ—¥ä»˜|ä½¿ç”¨æœŸé™|æœ‰åŠ¹æœŸé™/
                ],
                'ã‚¸ãƒƒãƒ‘ãƒ¼': [
                    /ã‚¸ãƒƒãƒ‘ãƒ¼|ãƒãƒ£ãƒƒã‚¯|å¯†å°|ã‚¸ãƒƒãƒ—|ä¿å­˜.{0,10}(ä¸ä¾¿|å›°)|è¢‹.{0,10}(é–‰|ç· )|ãƒ•ã‚¡ã‚¹ãƒŠãƒ¼/
                ],
                'åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„': [
                    /(å|å˜”å|åãæˆ»ã—).{0,20}(æ¸›[ã£ãŸã‚Š]|ãªããª[ã£ãŸã‚Š]|ã—ãªããª[ã£ãŸã‚Š]|æ”¹å–„|è‰¯ããª[ã£ãŸã‚Š]|æ¸›å°‘|æ²»[ã£ãŸã¾ã‚Š])/,
                    /ä¾¿.{0,20}(è‰¯[ãã„ã‹]ãª[ã£ãŸã‚Š]|æ”¹å–„|èª¿å­ãŒè‰¯|å¿«èª¿|ã—ã£ã‹ã‚Š|æ­£å¸¸|å›ºã|ç¡¬ã)/,
                    /ã†ã‚“ã¡.{0,20}(è‰¯[ãã„ã‹]ãª[ã£ãŸã‚Š]|æ”¹å–„|ã—ã£ã‹ã‚Š|æ­£å¸¸)/,
                    /æ¯›ç‰.{0,20}(æ¸›[ã£ãŸã‚Š]|ãªããª[ã£ãŸã‚Š]|å°‘ãª[ãã„])/
                    // æ¯›ä¸¦ã¿ãƒ»ä½“é‡ç³»ã¯å‰Šé™¤ï¼ˆæœ¬æ¥ã®æ„å‘³ã«æˆ»ã™ï¼‰
                ],
                'é£Ÿã¹ã‚‹': [
                    /å®Œé£Ÿ/, /ãƒšãƒ­ãƒª/, /ãƒšãƒ­ãƒƒã¨/, /ãƒã‚¯ãƒã‚¯/, /ãŒã£ã¤[ãã]/,
                    /å¤¢ä¸­.{0,10}é£Ÿã¹/, /å‹¢ã„.{0,10}é£Ÿã¹/, /é£›ã³ä»˜/,
                    /å–œã‚“ã§.{0,15}å®Œé£Ÿ/, /ç¾å‘³ã—ãã†ã«.{0,10}é£Ÿã¹/,
                    /ã‚ˆãé£Ÿã¹/, /é£Ÿã¹[ã‚‹ã¦ãŸã‚Š]/, /ãŸã¹[ã‚‹ã¦ãŸã‚Š]/,
                    /é£Ÿã„ã¤[ããã„].{0,5}(è‰¯|ã„ã„|ã‚ˆ[ã„ãã‹])/, 
                    /ç¾å‘³[ã—ã]/, /ãŠã„ã—/, /æ°—ã«å…¥/, /å¤§å¥½ã/,
                    /å–œã‚“ã§/, /ãŠæ°—ã«å…¥ã‚Š/, /ãƒªãƒ”ãƒ¼ãƒˆ/,
                    /ã™ãã«é£Ÿã¹/, /ä¸€ç¬ã§é£Ÿã¹/, /ã™ã”ã„å‹¢ã„ã§/
                    // è³¼å…¥ç³»ã¯å‰Šé™¤ï¼ˆæœ¬æ¥ã®æ„å‘³ã«æˆ»ã™ï¼‰
                ],
                'é£Ÿã¹ãªã„': [
                    /å…¨ãé£Ÿã¹ãªã„/, /å…¨ç„¶é£Ÿã¹ãªã„/, /çµ¶å¯¾ã«é£Ÿã¹ãªã„/,
                    /è¦‹å‘ãã‚‚ã—ãªã„/, /å®Œå…¨æ‹’å¦/, /ä¸€å£ã‚‚é£Ÿã¹/,
                    /åŒ‚ã„.{0,5}å—…[ã„ã]ã ã ã‘.{0,10}(çµ‚ã‚ã‚Š|ãŠã—ã¾ã„)/,
                    /é£Ÿã¹(ã¦ãã‚Œ)?ãª[ã„ã‹]/, /æ‹’å¦.{0,10}ã™ã‚‹/,
                    /å£ã«ã—ãª[ã„ã‹]/, /ãã£ã½.{0,5}å‘[ãã]/,
                    /è­¦æˆ’.{0,10}ã—ã¦.{0,5}é£Ÿã¹ãª[ã„ã‹]/,
                    /è¿‘ã¥[ã‹ã]ã‚‚ã—ãª[ã„ã‹]/,
                    /æ®‹ã—ã¦/, /é£Ÿã¹æ®‹[ã™ã—]/, /åŒ‚ã„.{0,5}å—…[ã„ã]ã ã ã‘/,
                    /èˆˆå‘³.{0,5}ç¤ºã•ãª/, /é£Ÿã„ã¤[ã‹ãã].{0,5}(æ‚ª|ãªã„|ãƒ€ãƒ¡)/,
                    /é£Ÿã¹[ã‚‹ã¦].{0,5}(ã®ã«|ã‘ã©).{0,5}æ™‚é–“.{0,5}ã‹ã‹[ã‚‹ã£ã‚Š]/
                ]
            };
            
            // ä¿®æ­£ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°
            Object.entries(correctedPatterns).forEach(([category, patterns]) => {
                patterns.forEach(pattern => {
                    if (lowerText.match(pattern)) {
                        scores[category] += 10 * weight;
                    }
                });
            });
            
            // ã€Œãã®ä»–ã€ã¨ã—ã¦åˆ†é¡ã™ã¹ããƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œå‡º
            const otherExclusivePatterns = {
                åŸææ–™æˆåˆ†: /åŸææ–™|æˆåˆ†|ææ–™|ä¸­èº«é‡è¦–|ç´ æ|æ·»åŠ ç‰©|ã‚°ãƒ¬ã‚¤ãƒ³ãƒ•ãƒªãƒ¼|ç©€ç‰©ä¸ä½¿ç”¨|ç„¡æ·»åŠ |ä¿å­˜æ–™|ç€è‰²æ–™|å¤©ç„¶ç´ æ/,
                éæ¶ˆåŒ–å™¨ç³»å¥åº·: /æ¯›ä¸¦ã¿|æ¯›è‰¶|æ¯›è³ª|ã‚¢ãƒ¬ãƒ«ã‚®ãƒ¼|çš®è†š|ç—’ã¿|ã‹ã‚†ã¿|ä½“èª¿(?!ä¸è‰¯)|æ¯›ç‰ã‚±ã‚¢|ãƒ€ãƒ–ãƒ«ã‚³ãƒ¼ãƒˆ|æ›æ¯›æœŸ/,
                ç”¨é€”ç›®çš„: /å·®ã—å…¥ã‚Œ|ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆ|è´ˆã‚Šç‰©|ä¿è­·çŒ«|å¯„ä»˜|ã‚®ãƒ•ãƒˆ/,
                è¦‹ãŸç›®å½¢çŠ¶: /è‰²(?!ã€…)|è¦‹ãŸç›®|å½¢(?!æˆ)|å¤–è¦³(?!æ¢±åŒ…)|è³ªæ„Ÿ/
            };
            
            // ã€Œãã®ä»–ã€ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºæ™‚ã®ã‚¹ã‚³ã‚¢åŠ ç®—
            let hasOtherPattern = false;
            Object.entries(otherExclusivePatterns).forEach(([type, pattern]) => {
                if (lowerText.match(pattern)) {
                    scores['ãã®ä»–'] += 15 * weight;
                    hasOtherPattern = true;
                }
            });
            
            // ã€Œé£Ÿã¹ã‚‹ã€ã‚«ãƒ†ã‚´ãƒªã®å³æ ¼åŒ–
            if (hasOtherPattern) {
                // åŸææ–™ãƒ»æˆåˆ†ãƒ»å¥åº·æ”¹å–„ãªã©ã®è¨€åŠãŒã‚ã‚‹å ´åˆã¯ã€Œé£Ÿã¹ã‚‹ã€ã‚¹ã‚³ã‚¢ã‚’å¤§å¹…æ¸›ç‚¹
                const actualEatingPattern = /é£Ÿã¹[ã¦ã‚‹]|é£Ÿã„ä»˜|ãŒã£ã¤ã|å®Œé£Ÿ|å¹³ã‚‰ã’|ã‚€ã—ã‚ƒã‚€ã—ã‚ƒ|ãºã‚ã‚Š|å–œã‚“ã§é£Ÿã¹|ã‚ˆãé£Ÿã¹|ãŸãã•ã‚“é£Ÿã¹|ç¾å‘³ã—ãã†ã«/;
                if (!lowerText.match(actualEatingPattern)) {
                    scores['é£Ÿã¹ã‚‹'] -= 20 * weight;
                }
            }
            
            // éæ¶ˆåŒ–å™¨ç³»å¥åº·æ”¹å–„ã¯ã€Œåãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„ã€ã‹ã‚‰é™¤å¤–
            if (lowerText.match(otherExclusivePatterns.éæ¶ˆåŒ–å™¨ç³»å¥åº·)) {
                scores['åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„'] -= 15 * weight;
            }
            
            return scores;
        }

        // ğŸ¯ Phase 3ç”¨å¼·åŒ–ç‰ˆã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ 
        function calculateLabelScoresEnhanced(reviewText, context = null) {
            const scores = {
                'é£Ÿã¹ã‚‹': 0,
                'é£Ÿã¹ãªã„': 0,
                'åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„': 0,
                'åããƒ»ä¾¿ãŒæ‚ªããªã‚‹': 0,
                'å®‰ã„': 0,
                'é…é€ãƒ»æ¢±åŒ…': 0,
                'å€¤ä¸ŠãŒã‚Š/é«˜ã„': 0,
                'è³å‘³æœŸé™': 0,
                'ã‚¸ãƒƒãƒ‘ãƒ¼': 0,
                'ãã®ä»–': 0
            };
            
            // æ—©æœŸã€Œãã®ä»–ã€åˆ¤å®šã®ãŸã‚ã®äº‹å‰ãƒã‚§ãƒƒã‚¯
            const lowerText = reviewText.toLowerCase();
            const otherPatterns = {
                åŸææ–™æˆåˆ†: /åŸææ–™|æˆåˆ†|ææ–™|ä¸­èº«é‡è¦–|ç´ æ|æ·»åŠ ç‰©|ã‚°ãƒ¬ã‚¤ãƒ³ãƒ•ãƒªãƒ¼|ç©€ç‰©ä¸ä½¿ç”¨|ç„¡æ·»åŠ |ä¿å­˜æ–™|ç€è‰²æ–™|å¤©ç„¶ç´ æ/,
                éæ¶ˆåŒ–å™¨ç³»å¥åº·: /æ¯›ä¸¦ã¿|æ¯›è‰¶|æ¯›è³ª|ã‚¢ãƒ¬ãƒ«ã‚®ãƒ¼|çš®è†š|ç—’ã¿|ã‹ã‚†ã¿|ä½“èª¿(?!ä¸è‰¯)|æ¯›ç‰ã‚±ã‚¢|ãƒ€ãƒ–ãƒ«ã‚³ãƒ¼ãƒˆ|æ›æ¯›æœŸ/,
                ç”¨é€”ç›®çš„: /å·®ã—å…¥ã‚Œ|ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆ|è´ˆã‚Šç‰©|ä¿è­·çŒ«|å¯„ä»˜|ã‚®ãƒ•ãƒˆ/,
                è¦‹ãŸç›®å½¢çŠ¶: /è‰²(?!ã€…)|è¦‹ãŸç›®|å½¢(?!æˆ)|å¤–è¦³(?!æ¢±åŒ…)|è³ªæ„Ÿ/
            };
            
            let isLikelyOther = false;
            Object.values(otherPatterns).forEach(pattern => {
                if (lowerText.match(pattern)) {
                    isLikelyOther = true;
                }
            });
            
            // æ™‚ç³»åˆ—é‡ã¿ä»˜ã‘ã‚’ã‚ˆã‚Šç´°ã‹ãåˆ¶å¾¡
            const timeWeights = {
                pastNegative: 0.1,    // éå»ã®ãƒã‚¬ãƒ†ã‚£ãƒ–
                pastPositive: 0.3,    // éå»ã®ãƒã‚¸ãƒ†ã‚£ãƒ–  
                currentNegative: 2.0, // ç¾åœ¨ã®ãƒã‚¬ãƒ†ã‚£ãƒ–
                currentPositive: 3.0, // ç¾åœ¨ã®ãƒã‚¸ãƒ†ã‚£ãƒ–
                transition: 1.5       // è»¢æ›è¡¨ç¾
            };
            
            // æ–‡è„ˆåˆ†æçµæœã‚’è€ƒæ…®ã—ãŸã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°
            if (context && context.timelineDetected) {
                // ã‚ˆã‚Šè©³ç´°ãªé‡ã¿ä»˜ã‘ãƒ­ã‚¸ãƒƒã‚¯
                context.currentContext.forEach(ctx => {
                    // ãƒã‚¸ãƒ†ã‚£ãƒ–ãƒ»ãƒã‚¬ãƒ†ã‚£ãƒ–åˆ¤å®š
                    const isPositive = ctx.sentence.match(/è‰¯|ã„ã„|å¥½|æ°—ã«å…¥|æº€è¶³|å–œ|å®Œé£Ÿ|ç¾å‘³/);
                    const weight = isPositive ? timeWeights.currentPositive : timeWeights.currentNegative;
                    addScoresByKeywordsEnhanced(ctx.sentence, scores, weight);
                });
                
                context.pastContext.forEach(ctx => {
                    const isPositive = ctx.sentence.match(/è‰¯|ã„ã„|å¥½|æ°—ã«å…¥|æº€è¶³|å–œ|å®Œé£Ÿ|ç¾å‘³/);
                    const weight = isPositive ? timeWeights.pastPositive : timeWeights.pastNegative;
                    addScoresByKeywordsEnhanced(ctx.sentence, scores, weight);
                });
                
                // è»¢æ›è¡¨ç¾ãŒã‚ã‚‹å ´åˆã®å‡¦ç†
                if (context.hasTransition) {
                    const sentences = reviewText.split(/[ã€‚ï¼ï¼Ÿ\n]/).filter(s => s.trim());
                    sentences.forEach((sentence, index) => {
                        if (sentence.match(/(ã—ã‹ã—|ã¨ã“ã‚ãŒ|ã§ã‚‚|ã‘ã‚Œã©|ãŒã€|ãŸã )/)) {
                            addScoresByKeywordsEnhanced(sentence, scores, timeWeights.transition);
                        }
                    });
                }
                
                // æ®‹ã‚Šã®æ–‡ç« ã¯é€šå¸¸é‡ã¿
                const processedIndices = [
                    ...context.currentContext.map(c => c.index),
                    ...context.pastContext.map(c => c.index)
                ];
                
                const remainingSentences = reviewText.split(/[ã€‚ï¼ï¼Ÿ\n]/)
                    .filter((_, index) => !processedIndices.includes(index))
                    .join('ã€‚');
                    
                if (remainingSentences) {
                    addScoresByKeywordsEnhanced(remainingSentences, scores, 1.0);
                }
            } else {
                // é€šå¸¸ã®ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°
                addScoresByKeywordsEnhanced(reviewText, scores, 1.0);
            }
            
            return scores;
        }

        // ğŸ¯ éšå±¤çš„åˆ†é¡ã‚·ã‚¹ãƒ†ãƒ ï¼ˆå„ªå…ˆåº¦2å¯¾å¿œï¼‰
        function getTopScoringLabelHierarchical(scores) {
            const maxScore = Math.max(...Object.values(scores));
            const topLabels = Object.entries(scores)
                .filter(([_, score]) => score === maxScore)
                .map(([label, _]) => label);
            
            // éšå±¤çš„å„ªå…ˆé †ä½ï¼ˆé«˜ç²¾åº¦é †ãƒ»10ã‚«ãƒ†ã‚´ãƒªå¯¾å¿œï¼‰
            const hierarchicalPriority = [
                // ç¬¬1å±¤: æ˜ç¢ºãªå…·ä½“çš„ã‚«ãƒ†ã‚´ãƒªï¼ˆèª¤åˆ†é¡ãƒªã‚¹ã‚¯æœ€å°ï¼‰
                'è³å‘³æœŸé™', 'ã‚¸ãƒƒãƒ‘ãƒ¼', 'é…é€ãƒ»æ¢±åŒ…',
                
                // ç¬¬2å±¤: å¥åº·é–¢é€£ï¼ˆé‡è¦åº¦é«˜ï¼‰
                'åããƒ»ä¾¿ãŒæ‚ªããªã‚‹', 'åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„',
                
                // ç¬¬3å±¤: é£Ÿäº‹é–¢é€£ï¼ˆä¸»è¦ã‚«ãƒ†ã‚´ãƒªï¼‰
                'é£Ÿã¹ãªã„', 'é£Ÿã¹ã‚‹',
                
                // ç¬¬4å±¤: ä¾¡æ ¼é–¢é€£ï¼ˆéå‰°åˆ†é¡å¯¾ç­–æ¸ˆã¿ï¼‰
                'å€¤ä¸ŠãŒã‚Š/é«˜ã„', 'å®‰ã„',
                
                // ç¬¬5å±¤: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                'ãã®ä»–'
            ];
            
            return hierarchicalPriority.find(label => topLabels.includes(label)) || 'ãã®ä»–';
        }
        
        // éšå±¤çš„åˆ†é¡åˆ¤å®šã‚·ã‚¹ãƒ†ãƒ ï¼ˆã€Œãã®ä»–ã€å„ªå…ˆåˆ¤å®šå¼·åŒ–ç‰ˆï¼‰
        function classifyHierarchically(reviewText, scores) {
            const lowerText = reviewText.toLowerCase();
            
            // æ—©æœŸã€Œãã®ä»–ã€åˆ¤å®š
            const otherPatterns = {
                åŸææ–™æˆåˆ†: /åŸææ–™|æˆåˆ†|ææ–™|ä¸­èº«é‡è¦–|ç´ æ|æ·»åŠ ç‰©|ã‚°ãƒ¬ã‚¤ãƒ³ãƒ•ãƒªãƒ¼|ç©€ç‰©ä¸ä½¿ç”¨|ç„¡æ·»åŠ |ä¿å­˜æ–™|ç€è‰²æ–™|å¤©ç„¶ç´ æ/,
                éæ¶ˆåŒ–å™¨ç³»å¥åº·: /æ¯›ä¸¦ã¿|æ¯›è‰¶|æ¯›è³ª|ã‚¢ãƒ¬ãƒ«ã‚®ãƒ¼|çš®è†š|ç—’ã¿|ã‹ã‚†ã¿|ä½“èª¿(?!ä¸è‰¯)|æ¯›ç‰ã‚±ã‚¢|ãƒ€ãƒ–ãƒ«ã‚³ãƒ¼ãƒˆ|æ›æ¯›æœŸ/,
                ç”¨é€”ç›®çš„: /å·®ã—å…¥ã‚Œ|ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆ|è´ˆã‚Šç‰©|ä¿è­·çŒ«|å¯„ä»˜|ã‚®ãƒ•ãƒˆ/,
                è¦‹ãŸç›®å½¢çŠ¶: /è‰²(?!ã€…)|è¦‹ãŸç›®|å½¢(?!æˆ)|å¤–è¦³(?!æ¢±åŒ…)|è³ªæ„Ÿ/
            };
            
            // ã€Œãã®ä»–ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒæ¤œå‡ºã•ã‚Œã€ã‹ã¤ä»–ã®å¼·ã„ã‚·ã‚°ãƒŠãƒ«ãŒãªã„å ´åˆ
            let hasOtherPattern = false;
            Object.values(otherPatterns).forEach(pattern => {
                if (lowerText.match(pattern)) {
                    hasOtherPattern = true;
                }
            });
            
            if (hasOtherPattern) {
                // ä»–ã®ã‚«ãƒ†ã‚´ãƒªã®å¼·ã„ã‚·ã‚°ãƒŠãƒ«ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                const strongSignals = {
                    'é£Ÿã¹ã‚‹': /é£Ÿã¹[ã¦ã‚‹]|é£Ÿã„ä»˜|ãŒã£ã¤ã|å®Œé£Ÿ|å¹³ã‚‰ã’|ã‚€ã—ã‚ƒã‚€ã—ã‚ƒ|ãºã‚ã‚Š|å–œã‚“ã§é£Ÿã¹|ã‚ˆãé£Ÿã¹|ãŸãã•ã‚“é£Ÿã¹|ç¾å‘³ã—ãã†ã«/,
                    'é£Ÿã¹ãªã„': /å…¨ãé£Ÿã¹ãªã„|è¦‹å‘ãã‚‚ã—ãªã„|å®Œå…¨æ‹’å¦|ä¸€å£ã‚‚é£Ÿã¹/,
                    'åããƒ»ä¾¿ãŒæ‚ªããªã‚‹': /å[ãã„ãŸ]|ä¸‹ç—¢|è»Ÿä¾¿|è¡€ä¾¿/,
                    'åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„': /ä¾¿.{0,20}(è‰¯[ãã„]ãª[ã£ãŸã‚Š]|æ”¹å–„|å¿«èª¿)|å.{0,20}(æ¸›[ã£ãŸã‚Š]|ãªããª[ã£ãŸã‚Š]|æ”¹å–„)/
                };
                
                let hasStrongSignal = false;
                Object.entries(strongSignals).forEach(([category, pattern]) => {
                    if (lowerText.match(pattern) && scores[category] >= 15) {
                        hasStrongSignal = true;
                    }
                });
                
                if (!hasStrongSignal) {
                    return 'ãã®ä»–';
                }
            }
            
            // ç¬¬1æ®µéš: æ˜ç¢ºãªåˆ¤å®šï¼ˆé«˜ä¿¡é ¼åº¦ï¼‰
            if (scores['è³å‘³æœŸé™'] >= 6) return 'è³å‘³æœŸé™';
            if (scores['ã‚¸ãƒƒãƒ‘ãƒ¼'] >= 6) return 'ã‚¸ãƒƒãƒ‘ãƒ¼';
            if (scores['é…é€ãƒ»æ¢±åŒ…'] >= 8) return 'é…é€ãƒ»æ¢±åŒ…';
            
            // ç¬¬2æ®µéš: å¥åº·é–¢é€£ï¼ˆä¸­ï½é«˜ä¿¡é ¼åº¦ï¼‰
            if (scores['åããƒ»ä¾¿ãŒæ‚ªããªã‚‹'] >= 8) return 'åããƒ»ä¾¿ãŒæ‚ªããªã‚‹';
            if (scores['åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„'] >= 8) return 'åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„';
            
            // ç¬¬3æ®µéš: é£Ÿäº‹é–¢é€£ï¼ˆã‚¹ã‚³ã‚¢é‡è¦–ãƒ»å¼·åŒ–ç‰ˆï¼‰
            if (scores['é£Ÿã¹ãªã„'] >= 10) return 'é£Ÿã¹ãªã„';
            if (scores['é£Ÿã¹ã‚‹'] >= 10) return 'é£Ÿã¹ã‚‹';
            if (scores['é£Ÿã¹ãªã„'] >= 8) return 'é£Ÿã¹ãªã„';
            if (scores['é£Ÿã¹ã‚‹'] >= 8) return 'é£Ÿã¹ã‚‹';
            
            // ç¬¬4æ®µéš: ä¾¡æ ¼é–¢é€£ï¼ˆå³æ ¼åˆ¤å®šï¼‰
            if (scores['å€¤ä¸ŠãŒã‚Š/é«˜ã„'] >= 10) return 'å€¤ä¸ŠãŒã‚Š/é«˜ã„';
            if (scores['å®‰ã„'] >= 10) return 'å®‰ã„';
            
            // ç¬¬5æ®µéš: ç©æ¥µçš„åˆ†é¡ï¼ˆé–¾å€¤ã‚’å¤§å¹…ã«ä¸‹ã’ã‚‹ï¼‰
            const maxScore = Math.max(...Object.values(scores));
            if (maxScore >= 6) {
                return getTopScoringLabelHierarchical(scores);
            }
            if (maxScore >= 4) {
                return getTopScoringLabelHierarchical(scores);
            }
            if (maxScore >= 2) {
                return getTopScoringLabelHierarchical(scores);
            }
            
            return 'ãã®ä»–';
        }

        // ğŸ¤– OpenAI APIçµ±åˆ: æ–°ã—ã„å®Œå…¨ç‰ˆãƒ©ãƒ™ãƒ«æ¤œå‡º
        async function detectLabelsFromConfigV2(reviewText) {
            if (!reviewText) return 'ãã®ä»–';
            
            // OpenAI APIã‚’ä½¿ç”¨ã—ãŸåˆ†é¡
            return await detectLabels(reviewText);
        }

        // ğŸ¯ æ–°æ©Ÿèƒ½: ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°é–¢æ•°ï¼ˆPhase 2ç”¨ï¼‰
        function addScoresByKeywords(text, scores, weight = 1.0) {
            const lowerText = text.toLowerCase();
            
            // é£Ÿã¹ã‚‹é–¢é€£
            const eatPatterns = {
                strong: [
                    /å–œã‚“ã§.{0,20}(å®Œé£Ÿ|é£Ÿã¹)/,
                    /é£›ã³ä»˜ã„ã¦.{0,20}é£Ÿã¹/,
                    /(ãƒã‚¯ãƒã‚¯|ãŒã£ã¤[ãã]).{0,10}é£Ÿã¹/,
                    /ç¾å‘³ã—ãã†.{0,10}é£Ÿã¹/
                ],
                medium: [
                    /å®Œé£Ÿ/, /ã‚ˆãé£Ÿã¹/, /ç¾å‘³ã—ã„/, /ãŠã„ã—ã„/,
                    /æ°—ã«å…¥[ã£ã‚Š]/, /å¤§å¥½ã/, /ãŠæ°—ã«å…¥ã‚Š/
                ]
            };
            
            eatPatterns.strong.forEach(pattern => {
                if (lowerText.match(pattern)) scores['é£Ÿã¹ã‚‹'] += 10 * weight;
            });
            eatPatterns.medium.forEach(pattern => {
                if (lowerText.match(pattern)) scores['é£Ÿã¹ã‚‹'] += 5 * weight;
            });
            
            // é£Ÿã¹ãªã„é–¢é€£
            const noEatPatterns = {
                strong: [
                    /å…¨ãé£Ÿã¹ãªã„/, /è¦‹å‘ãã‚‚ã—ãªã„/, /æ‹’å¦.{0,10}ã™ã‚‹/
                ],
                medium: [
                    /é£Ÿã¹(ã¦)?ãã‚Œãª[ã„ã‹]/, /æ®‹ã—ã¦/, /å£ã«ã—ãª[ã„ã‹]/
                ],
                exclusions: [
                    /(ä»Šã¾ã§|ä»¥å‰|ã“ã‚Œã¾ã§).{0,50}é£Ÿã¹.*ãª[ã„ã‹]/  // éå»ã®è©±ã¯é™¤å¤–
                ]
            };
            
            // é™¤å¤–ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒã‚§ãƒƒã‚¯
            const hasExclusion = noEatPatterns.exclusions.some(pattern => 
                lowerText.match(pattern));
            
            if (!hasExclusion) {
                noEatPatterns.strong.forEach(pattern => {
                    if (lowerText.match(pattern)) scores['é£Ÿã¹ãªã„'] += 10 * weight;
                });
                noEatPatterns.medium.forEach(pattern => {
                    if (lowerText.match(pattern)) scores['é£Ÿã¹ãªã„'] += 5 * weight;
                });
            }
            
            // å¥åº·é–¢é€£ï¼ˆæ”¹å–„ï¼‰
            if (lowerText.match(/(å|å˜”å).{0,20}(æ¸›[ã£ãŸã‚Š]|ãªããª[ã£ãŸã‚Š]|æ”¹å–„)/)) {
                scores['åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„'] += 8 * weight;
            }
            if (lowerText.match(/ä¾¿.{0,20}(è‰¯[ãã„]ãª[ã£ãŸã‚Š]|æ”¹å–„|å¿«èª¿)/)) {
                scores['åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„'] += 8 * weight;
            }
            
            // å¥åº·é–¢é€£ï¼ˆæ‚ªåŒ–ï¼‰
            if (lowerText.match(/å[ãã„ãŸ]|ä¸‹ç—¢|è»Ÿä¾¿|è¡€ä¾¿/) && 
                !lowerText.match(/(æ¸›[ã£ãŸã‚Š]|æ”¹å–„|è‰¯ããª)/)) {
                scores['åããƒ»ä¾¿ãŒæ‚ªããªã‚‹'] += 8 * weight;
            }
            
            // é…é€ãƒ»æ¢±åŒ…é–¢é€£
            if (lowerText.match(/é…é€|æ¢±åŒ…|ç™ºé€|å±Š[ãã„ãã‘]|ç®±|åŒ…è£…|é…é”/)) {
                scores['é…é€ãƒ»æ¢±åŒ…'] += 8 * weight;
            }
            
            // ä¾¡æ ¼é–¢é€£
            if (lowerText.match(/å€¤ä¸Š[ã’ãŒã‚Š]|é«˜[ã„ãã‚]|ãŸã‹[ã„ãã‚]|é«˜ä¾¡/)) {
                scores['å€¤ä¸ŠãŒã‚Š/é«˜ã„'] += 8 * weight;
            }
            if (lowerText.match(/å®‰[ã„ãã‚]|ã‚„ã™[ã„ãã‚]|ãŠå¾—|ã‚³ã‚¹ãƒ‘|æ‰‹é ƒ/)) {
                scores['å®‰ã„'] += 8 * weight;
            }
            
            // è³å‘³æœŸé™é–¢é€£
            if (lowerText.match(/è³å‘³æœŸé™|æ¶ˆè²»æœŸé™|æœŸé™|æ—¥ä»˜/)) {
                scores['è³å‘³æœŸé™'] += 8 * weight;
            }
            
            // ã‚¸ãƒƒãƒ‘ãƒ¼é–¢é€£
            if (lowerText.match(/ã‚¸ãƒƒãƒ‘ãƒ¼|ãƒãƒ£ãƒƒã‚¯|å¯†å°|ã‚¸ãƒƒãƒ—|ä¿å­˜.{0,10}(ä¸ä¾¿|å›°)/)) {
                scores['ã‚¸ãƒƒãƒ‘ãƒ¼'] += 8 * weight;
            }
            
            return scores;
        }

        // ğŸ¯ æ–°æ©Ÿèƒ½: ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ 
        function calculateLabelScores(reviewText, context = null) {
            const scores = {
                'é£Ÿã¹ã‚‹': 0,
                'é£Ÿã¹ãªã„': 0,
                'åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„': 0,
                'åããƒ»ä¾¿ãŒæ‚ªããªã‚‹': 0,
                'å®‰ã„': 0,
                'é…é€ãƒ»æ¢±åŒ…': 0,
                'å€¤ä¸ŠãŒã‚Š/é«˜ã„': 0,
                'è³å‘³æœŸé™': 0,
                'ã‚¸ãƒƒãƒ‘ãƒ¼': 0,
                'ãã®ä»–': 0
            };
            
            // æ–‡è„ˆåˆ†æçµæœã‚’è€ƒæ…®ã—ãŸã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°
            if (context && context.timelineDetected) {
                // ç¾åœ¨ã®å•†å“ã«é–¢ã™ã‚‹å†…å®¹ã‚’é«˜ãè©•ä¾¡ï¼ˆé‡ã¿ 3.0ï¼‰
                context.currentContext.forEach(ctx => {
                    addScoresByKeywords(ctx.sentence, scores, 3.0);
                });
                
                // éå»ã®è©±ã¯ä½ãè©•ä¾¡ï¼ˆé‡ã¿ 0.3ï¼‰
                context.pastContext.forEach(ctx => {
                    addScoresByKeywords(ctx.sentence, scores, 0.3);
                });
                
                // æ®‹ã‚Šã®æ–‡ç« ã¯é€šå¸¸é‡ã¿ï¼ˆé‡ã¿ 1.0ï¼‰
                const processedIndices = [
                    ...context.currentContext.map(c => c.index),
                    ...context.pastContext.map(c => c.index)
                ];
                
                const remainingSentences = reviewText.split(/[ã€‚ï¼ï¼Ÿ\n]/)
                    .filter((_, index) => !processedIndices.includes(index))
                    .join('ã€‚');
                    
                if (remainingSentences) {
                    addScoresByKeywords(remainingSentences, scores, 1.0);
                }
            } else {
                // é€šå¸¸ã®ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°
                addScoresByKeywords(reviewText, scores, 1.0);
            }
            
            return scores;
        }

        // ğŸ¯ æ–°æ©Ÿèƒ½: ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ã‚·ã‚¹ãƒ†ãƒ ï¼ˆPhase 2å®Ÿè£…ï¼‰
        function detectLabelsHybrid(reviewText) {
            if (!reviewText) return 'ãã®ä»–';
            
            // Step 1: æ˜ç¢ºãªã‚«ãƒ†ã‚´ãƒªã‚’ã¾ãšåˆ¤å®šï¼ˆå„ªå…ˆåº¦é †ï¼‰
            const explicitCategories = detectLabels(reviewText);
            
            // Step 2: ã€Œãã®ä»–ã€ä»¥å¤–ãªã‚‰å¾“æ¥ç‰ˆã®çµæœã‚’æ¡ç”¨
            if (explicitCategories !== 'ãã®ä»–') {
                return explicitCategories;
            }
            
            // Step 3: æ–‡è„ˆåˆ†æã‚’æ´»ç”¨ã—ãŸã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°
            const context = analyzeReviewContext(reviewText);
            const scores = calculateLabelScores(reviewText, context);
            
            // Step 4: ä¸€å®šã‚¹ã‚³ã‚¢ä»¥ä¸Šãªã‚‰æœ€é«˜ã‚¹ã‚³ã‚¢ã®ãƒ©ãƒ™ãƒ«ã‚’æ¡ç”¨
            const maxScore = Math.max(...Object.values(scores));
            if (maxScore >= 3) {  // é–¾å€¤ã‚’3ã«è¨­å®š
                const topLabels = Object.entries(scores)
                    .filter(([_, score]) => score === maxScore);
                return topLabels[0][0];
            }
            
            // Step 5: ãã‚Œã§ã‚‚åˆ¤å®šã§ããªã„å ´åˆã®ã¿ã€Œãã®ä»–ã€
            return 'ãã®ä»–';
        }

        // ğŸ¯ æ–°æ©Ÿèƒ½: æ”¹è‰¯ç‰ˆãƒ©ãƒ™ãƒ«æ¤œå‡º
        function detectLabelsEnhanced(reviewText, context) {
            const scores = calculateLabelScores(reviewText, context);
            
            // æœ€é«˜ã‚¹ã‚³ã‚¢ã®ãƒ©ãƒ™ãƒ«ã‚’é¸æŠ
            const maxScore = Math.max(...Object.values(scores));
            
            if (maxScore === 0) return 'ãã®ä»–';
            
            const topLabels = Object.entries(scores)
                .filter(([_, score]) => score === maxScore)
                .map(([label, _]) => label);
            
            // åŒç‚¹ã®å ´åˆã®å„ªå…ˆé †ä½
            const priority = [
                'é…é€ãƒ»æ¢±åŒ…', 'è³å‘³æœŸé™', 'ã‚¸ãƒƒãƒ‘ãƒ¼',  // æ˜ç¢ºãªå¯¾è±¡ãŒã‚ã‚‹ã‚‚ã®ã‚’å„ªå…ˆ
                'åããƒ»ä¾¿ãŒæ‚ªããªã‚‹', 'åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„',  // å¥åº·é–¢é€£
                'é£Ÿã¹ãªã„', 'é£Ÿã¹ã‚‹',  // é£Ÿã„ã¤ãé–¢é€£
                'å€¤ä¸ŠãŒã‚Š/é«˜ã„', 'å®‰ã„',  // ä¾¡æ ¼é–¢é€£
                'ãã®ä»–'
            ];
            
            return priority.find(label => topLabels.includes(label)) || 'ãã®ä»–';
        }

        // ğŸ¯ é«˜ç²¾åº¦åŒ–: ãƒ¡ã‚¤ãƒ³é–¢æ•°ã®æ›´æ–°
        function detectLabelsFromConfig(reviewText) {
            if (!reviewText) return 'ãã®ä»–';
            
            // æ–‡è„ˆåˆ†æ
            const context = analyzeReviewContext(reviewText);
            
            // ã‚«ã‚¹ã‚¿ãƒ è¨­å®šãŒã‚ã‚‹å ´åˆ
            if (labelConfig.length > 0) {
                const scores = calculateLabelScores(reviewText, context);
                
                // ã‚«ã‚¹ã‚¿ãƒ ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ï¼ˆå„ªå…ˆåº¦è€ƒæ…®ï¼‰
                for (const config of labelConfig) {
                    if (config.patterns.length === 0) continue;
                    
                    let patternScore = 0;
                    const text = String(reviewText).toLowerCase();
                    
                    for (const pattern of config.patterns) {
                        try {
                            if (text.match(new RegExp(pattern, 'i'))) {
                                patternScore += 5;
                            }
                        } catch (e) {
                            console.warn(`ç„¡åŠ¹ãªæ­£è¦è¡¨ç¾: ${pattern}`, e);
                        }
                    }
                    
                    // ã‚¹ã‚³ã‚¢ã¨ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã‚’çµ„ã¿åˆã‚ã›ã¦åˆ¤å®š
                    if (patternScore > 0 && scores[config.name] >= 3) {
                        return config.name;
                    }
                }
            }
            
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆåˆ¤å®šï¼ˆæ”¹è‰¯ç‰ˆï¼‰
            return detectLabelsEnhanced(reviewText, context);
        }

        // ğŸ¤– OpenAI APIçµ±åˆ: æ–°ã—ã„åˆ†é¡é–¢æ•°ï¼ˆã‚«ã‚¹ã‚¿ãƒ ã‚«ãƒ†ã‚´ãƒªå¯¾å¿œï¼‰
        async function detectLabels(reviewText) {
            if (!reviewText) return 'ãã®ä»–';
            
            try {
                // UIã‹ã‚‰ã‚«ãƒ†ã‚´ãƒªã®ã¿å–å¾—
                const categoryInput = document.getElementById('categoryInput');
                const customCategories = categoryInput.value.trim().split('\n').filter(cat => cat.trim());
                
                const response = await fetch('/api/classify', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        review: reviewText,
                        type: 'classification',
                        categories: customCategories // ã‚«ã‚¹ã‚¿ãƒ ã‚«ãƒ†ã‚´ãƒªã®ã¿é€ä¿¡
                    })
                });

                if (!response.ok) {
                    console.error('API error:', await response.text());
                    return 'ãã®ä»–';
                }

                const data = await response.json();
                return data.category || 'ãã®ä»–';
            } catch (error) {
                console.error('Classification error:', error);
                return 'ãã®ä»–';
            }
        }

        // ğŸ¤– OpenAI APIçµ±åˆ: æ–°ã—ã„ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆåˆ†æé–¢æ•°
        async function analyzeSentimentOpenAI(reviewText) {
            if (!reviewText) return { label: 'Neutral', score: 0, reason: 'ç©ºã®ãƒ†ã‚­ã‚¹ãƒˆ' };
            
            try {
                const response = await fetch('/api/classify', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        review: reviewText,
                        type: 'sentiment'
                    })
                });

                if (!response.ok) {
                    console.error('Sentiment API error:', await response.text());
                    return { label: 'Neutral', score: 0, reason: 'API ã‚¨ãƒ©ãƒ¼' };
                }

                const data = await response.json();
                return {
                    label: data.sentiment || 'Neutral',
                    score: data.score || 0,
                    reason: data.reason || 'åˆ†æå®Œäº†'
                };
            } catch (error) {
                console.error('Sentiment analysis error:', error);
                return { label: 'Neutral', score: 0, reason: 'ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ' };
            }
        }

        function analyzeSentiment(reviewText) {
            if (!reviewText) {
                return {
                    label: 'ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«',
                    score: 50,
                    reason: 'ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ†ã‚­ã‚¹ãƒˆãŒç©ºã®ãŸã‚åˆ¤å®šä¸å¯'
                };
            }
            
            const text = String(reviewText);
            let score = 50;
            const reasons = [];
            
            if (text.match(/é£Ÿã¹[ã‚‹ã¦ãŸã‚Š](?!ãª)|ç¾å‘³[ã—ã]|ãŠã„ã—|å–œã‚“ã§|ãƒã‚¯ãƒã‚¯|å®Œé£Ÿ|ã‚ˆãé£Ÿã¹|å¤§å¥½ã/)) {
                score += 15;
                reasons.push('é£Ÿã„ã¤ããŒè‰¯ã„');
            }
            if (text.match(/æº€è¶³|è‰¯[ã„ãã‹ã‘](?!ãª)|æ°—ã«å…¥|ãŠæ°—ã«å…¥ã‚Š|ãƒªãƒ”ãƒ¼ãƒˆ|ã¾ãŸè²·|å®šç•ª|ãšã£ã¨/)) {
                score += 10;
                reasons.push('æº€è¶³åº¦ãŒé«˜ã„');
            }
            if (text.match(/(å|å˜”å).{0,20}(æ¸›|ãªããªã£ãŸ|æ”¹å–„)|ä¾¿.{0,20}è‰¯|å¥åº·|å…ƒæ°—|èª¿å­.{0,5}è‰¯/)) {
                score += 15;
                reasons.push('å¥åº·é¢ã§ã®æ”¹å–„');
            }
            if (text.match(/å®‰[ã„ãã‚]|ã‚„ã™[ã„ãã‚]|ãŠå¾—|ã‚³ã‚¹ãƒ‘|æ‰‹é ƒ/)) {
                score += 10;
                reasons.push('ä¾¡æ ¼æº€è¶³åº¦ãŒé«˜ã„');
            }
            if (text.match(/æ¯›ä¸¦ã¿.{0,10}(è‰¯|ç¶ºéº—|ãƒ„ãƒ¤|ã‚µãƒ©ã‚µãƒ©)|æ¯›è‰¶|æ¯›.{0,5}ãƒ„ãƒ¤ãƒ„ãƒ¤/)) {
                score += 10;
                reasons.push('æ¯›ä¸¦ã¿ã®æ”¹å–„');
            }
            
            if (text.match(/é£Ÿã¹(ã¦ãã‚Œ)?ãª[ã„ã‹ãã‘]|æ‹’å¦|æ®‹[ã™ã—]/)) {
                score -= 20;
                reasons.push('é£Ÿã„ã¤ããŒæ‚ªã„');
            }
            if (text.match(/å[ãã„ãŸã‘]|å˜”å|ä¸‹ç—¢|è»Ÿä¾¿|ä¾¿.{0,5}æ‚ª/) && !text.match(/(æ¸›|ãªããªã£ãŸ|æ”¹å–„)/)) {
                score -= 15;
                reasons.push('ä½“èª¿ä¸è‰¯ã®ç™ºç”Ÿ');
            }
            if (text.match(/é«˜[ã„ãã‚]|ãŸã‹[ã„ãã‚]|å€¤ä¸Š[ã’ãŒã‚Š]/)) {
                score -= 10;
                reasons.push('ä¾¡æ ¼ã¸ã®ä¸æº€');
            }
            if (text.match(/æ®‹å¿µ|ãŒã£ã‹ã‚Š|æœŸå¾…ã¯ãšã‚Œ|ãƒ€ãƒ¡|æœ€æ‚ª|äºŒåº¦ã¨|ã‚‚ã†è²·ã‚ãªã„/)) {
                score -= 15;
                reasons.push('æœŸå¾…ã¨ã®ä¹–é›¢');
            }
            
            score = Math.max(0, Math.min(100, score));
            
            let label = 'ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«';
            if (score >= 70) label = 'ãƒã‚¸ãƒ†ã‚£ãƒ–';
            else if (score <= 30) label = 'ãƒã‚¬ãƒ†ã‚£ãƒ–';
            
            let reason = '';
            if (reasons.length > 0) {
                reason = reasons.join('ã€') + 'ãŸã‚ã€‚';
            } else {
                reason = 'ç‰¹å®šã®è©•ä¾¡è¦ç´ ãŒè¦‹å½“ãŸã‚‰ãªã„ãŸã‚ä¸­ç«‹çš„ã¨åˆ¤å®šã€‚';
            }
            
            return {
                label: label,
                score: score,
                reason: reason
            };
        }

        function generateAndShowSentimentSummary() {
            const positive = sentimentDataList.filter(s => s.label === 'ãƒã‚¸ãƒ†ã‚£ãƒ–').length;
            const negative = sentimentDataList.filter(s => s.label === 'ãƒã‚¬ãƒ†ã‚£ãƒ–').length;
            const neutral = sentimentDataList.filter(s => s.label === 'ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«').length;
            const total = sentimentDataList.length;
            
            let summaryHTML = `
                <p><strong>ç·ãƒ¬ãƒ“ãƒ¥ãƒ¼æ•°:</strong> ${total}ä»¶</p>
                <p><strong>ãƒã‚¸ãƒ†ã‚£ãƒ–:</strong> ${positive}ä»¶ (${(positive/total*100).toFixed(1)}%)</p>
                <p><strong>ãƒã‚¬ãƒ†ã‚£ãƒ–:</strong> ${negative}ä»¶ (${(negative/total*100).toFixed(1)}%)</p>
                <p><strong>ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«:</strong> ${neutral}ä»¶ (${(neutral/total*100).toFixed(1)}%)</p>
                <h4>ä¸»ãªå‚¾å‘:</h4>
                <ul>
            `;
            
            if (positive > negative * 2) {
                summaryHTML += '<li>å…¨ä½“çš„ã«å¥½è©•ä¾¡ãŒå¤šãã€è£½å“ã«å¯¾ã™ã‚‹æº€è¶³åº¦ãŒé«˜ã„å‚¾å‘ã«ã‚ã‚Šã¾ã™ã€‚</li>';
            }
            if (negative > positive * 2) {
                summaryHTML += '<li>æ”¹å–„ãŒå¿…è¦ãªç‚¹ãŒå¤šãè¦‹å—ã‘ã‚‰ã‚Œã¾ã™ã€‚</li>';
            }
            if (Math.abs(positive - negative) < total * 0.1) {
                summaryHTML += '<li>è©•ä¾¡ãŒåˆ†ã‹ã‚Œã¦ãŠã‚Šã€å€‹ä½“å·®ã‚„å¥½ã¿ã®é•ã„ãŒå¤§ãã„ã‚ˆã†ã§ã™ã€‚</li>';
            }
            
            const positiveReasons = {};
            sentimentDataList.filter(s => s.label === 'ãƒã‚¸ãƒ†ã‚£ãƒ–').forEach(s => {
                if (s.reason.includes('é£Ÿã„ã¤ããŒè‰¯ã„')) positiveReasons['é£Ÿã„ã¤ã'] = (positiveReasons['é£Ÿã„ã¤ã'] || 0) + 1;
                if (s.reason.includes('å¥åº·é¢ã§ã®æ”¹å–„')) positiveReasons['å¥åº·æ”¹å–„'] = (positiveReasons['å¥åº·æ”¹å–„'] || 0) + 1;
                if (s.reason.includes('ä¾¡æ ¼æº€è¶³åº¦')) positiveReasons['ä¾¡æ ¼'] = (positiveReasons['ä¾¡æ ¼'] || 0) + 1;
            });
            
            if (Object.keys(positiveReasons).length > 0) {
                summaryHTML += '<li>ãƒã‚¸ãƒ†ã‚£ãƒ–è©•ä¾¡ã®ä¸»ãªè¦å› ï¼š';
                const topReasons = Object.entries(positiveReasons).sort((a, b) => b[1] - a[1]).slice(0, 3);
                summaryHTML += topReasons.map(([reason, count]) => `${reason}(${count}ä»¶)`).join('ã€');
                summaryHTML += '</li>';
            }
            
            summaryHTML += '</ul>';
            
            document.getElementById('sentimentContent').innerHTML = summaryHTML;
            document.getElementById('sentimentSummary').style.display = 'block';
        }

        // A/Bãƒ†ã‚¹ãƒˆç”¨ãƒ‡ãƒ¼ã‚¿ä¿å­˜
        let abTestResults = {
            traditional: [],
            enhanced: []
        };
        
        // ãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ¡ã‚¤ãƒ³é–¢æ•° - Phase 4å®Œå…¨ç‰ˆã‚’é©ç”¨
        async function processData() {
            const statusDiv = document.getElementById('status');
            const processBtn = document.getElementById('processBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            const visualizeBtn = document.getElementById('visualizeBtn');
            const abTestEnabled = document.getElementById('enableAbTest').checked;
            
            try {
                processBtn.disabled = true;
                statusDiv.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...';
                
                const rawReviewFile = Object.values(uploadedFiles).find(file => 
                    file.name.toLowerCase().includes('raw_review') || file.name.toLowerCase().includes('review')
                );
                
                if (!rawReviewFile) {
                    throw new Error('ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                }
                
                const rawWorkbook = XLSX.read(rawReviewFile.data);
                const rawSheet = rawWorkbook.Sheets[rawWorkbook.SheetNames[0]];
                rawData = XLSX.utils.sheet_to_json(rawSheet, { header: 1 });
                
                statusDiv.textContent = `ãƒ‡ãƒ¼ã‚¿ã‚’å‡¦ç†ä¸­... (ç·è¡Œæ•°: ${rawData.length - 1})`;
                
                console.log('ãƒ˜ãƒƒãƒ€ãƒ¼:', rawData[0]);
                console.log('1è¡Œç›®ãƒ‡ãƒ¼ã‚¿:', rawData[1]);
                console.log('2è¡Œç›®ãƒ‡ãƒ¼ã‚¿:', rawData[2]);
                
                let headers = [...rawData[0], 'ãƒ©ãƒ™ãƒ«', 'å¹´', 'æœˆ', 'å¹´æœˆ', 'ã‚¯ã‚©ãƒ¼ã‚¿ãƒ¼', 'ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆï¼ˆãƒ©ãƒ™ãƒ«ï¼‰', 'ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆï¼ˆã‚¹ã‚³ã‚¢ï¼‰', 'ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆï¼ˆç†ç”±ï¼‰'];
                if (abTestEnabled) {
                    headers.push('Tåˆ—_å¾“æ¥ç‰ˆãƒ©ãƒ™ãƒ«', 'Uåˆ—_æ¯”è¼ƒçµæœ');
                }
                processedData = [headers];
                
                sentimentDataList = [];
                abTestResults = { traditional: [], enhanced: [] };
                
                const batchSize = 100;
                const totalRows = rawData.length - 1;
                
                for (let i = 1; i < rawData.length; i++) {
                    const row = rawData[i];
                    
                    const reviewDate = row[1];
                    const reviewText = row[10];
                    
                    if (i <= 5) {
                        console.log(`${i}è¡Œç›® - æ—¥ä»˜:`, reviewDate, 'ãƒ¬ãƒ“ãƒ¥ãƒ¼:', reviewText?.substring(0, 50));
                    }
                    
                    const dateInfo = parseDate(reviewDate);
                    
                    // ğŸ¤– OpenAI APIçµ±åˆ: æ–°ã—ã„ã‚·ã‚¹ãƒ†ãƒ é©ç”¨
                    const enhancedLabels = await detectLabelsFromConfigV2(reviewText);
                    const sentimentData = await analyzeSentimentOpenAI(reviewText);
                    
                    // Påˆ—ï¼šã‚¯ã‚©ãƒ¼ã‚¿ãƒ¼, Qåˆ—ï¼šã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆï¼ˆãƒ©ãƒ™ãƒ«ï¼‰, Råˆ—ï¼šã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆï¼ˆã‚¹ã‚³ã‚¢ï¼‰, Såˆ—ï¼šã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆï¼ˆç†ç”±ï¼‰
                    let newRow = [...row, enhancedLabels, dateInfo.year, dateInfo.month, dateInfo.yearMonth, dateInfo.quarter, sentimentData.label, sentimentData.score, sentimentData.reason];
                    
                    // A/Bãƒ†ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ (ç¾åœ¨ã¯ç„¡åŠ¹)
                    if (abTestEnabled) {
                        const traditionalLabels = 'OpenAIçµ±åˆã«ã‚ˆã‚Šç„¡åŠ¹';
                        const comparisonResult = 'OpenAIçµ±åˆã«ã‚ˆã‚Šç„¡åŠ¹';
                        
                        newRow.push(traditionalLabels, comparisonResult);
                        
                        abTestResults.traditional.push(traditionalLabels);
                        abTestResults.enhanced.push(enhancedLabels);
                    }
                    
                    processedData.push(newRow);
                    sentimentDataList.push(sentimentData);
                    
                    if (i % batchSize === 0) {
                        statusDiv.textContent = `å‡¦ç†ä¸­... ${i}/${totalRows} (${Math.round(i/totalRows*100)}%)`;
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                }
                
                let statusMessage = `å‡¦ç†å®Œäº†ï¼Phase 5.2: æ•™å¸«ãƒ‡ãƒ¼ã‚¿æº–æ‹ ç‰ˆ+éå‰°åˆ†é¡ãƒ»æ¤œå‡ºä¸è¶³ä¿®æ­£æ¸ˆã¿`;
                if (abTestEnabled) {
                    statusMessage += ` | A/Bãƒ†ã‚¹ãƒˆå®Ÿè¡Œæ¸ˆã¿`;
                }
                statusDiv.innerHTML = `<span class="success">${statusMessage}</span>`;
                
                downloadBtn.disabled = false;
                visualizeBtn.disabled = false;
                
                // åˆ†æãƒ‡ãƒ¼ã‚¿ã®æº–å‚™
                prepareAnalysisData();
                
                showStatistics();
                generateAndShowSentimentSummary();
                showSampleResults();
                
                // A/Bãƒ†ã‚¹ãƒˆçµæœè¡¨ç¤º
                if (abTestEnabled) {
                    showAbTestResults();
                }
                
            } catch (error) {
                statusDiv.innerHTML = `<span class="error">ã‚¨ãƒ©ãƒ¼: ${error.message}</span>`;
                processBtn.disabled = false;
            }
        }
        
        // A/Bãƒ†ã‚¹ãƒˆçµæœè¡¨ç¤º
        function showAbTestResults() {
            const sampleDiv = document.getElementById('sampleResults');
            let html = '<h3>ğŸ§ª A/Bãƒ†ã‚¹ãƒˆçµæœ</h3>';
            
            // ä¸€è‡´ç‡è¨ˆç®—
            const total = abTestResults.traditional.length;
            const matches = abTestResults.traditional.filter((trad, i) => 
                trad === abTestResults.enhanced[i]
            ).length;
            const matchRate = ((matches / total) * 100).toFixed(1);
            
            html += `<p><strong>ä¸€è‡´ç‡:</strong> ${matchRate}% (${matches}/${total})</p>`;
            
            // ã‚«ãƒ†ã‚´ãƒªåˆ¥æ¯”è¼ƒ
            const categoryComparison = {};
            abTestResults.traditional.forEach((trad, i) => {
                const enh = abTestResults.enhanced[i];
                const key = `${trad} â†’ ${enh}`;
                categoryComparison[key] = (categoryComparison[key] || 0) + 1;
            });
            
            html += '<p><strong>ä¸»ãªå¤‰æ›´ãƒ‘ã‚¿ãƒ¼ãƒ³:</strong></p><ul>';
            Object.entries(categoryComparison)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .forEach(([pattern, count]) => {
                    if (!pattern.includes(' â†’ ')) return;
                    const [from, to] = pattern.split(' â†’ ');
                    if (from !== to) {
                        html += `<li>${pattern}: ${count}ä»¶</li>`;
                    }
                });
            html += '</ul>';
            
            sampleDiv.innerHTML = html + sampleDiv.innerHTML;
        }

        // æ–°æ©Ÿèƒ½: åˆ†æãƒ‡ãƒ¼ã‚¿ã®æº–å‚™
        function prepareAnalysisData() {
            analysisData = {
                monthlyData: {},
                labelData: {},
                sentimentData: {},
                quarterlyData: {},
                heatmapData: {}
            };

            const allLabels = new Set();
            const allMonths = new Set();

            for (let i = 1; i < processedData.length; i++) {
                const row = processedData[i];
                const yearMonth = row[14]; // Oåˆ—
                const label = row[11]; // Låˆ—
                const quarter = row[16]; // Qåˆ—
                const sentimentText = row[15]; // Påˆ—

                if (yearMonth && label) {
                    allMonths.add(yearMonth);
                    allLabels.add(label);

                    // æœˆåˆ¥ãƒ‡ãƒ¼ã‚¿
                    if (!analysisData.monthlyData[yearMonth]) {
                        analysisData.monthlyData[yearMonth] = {};
                    }
                    if (!analysisData.monthlyData[yearMonth][label]) {
                        analysisData.monthlyData[yearMonth][label] = 0;
                    }
                    analysisData.monthlyData[yearMonth][label]++;

                    // ãƒ©ãƒ™ãƒ«åˆè¨ˆ
                    if (!analysisData.labelData[label]) {
                        analysisData.labelData[label] = 0;
                    }
                    analysisData.labelData[label]++;

                    // ã‚¯ã‚©ãƒ¼ã‚¿ãƒ¼åˆ¥
                    if (quarter) {
                        if (!analysisData.quarterlyData[quarter]) {
                            analysisData.quarterlyData[quarter] = {};
                        }
                        if (!analysisData.quarterlyData[quarter][label]) {
                            analysisData.quarterlyData[quarter][label] = 0;
                        }
                        analysisData.quarterlyData[quarter][label]++;
                    }

                    // ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆæŠ½å‡º
                    const sentimentMatch = sentimentText.match(/ãƒ©ãƒ™ãƒ«: (\w+)/);
                    if (sentimentMatch) {
                        const sentiment = sentimentMatch[1];
                        if (!analysisData.sentimentData[sentiment]) {
                            analysisData.sentimentData[sentiment] = 0;
                        }
                        analysisData.sentimentData[sentiment]++;

                        // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿
                        const key = `${label}_${sentiment}`;
                        if (!analysisData.heatmapData[key]) {
                            analysisData.heatmapData[key] = 0;
                        }
                        analysisData.heatmapData[key]++;
                    }
                }
            }

            // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é¸æŠè‚¢ã®æ›´æ–°
            updateFilterOptions();
        }

        // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é¸æŠè‚¢ã®æ›´æ–°
        function updateFilterOptions() {
            const labelFilter = document.getElementById('labelFilter');
            labelFilter.innerHTML = '<option value="all">å…¨ãƒ©ãƒ™ãƒ«</option>';
            
            Object.keys(analysisData.labelData).forEach(label => {
                const option = document.createElement('option');
                option.value = label;
                option.textContent = label;
                labelFilter.appendChild(option);
            });
        }

        // æ–°æ©Ÿèƒ½: å¯è¦–åŒ–è¡¨ç¤ºã®åˆ‡ã‚Šæ›¿ãˆ
        function toggleVisualization() {
            const dashboard = document.getElementById('dashboardSection');
            dashboardVisible = !dashboardVisible;
            
            if (dashboardVisible) {
                dashboard.style.display = 'block';
                document.getElementById('visualizeBtn').textContent = 'ğŸ“Š å¯è¦–åŒ–éè¡¨ç¤º';
                initializeCharts();
                updateKPIs();
            } else {
                dashboard.style.display = 'none';
                document.getElementById('visualizeBtn').textContent = 'ğŸ“Š å¯è¦–åŒ–è¡¨ç¤º';
                destroyAllCharts();
            }
        }

        // ãƒãƒ£ãƒ¼ãƒˆã®åˆæœŸåŒ–
        function initializeCharts() {
            setTimeout(() => {
                createMonthlyTrendChart();
                createLabelDistributionChart();
                createSentimentChart();
                createQuarterlyChart();
                createHeatmapTable();
            }, 100);
        }

        // ã™ã¹ã¦ã®ãƒãƒ£ãƒ¼ãƒˆã‚’å‰Šé™¤
        function destroyAllCharts() {
            Object.values(charts).forEach(chart => {
                if (chart && typeof chart.destroy === 'function') {
                    chart.destroy();
                }
            });
            charts = {};
        }

        // KPIæ›´æ–°
        function updateKPIs() {
            const total = processedData.length - 1;
            const positive = sentimentDataList.filter(s => s.label === 'ãƒã‚¸ãƒ†ã‚£ãƒ–').length;
            const positiveRate = ((positive / total) * 100).toFixed(1);
            
            const labelCounts = Object.entries(analysisData.labelData).sort((a, b) => b[1] - a[1]);
            const topLabel = labelCounts[0] ? labelCounts[0][0] : '-';
            const topLabelCount = labelCounts[0] ? labelCounts[0][1] : 0;
            
            const avgScore = (sentimentDataList.reduce((sum, s) => sum + s.score, 0) / sentimentDataList.length).toFixed(1);

            document.getElementById('totalReviews').textContent = total;
            document.getElementById('positiveRate').textContent = positiveRate + '%';
            document.getElementById('topLabel').textContent = topLabel;
            document.getElementById('avgScore').textContent = avgScore;

            // ãƒˆãƒ¬ãƒ³ãƒ‰è¡¨ç¤ºï¼ˆç°¡å˜ãªå®Ÿè£…ï¼‰
            document.getElementById('reviewsTrend').textContent = `${total}ä»¶`;
            document.getElementById('reviewsTrend').className = 'trend-indicator trend-stable';
            
            document.getElementById('positiveTrend').textContent = `${positive}ä»¶`;
            document.getElementById('positiveTrend').className = `trend-indicator ${positiveRate > 60 ? 'trend-up' : positiveRate < 40 ? 'trend-down' : 'trend-stable'}`;
            
            document.getElementById('topLabelCount').textContent = `${topLabelCount}ä»¶`;
            document.getElementById('topLabelCount').className = 'trend-indicator trend-stable';
            
            document.getElementById('scoreTrend').textContent = `å…¨ä½“å¹³å‡`;
            document.getElementById('scoreTrend').className = `trend-indicator ${avgScore > 60 ? 'trend-up' : avgScore < 40 ? 'trend-down' : 'trend-stable'}`;
        }

        // æœˆåˆ¥æ¨ç§»ãƒãƒ£ãƒ¼ãƒˆ
        function createMonthlyTrendChart() {
            const ctx = document.getElementById('monthlyTrendChart').getContext('2d');
            
            const months = Object.keys(analysisData.monthlyData).sort();
            const datasets = [];
            
            // ä¸Šä½5ãƒ©ãƒ™ãƒ«ã®ã¿è¡¨ç¤º
            const topLabels = Object.entries(analysisData.labelData)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([label]) => label);
            
            const colors = [
                '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF'
            ];
            
            topLabels.forEach((label, index) => {
                const data = months.map(month => analysisData.monthlyData[month][label] || 0);
                datasets.push({
                    label: label,
                    data: data,
                    borderColor: colors[index],
                    backgroundColor: colors[index] + '20',
                    fill: document.getElementById('chartType').value === 'area'
                });
            });

            if (charts.monthlyTrend) {
                charts.monthlyTrend.destroy();
            }

            charts.monthlyTrend = new Chart(ctx, {
                type: document.getElementById('chartType').value === 'bar' ? 'bar' : 'line',
                data: {
                    labels: months,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // ãƒ©ãƒ™ãƒ«åˆ†å¸ƒãƒãƒ£ãƒ¼ãƒˆ
        function createLabelDistributionChart() {
            const ctx = document.getElementById('labelDistributionChart').getContext('2d');
            
            const labels = Object.keys(analysisData.labelData);
            const data = Object.values(analysisData.labelData);
            
            if (charts.labelDistribution) {
                charts.labelDistribution.destroy();
            }

            charts.labelDistribution = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: [
                            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
                            '#FF9F40', '#C9CBCF', '#4BC0C0', '#FF6384', '#36A2EB'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                        }
                    }
                }
            });
        }

        // ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆãƒãƒ£ãƒ¼ãƒˆ
        function createSentimentChart() {
            const ctx = document.getElementById('sentimentChart').getContext('2d');
            
            if (charts.sentiment) {
                charts.sentiment.destroy();
            }

            charts.sentiment = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: Object.keys(analysisData.sentimentData),
                    datasets: [{
                        data: Object.values(analysisData.sentimentData),
                        backgroundColor: ['#4CAF50', '#F44336', '#FF9800']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                        }
                    }
                }
            });
        }

        // ã‚¯ã‚©ãƒ¼ã‚¿ãƒ¼åˆ¥ãƒãƒ£ãƒ¼ãƒˆ
        function createQuarterlyChart() {
            const ctx = document.getElementById('quarterlyChart').getContext('2d');
            
            const quarters = Object.keys(analysisData.quarterlyData).sort();
            const datasets = [];
            
            const topLabels = Object.entries(analysisData.labelData)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([label]) => label);
            
            const colors = [
                '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF'
            ];
            
            topLabels.forEach((label, index) => {
                const data = quarters.map(quarter => analysisData.quarterlyData[quarter][label] || 0);
                datasets.push({
                    label: label,
                    data: data,
                    backgroundColor: colors[index]
                });
            });

            if (charts.quarterly) {
                charts.quarterly.destroy();
            }

            charts.quarterly = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: quarters,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                        },
                        y: {
                            stacked: true,
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ãƒ†ãƒ¼ãƒ–ãƒ«
        function createHeatmapTable() {
            const container = document.getElementById('heatmapTable');
            const labels = Object.keys(analysisData.labelData);
            const sentiments = ['ãƒã‚¸ãƒ†ã‚£ãƒ–', 'ãƒã‚¬ãƒ†ã‚£ãƒ–', 'ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«'];
            
            let html = '<tr><th>ãƒ©ãƒ™ãƒ«</th>';
            sentiments.forEach(sentiment => {
                html += `<th>${sentiment}</th>`;
            });
            html += '</tr>';
            
            labels.forEach(label => {
                html += `<tr><td style="font-weight: bold; padding: 8px; border: 1px solid #ddd;">${label}</td>`;
                sentiments.forEach(sentiment => {
                    const key = `${label}_${sentiment}`;
                    const count = analysisData.heatmapData[key] || 0;
                    const total = analysisData.labelData[label] || 1;
                    const percentage = ((count / total) * 100).toFixed(1);
                    
                    let bgColor = '#f5f5f5';
                    if (sentiment === 'ãƒã‚¸ãƒ†ã‚£ãƒ–' && percentage > 50) bgColor = '#c8e6c9';
                    else if (sentiment === 'ãƒã‚¬ãƒ†ã‚£ãƒ–' && percentage > 30) bgColor = '#ffcdd2';
                    else if (sentiment === 'ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«' && percentage > 40) bgColor = '#e1f5fe';
                    
                    html += `<td style="padding: 8px; border: 1px solid #ddd; background-color: ${bgColor}; text-align: center;">
                        ${count}<br><small>${percentage}%</small>
                    </td>`;
                });
                html += '</tr>';
            });
            
            container.innerHTML = html;
        }

        // ãƒãƒ£ãƒ¼ãƒˆæ›´æ–°
        function updateCharts() {
            if (dashboardVisible) {
                destroyAllCharts();
                initializeCharts();
            }
        }

        function showStatistics() {
            const statsDiv = document.getElementById('stats');
            const statsContent = document.getElementById('statsContent');
            
            const yearMonthStats = {};
            const labelStats = {};
            
            for (let i = 1; i < processedData.length; i++) {
                const yearMonth = processedData[i][14];
                const labels = processedData[i][11];
                
                if (yearMonth) {
                    yearMonthStats[yearMonth] = (yearMonthStats[yearMonth] || 0) + 1;
                }
                
                if (labels) {
                    labelStats[labels] = (labelStats[labels] || 0) + 1;
                }
            }
            
            let html = '<p><strong>ç·ãƒ¬ãƒ“ãƒ¥ãƒ¼æ•°:</strong> ' + (processedData.length - 1) + '</p>';
            html += '<p><strong>æœŸé–“:</strong> ' + Object.keys(yearMonthStats).sort()[0] + ' ï½ ' + 
                    Object.keys(yearMonthStats).sort().slice(-1)[0] + '</p>';
            
            if (labelConfig.length > 0) {
                html += `<p><strong>ãƒ©ãƒ™ãƒ«è¨­å®š:</strong> ã‚«ã‚¹ã‚¿ãƒ è¨­å®šï¼ˆ${labelConfig.length}ä»¶ï¼‰</p>`;
            } else {
                html += '<p><strong>ãƒ©ãƒ™ãƒ«è¨­å®š:</strong> ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š</p>';
            }
            
            html += '<p><strong>ğŸš€ Phase 3:</strong> å¼·åŒ–ç‰ˆã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ å®Œå…¨ç‰ˆé©ç”¨æ¸ˆã¿ï¼ˆ90%+ ç²¾åº¦ï¼‰</p>';
            
            html += '<p><strong>ãƒ©ãƒ™ãƒ«åˆ¥ä»¶æ•°:</strong></p><ul>';
            Object.entries(labelStats).sort((a, b) => b[1] - a[1]).forEach(([label, count]) => {
                html += `<li>${label}: ${count}ä»¶</li>`;
            });
            html += '</ul>';
            
            statsContent.innerHTML = html;
            statsDiv.style.display = 'block';
        }

        function showSampleResults() {
            const sampleDiv = document.getElementById('sampleResults');
            const sampleContent = document.getElementById('sampleContent');
            
            let html = '';
            for (let i = 1; i <= 5 && i < processedData.length; i++) {
                const row = processedData[i];
                const sentimentLines = row[15].split('\\n');
                html += `<div class="result-item">
                    <strong>ãƒ¬ãƒ“ãƒ¥ãƒ¼:</strong> ${String(row[10]).substring(0, 100)}...<br>
                    <strong>ãƒ©ãƒ™ãƒ«:</strong> ${row[11]}<br>
                    <strong>å¹´æœˆ:</strong> ${row[14]}<br>
                    <strong>ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆåˆ†æ:</strong><br>
                    ${sentimentLines.map(line => `&nbsp;&nbsp;${line}`).join('<br>')}
                </div>`;
            }
            
            sampleContent.innerHTML = html;
            sampleDiv.style.display = 'block';
        }

        function downloadExcel() {
            if (!processedData) return;
            
            const wb = XLSX.utils.book_new();
            const ws1 = XLSX.utils.aoa_to_sheet(processedData);
            XLSX.utils.book_append_sheet(wb, ws1, 'ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ‡ãƒ¼ã‚¿');
            
            const statsData = createStatisticsSheet();
            const ws2 = XLSX.utils.aoa_to_sheet(statsData);
            XLSX.utils.book_append_sheet(wb, ws2, 'çµ±è¨ˆåˆ†æ');
            
            const sentimentSummaryData = createSentimentSummarySheet();
            const ws3 = XLSX.utils.aoa_to_sheet(sentimentSummaryData);
            XLSX.utils.book_append_sheet(wb, ws3, 'ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆåˆ†æ');
            
            XLSX.writeFile(wb, 'ãƒšãƒƒãƒˆãƒ•ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼åˆ†æçµæœ_Phase3_å®Œå…¨ç‰ˆ.xlsx');
        }

        function createStatisticsSheet() {
            const statsData = [['ãƒšãƒƒãƒˆãƒ•ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼åˆ†æçµæœ - çµ±è¨ˆåˆ†æï¼ˆPhase 3: å¼·åŒ–ç‰ˆå®Œå…¨ç‰ˆï¼‰']];
            statsData.push([]);
            
            const yearMonthLabelCounts = {};
            const quarterLabelCounts = {};
            const yearMonthTotals = {};
            const quarterTotals = {};
            
            const allLabels = new Set(labelConfig.length > 0 ? 
                labelConfig.map(c => c.name) : masterLabels);
            const allYearMonths = new Set();
            const allQuarters = new Set();
            
            for (let i = 1; i < processedData.length; i++) {
                const yearMonth = processedData[i][14];
                const quarter = processedData[i][16];
                const label = processedData[i][11];
                
                if (yearMonth && label) {
                    allYearMonths.add(yearMonth);
                    yearMonthTotals[yearMonth] = (yearMonthTotals[yearMonth] || 0) + 1;
                    
                    if (!yearMonthLabelCounts[yearMonth]) {
                        yearMonthLabelCounts[yearMonth] = {};
                    }
                    
                    yearMonthLabelCounts[yearMonth][label] = 
                        (yearMonthLabelCounts[yearMonth][label] || 0) + 1;
                }
                
                if (quarter && label) {
                    allQuarters.add(quarter);
                    quarterTotals[quarter] = (quarterTotals[quarter] || 0) + 1;
                    
                    if (!quarterLabelCounts[quarter]) {
                        quarterLabelCounts[quarter] = {};
                    }
                    
                    quarterLabelCounts[quarter][label] = 
                        (quarterLabelCounts[quarter][label] || 0) + 1;
                }
            }
            
            const sortedYearMonths = Array.from(allYearMonths).sort();
            const sortedQuarters = Array.from(allQuarters).sort();
            const sortedLabels = Array.from(allLabels);
            
            statsData.push(['ã€è¡¨1ã€‘å¹´æœˆã”ã¨ã®å®Ÿæ•°æ¨ç§»']);
            statsData.push(['ãƒ©ãƒ™ãƒ«', ...sortedYearMonths]);
            
            sortedLabels.forEach(label => {
                const row = [label];
                sortedYearMonths.forEach(ym => {
                    row.push(yearMonthLabelCounts[ym] && yearMonthLabelCounts[ym][label] ? yearMonthLabelCounts[ym][label] : 0);
                });
                statsData.push(row);
            });
            
            const totalRow = ['åˆè¨ˆ'];
            sortedYearMonths.forEach(ym => {
                totalRow.push(yearMonthTotals[ym] || 0);
            });
            statsData.push(totalRow);
            
            statsData.push([]);
            statsData.push([]);
            
            statsData.push(['ã€è¡¨2ã€‘å¹´æœˆã”ã¨ã®å‰²åˆæ¨ç§»ï¼ˆ%ï¼‰']);
            statsData.push(['ãƒ©ãƒ™ãƒ«', ...sortedYearMonths]);
            
            sortedLabels.forEach(label => {
                const row = [label];
                sortedYearMonths.forEach(ym => {
                    const count = yearMonthLabelCounts[ym] && yearMonthLabelCounts[ym][label] ? yearMonthLabelCounts[ym][label] : 0;
                    const total = yearMonthTotals[ym] || 1;
                    const percentage = ((count / total) * 100).toFixed(1);
                    row.push(percentage + '%');
                });
                statsData.push(row);
            });
            
            statsData.push([]);
            statsData.push([]);
            
            statsData.push(['ã€è¡¨3ã€‘ã‚¯ã‚©ãƒ¼ã‚¿ãƒ¼ã”ã¨ã®ã¾ã¨ã‚']);
            
            statsData.push(['ãƒ©ãƒ™ãƒ«ï¼ˆå®Ÿæ•°ï¼‰', ...sortedQuarters]);
            sortedLabels.forEach(label => {
                const row = [label];
                sortedQuarters.forEach(q => {
                    row.push(quarterLabelCounts[q] && quarterLabelCounts[q][label] ? quarterLabelCounts[q][label] : 0);
                });
                statsData.push(row);
            });
            
            const quarterTotalRow = ['åˆè¨ˆ'];
            sortedQuarters.forEach(q => {
                quarterTotalRow.push(quarterTotals[q] || 0);
            });
            statsData.push(quarterTotalRow);
            
            statsData.push([]);
            
            statsData.push(['ãƒ©ãƒ™ãƒ«ï¼ˆå‰²åˆ%ï¼‰', ...sortedQuarters]);
            sortedLabels.forEach(label => {
                const row = [label];
                sortedQuarters.forEach(q => {
                    const count = quarterLabelCounts[q] && quarterLabelCounts[q][label] ? quarterLabelCounts[q][label] : 0;
                    const total = quarterTotals[q] || 1;
                    const percentage = ((count / total) * 100).toFixed(1);
                    row.push(percentage + '%');
                });
                statsData.push(row);
            });
            
            return statsData;
        }

        function createSentimentSummarySheet() {
            const summaryData = [['ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆåˆ†æã‚µãƒãƒªãƒ¼ï¼ˆPhase 3: å¼·åŒ–ç‰ˆå®Œå…¨ç‰ˆï¼‰']];
            summaryData.push([]);
            
            const positive = sentimentDataList.filter(s => s.label === 'ãƒã‚¸ãƒ†ã‚£ãƒ–').length;
            const negative = sentimentDataList.filter(s => s.label === 'ãƒã‚¬ãƒ†ã‚£ãƒ–').length;
            const neutral = sentimentDataList.filter(s => s.label === 'ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«').length;
            const total = sentimentDataList.length;
            
            summaryData.push(['é …ç›®', 'ä»¶æ•°', 'å‰²åˆ']);
            summaryData.push(['ç·ãƒ¬ãƒ“ãƒ¥ãƒ¼æ•°', total, '100.0%']);
            summaryData.push(['ãƒã‚¸ãƒ†ã‚£ãƒ–', positive, `${(positive/total*100).toFixed(1)}%`]);
            summaryData.push(['ãƒã‚¬ãƒ†ã‚£ãƒ–', negative, `${(negative/total*100).toFixed(1)}%`]);
            summaryData.push(['ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«', neutral, `${(neutral/total*100).toFixed(1)}%`]);
            
            summaryData.push([]);
            summaryData.push(['ä¸»ãªå‚¾å‘']);
            
            if (positive > negative * 2) {
                summaryData.push(['å…¨ä½“çš„ã«å¥½è©•ä¾¡ãŒå¤šãã€è£½å“ã«å¯¾ã™ã‚‹æº€è¶³åº¦ãŒé«˜ã„å‚¾å‘ã«ã‚ã‚Šã¾ã™ã€‚']);
            }
            if (negative > positive * 2) {
                summaryData.push(['æ”¹å–„ãŒå¿…è¦ãªç‚¹ãŒå¤šãè¦‹å—ã‘ã‚‰ã‚Œã¾ã™ã€‚']);
            }
            if (Math.abs(positive - negative) < total * 0.1) {
                summaryData.push(['è©•ä¾¡ãŒåˆ†ã‹ã‚Œã¦ãŠã‚Šã€å€‹ä½“å·®ã‚„å¥½ã¿ã®é•ã„ãŒå¤§ãã„ã‚ˆã†ã§ã™ã€‚']);
            }
            
            summaryData.push([]);
            summaryData.push(['æœˆåˆ¥ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆæ¨ç§»']);
            
            const monthSentiment = {};
            for (let i = 1; i < processedData.length; i++) {
                const yearMonth = processedData[i][14];
                const sentiment = processedData[i][15];
                
                if (yearMonth && sentiment) {
                    if (!monthSentiment[yearMonth]) {
                        monthSentiment[yearMonth] = {
                            'ãƒã‚¸ãƒ†ã‚£ãƒ–': 0,
                            'ãƒã‚¬ãƒ†ã‚£ãƒ–': 0,
                            'ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«': 0
                        };
                    }
                    
                    const sentimentMatch = sentiment.match(/ãƒ©ãƒ™ãƒ«: (\w+)/);
                    if (sentimentMatch) {
                        monthSentiment[yearMonth][sentimentMatch[1]]++;
                    }
                }
            }
            
            const sortedMonths = Object.keys(monthSentiment).sort();
            summaryData.push(['å¹´æœˆ', 'ãƒã‚¸ãƒ†ã‚£ãƒ–', 'ãƒã‚¬ãƒ†ã‚£ãƒ–', 'ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«']);
            
            sortedMonths.forEach(month => {
                summaryData.push([
                    month,
                    monthSentiment[month]['ãƒã‚¸ãƒ†ã‚£ãƒ–'],
                    monthSentiment[month]['ãƒã‚¬ãƒ†ã‚£ãƒ–'],
                    monthSentiment[month]['ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«']
                ]);
            });
            
            return summaryData;
        }
        
        // ===========================================
        // ğŸ“ æ•™å¸«ãƒ‡ãƒ¼ã‚¿å­¦ç¿’ã‚·ã‚¹ãƒ†ãƒ 
        // ===========================================
        
        /**
         * ğŸ† ä¿®æ­£ç‰ˆï¼šé«˜ç²¾åº¦ãƒšãƒƒãƒˆãƒ•ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼æ•™å¸«å­¦ç¿’ã‚·ã‚¹ãƒ†ãƒ 
         * æ•™å¸«ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å­¦ç¿’ã—ã¦10ã‚«ãƒ†ã‚´ãƒªåˆ†é¡ç²¾åº¦ã‚’å¤§å¹…å‘ä¸Š
         */
class PetFoodTeacherLearning {
    constructor() {
        // 10å›ºå®šã‚«ãƒ†ã‚´ãƒª
        this.categories = [
            'åããƒ»ä¾¿ãŒæ‚ªããªã‚‹',
            'é£Ÿã¹ãªã„',
            'åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„',
            'é£Ÿã¹ã‚‹',
            'å€¤ä¸ŠãŒã‚Š/é«˜ã„',
            'å®‰ã„',
            'é…é€ãƒ»æ¢±åŒ…',
            'è³å‘³æœŸé™',
            'ã‚¸ãƒƒãƒ‘ãƒ¼',
            'ãã®ä»–'
        ];

        // å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸
        this.categoryPatterns = {};
        this.wordScores = {};
        this.isLearned = false;
        this.accuracyHistory = [];
        
        // å„ã‚«ãƒ†ã‚´ãƒªåˆæœŸåŒ–
        this.categories.forEach(category => {
            this.categoryPatterns[category] = new Map();
            this.wordScores[category] = new Map();
        });
        
        // ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
        this.loadModel();
    }
    
    /**
     * æ•™å¸«ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å­¦ç¿’
     */
    processTeacherData(teacherData) {
        console.log('ğŸ“ æ•™å¸«ãƒ‡ãƒ¼ã‚¿å­¦ç¿’é–‹å§‹:', teacherData.length, 'ä»¶');
        
        // ã‚«ãƒ†ã‚´ãƒªåˆ†å¸ƒç¢ºèª
        const categoryStats = {};
        this.categories.forEach(cat => categoryStats[cat] = 0);
        teacherData.forEach(ex => {
            if (categoryStats[ex.category] !== undefined) {
                categoryStats[ex.category]++;
            }
        });
        console.log('ğŸ“Š ã‚«ãƒ†ã‚´ãƒªåˆ†å¸ƒ:', categoryStats);
        
        // å„ã‚«ãƒ†ã‚´ãƒªã®ç‰¹å¾´èªã‚’å­¦ç¿’
        this.categories.forEach(category => {
            const examples = teacherData.filter(ex => ex.category === category);
            this.learnCategoryFeatures(category, examples, teacherData.length);
        });
        
        this.isLearned = true;
        this.saveModel();
        console.log('âœ… æ•™å¸«ãƒ‡ãƒ¼ã‚¿å­¦ç¿’å®Œäº†');
    }
    
    /**
     * ã‚«ãƒ†ã‚´ãƒªç‰¹å¾´èªå­¦ç¿’
     */
    learnCategoryFeatures(category, examples, totalExamples) {
        if (examples.length === 0) return;
        
        const wordFreq = new Map();
        const totalWords = new Map();
        
        // å˜èªé »åº¦è¨ˆç®—
        examples.forEach(ex => {
            const words = this.extractWords(ex.text);
            words.forEach(word => {
                wordFreq.set(word, (wordFreq.get(word) || 0) + 1);
                totalWords.set(word, (totalWords.get(word) || 0) + 1);
            });
        });
        
        // TF-IDFé¢¨ã‚¹ã‚³ã‚¢è¨ˆç®—
        wordFreq.forEach((freq, word) => {
            const tf = freq / examples.length;
            const categoryOccurrence = this.categories.reduce((count, cat) => {
                return count + (this.wordScores[cat].has(word) ? 1 : 0);
            }, 0);
            const idf = Math.log(this.categories.length / (1 + categoryOccurrence));
            const score = tf * idf;
            
            if (score > 0.1) { // é–¾å€¤ä»¥ä¸Šã®ã¿ä¿å­˜
                this.wordScores[category].set(word, score);
            }
        });
        
        // ç‰¹å¾´çš„ãªãƒ•ãƒ¬ãƒ¼ã‚ºãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å­¦ç¿’
        this.learnPhrasePatterns(category, examples);
        
        console.log(`ğŸ“ ${category}: ${this.wordScores[category].size}èªã‚’å­¦ç¿’`);
    }
    
    /**
     * ãƒ•ãƒ¬ãƒ¼ã‚ºãƒ‘ã‚¿ãƒ¼ãƒ³å­¦ç¿’
     */
    learnPhrasePatterns(category, examples) {
        const patterns = new Map();
        
        // ã‚«ãƒ†ã‚´ãƒªç‰¹æœ‰ã®ãƒ•ãƒ¬ãƒ¼ã‚ºã‚’å­¦ç¿’
        examples.forEach(ex => {
            const phrases = this.extractPhrases(ex.text, category);
            phrases.forEach(phrase => {
                patterns.set(phrase, (patterns.get(phrase) || 0) + 1);
            });
        });
        
        // é«˜é »åº¦ãƒ•ãƒ¬ãƒ¼ã‚ºã®ã¿ä¿å­˜
        patterns.forEach((freq, phrase) => {
            if (freq >= 2) {
                this.categoryPatterns[category].set(phrase, freq / examples.length);
            }
        });
    }
    
    /**
     * å˜èªæŠ½å‡ºï¼ˆæ—¥æœ¬èªç‰¹åŒ–ï¼‰
     */
    extractWords(text) {
        const words = [];
        const cleanText = text.toLowerCase().replace(/[ï¼ï¼Ÿã€‚ã€]/g, '');
        
        // æ—¥æœ¬èªã®å˜èªãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æŠ½å‡º
        const patterns = [
            /[ã‚-ã‚“ã‚¢-ãƒ³ãƒ¼ãƒ»]+/g,  // ã²ã‚‰ãŒãªãƒ»ã‚«ã‚¿ã‚«ãƒŠ
            /[ä¸€-é¾¯]+/g,           // æ¼¢å­—
            /[a-zA-Z]{2,}/g        // è‹±èª
        ];
        
        patterns.forEach(pattern => {
            const matches = cleanText.match(pattern);
            if (matches) {
                matches.forEach(match => {
                    if (match.length >= 2 && !this.isStopWord(match)) {
                        words.push(match);
                    }
                });
            }
        });
        
        return words;
    }
    
    /**
     * ãƒ•ãƒ¬ãƒ¼ã‚ºæŠ½å‡ºï¼ˆã‚«ãƒ†ã‚´ãƒªç‰¹åŒ–ï¼‰
     */
    extractPhrases(text, category) {
        const phrases = [];
        const lowerText = text.toLowerCase();
        
        // ã‚«ãƒ†ã‚´ãƒªç‰¹æœ‰ã®ãƒ•ãƒ¬ãƒ¼ã‚ºãƒ‘ã‚¿ãƒ¼ãƒ³
        const categoryPhrases = {
            'é£Ÿã¹ã‚‹': [
                /é£Ÿã„ã¤ã.{0,3}è‰¯/g, /ã‚ˆãé£Ÿã¹/g, /ç¾å‘³ã—/g, /å®Œé£Ÿ/g, /å–œã‚“ã§é£Ÿã¹/g
            ],
            'é£Ÿã¹ãªã„': [
                /é£Ÿã¹.{0,3}ãªã„/g, /é£Ÿã„ã¤ã.{0,3}æ‚ª/g, /æ®‹ã—/g, /æ‹’å¦/g, /è¦‹å‘ãã‚‚ã—ãªã„/g
            ],
            'åããƒ»ä¾¿ãŒæ‚ªããªã‚‹': [
                /åã/g, /ä¸‹ç—¢/g, /è»Ÿä¾¿/g, /ä½“èª¿ä¸è‰¯/g, /ãŠè…¹ã‚’å£Š/g
            ],
            'åãæˆ»ã—ãƒ»ä¾¿ã®æ”¹å–„': [
                /å.{0,5}ãªããªã£ãŸ/g, /ä¾¿.{0,5}è‰¯ããªã£ãŸ/g, /èª¿å­ãŒè‰¯/g, /å…ƒæ°—ã«ãªã£ãŸ/g
            ],
            'é…é€ãƒ»æ¢±åŒ…': [
                /é…é€/g, /æ¢±åŒ…/g, /å±Šã„ãŸ/g, /ç®±/g, /ç ´æ/g
            ],
            'è³å‘³æœŸé™': [
                /è³å‘³æœŸé™/g, /æœŸé™/g, /æ—¥ä»˜/g
            ],
            'ã‚¸ãƒƒãƒ‘ãƒ¼': [
                /ã‚¸ãƒƒãƒ‘ãƒ¼/g, /ãƒãƒ£ãƒƒã‚¯/g, /å¯†å°/g
            ],
            'å€¤ä¸ŠãŒã‚Š/é«˜ã„': [
                /å€¤ä¸ŠãŒã‚Š/g, /é«˜ã„/g, /å€¤æ®µãŒä¸ŠãŒ/g
            ],
            'å®‰ã„': [
                /å®‰ã„/g, /ãŠå¾—/g, /ã‚³ã‚¹ãƒ‘/g
            ]
        };
        
        if (categoryPhrases[category]) {
            categoryPhrases[category].forEach(pattern => {
                const matches = lowerText.match(pattern);
                if (matches) {
                    matches.forEach(match => phrases.push(match));
                }
            });
        }
        
        return phrases;
    }
    
    /**
     * ã‚¹ãƒˆãƒƒãƒ—ãƒ¯ãƒ¼ãƒ‰åˆ¤å®š
     */
    isStopWord(word) {
        const stopWords = ['ã§ã™', 'ã—ãŸ', 'ã—ã¦', 'ã‚ã‚‹', 'ã„ã‚‹', 'ã“ã®', 'ãã®', 'ãã‚Œ', 'ã‹ã‚‰', 'ã¾ã§', 'ãªã©'];
        return stopWords.includes(word) || word.length < 2;
    }
    
    /**
     * ãƒ†ã‚­ã‚¹ãƒˆåˆ†é¡ï¼ˆå­¦ç¿’å¾Œï¼‰
     */
    classifyText(text) {
        if (!this.isLearned) {
            return { category: 'ãã®ä»–', score: 0, confidence: 0 };
        }
        
        const scores = {};
        this.categories.forEach(cat => scores[cat] = 0);
        
        const words = this.extractWords(text);
        
        // å­¦ç¿’ã—ãŸå˜èªã‚¹ã‚³ã‚¢ã‚’é©ç”¨
        this.categories.forEach(category => {
            let categoryScore = 0;
            
            // å˜èªã‚¹ã‚³ã‚¢
            words.forEach(word => {
                const wordScore = this.wordScores[category].get(word) || 0;
                categoryScore += wordScore * 10;
            });
            
            // ãƒ•ãƒ¬ãƒ¼ã‚ºãƒ‘ã‚¿ãƒ¼ãƒ³ã‚¹ã‚³ã‚¢
            const phrases = this.extractPhrases(text, category);
            phrases.forEach(phrase => {
                const phraseScore = this.categoryPatterns[category].get(phrase) || 0;
                categoryScore += phraseScore * 15;
            });
            
            scores[category] = categoryScore;
        });
        
        // æœ€é«˜ã‚¹ã‚³ã‚¢ã®ã‚«ãƒ†ã‚´ãƒªã‚’é¸æŠ
        let bestCategory = 'ãã®ä»–';
        let bestScore = 0;
        
        Object.entries(scores).forEach(([category, score]) => {
            if (score > bestScore) {
                bestScore = score;
                bestCategory = category;
            }
        });
        
        // ä¿¡é ¼åº¦è¨ˆç®—
        const totalScore = Object.values(scores).reduce((a, b) => a + b, 0);
        const confidence = totalScore > 0 ? bestScore / totalScore : 0;
        
        return {
            category: bestCategory,
            score: bestScore,
            confidence: confidence,
            allScores: scores
        };
    }
    
    /**
     * ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‹ã‚‰å­¦ç¿’
     */
    learnFromFeedback(text, correctCategory, predictedCategory) {
        if (!this.categories.includes(correctCategory)) return;
        
        // æ­£è§£ã‚«ãƒ†ã‚´ãƒªã®ç‰¹å¾´èªã‚’å¼·åŒ–
        const words = this.extractWords(text);
        words.forEach(word => {
            const currentScore = this.wordScores[correctCategory].get(word) || 0;
            this.wordScores[correctCategory].set(word, currentScore + 0.1);
        });
        
        // èª¤ç­”ã‚«ãƒ†ã‚´ãƒªã®ç‰¹å¾´èªã‚’æ¸›ç‚¹
        if (predictedCategory !== correctCategory && predictedCategory !== 'ãã®ä»–') {
            words.forEach(word => {
                const currentScore = this.wordScores[predictedCategory].get(word) || 0;
                this.wordScores[predictedCategory].set(word, Math.max(0, currentScore - 0.05));
            });
        }
        
        this.saveModel();
    }
    
    /**
     * ãƒ¢ãƒ‡ãƒ«ä¿å­˜
     */
    saveModel() {
        const model = {
            isLearned: this.isLearned,
            wordScores: this.serializeMapStructure(this.wordScores),
            categoryPatterns: this.serializeMapStructure(this.categoryPatterns),
            accuracyHistory: this.accuracyHistory,
            timestamp: new Date().toISOString()
        };
        
        localStorage.setItem('petFoodTeacherModel', JSON.stringify(model));
    }
    
    /**
     * ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
     */
    loadModel() {
        const savedModel = localStorage.getItem('petFoodTeacherModel');
        if (!savedModel) return;
        
        try {
            const model = JSON.parse(savedModel);
            
            this.isLearned = model.isLearned || false;
            this.accuracyHistory = model.accuracyHistory || [];
            
            if (model.wordScores) {
                this.wordScores = this.deserializeMapStructure(model.wordScores);
            }
            
            if (model.categoryPatterns) {
                this.categoryPatterns = this.deserializeMapStructure(model.categoryPatterns);
            }
            
            if (this.isLearned) {
                console.log('âœ… å­¦ç¿’æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ');
            }
        } catch (e) {
            console.error('âŒ ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', e);
        }
    }
    
    /**
     * Mapæ§‹é€ ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
     */
    serializeMapStructure(mapStructure) {
        const serialized = {};
        Object.keys(mapStructure).forEach(key => {
            serialized[key] = Object.fromEntries(mapStructure[key]);
        });
        return serialized;
    }
    
    /**
     * Mapæ§‹é€ ã®ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
     */
    deserializeMapStructure(serialized) {
        const mapStructure = {};
        Object.keys(serialized).forEach(key => {
            mapStructure[key] = new Map(Object.entries(serialized[key]));
        });
        return mapStructure;
    }
    
    /**
     * ãƒ¢ãƒ‡ãƒ«ãƒªã‚»ãƒƒãƒˆ
     */
    resetModel() {
        this.isLearned = false;
        this.accuracyHistory = [];
        this.categories.forEach(category => {
            this.wordScores[category].clear();
            this.categoryPatterns[category].clear();
        });
        localStorage.removeItem('petFoodTeacherModel');
    }
}        
        // Initialize teacher learning system
        let teacherLearningSystem = new PetFoodTeacherLearning();
        
        // æ—¢å­˜ã®åˆ†é¡é–¢æ•°ã‚’å¼·åŒ–
        const originalDetectLabelsFromConfigV2 = detectLabelsFromConfigV2;
        
        async function detectLabelsFromConfigV2Enhanced(reviewText) {
            // æ•™å¸«å­¦ç¿’ã‚·ã‚¹ãƒ†ãƒ ãŒå­¦ç¿’æ¸ˆã¿ã®å ´åˆã€ãã®çµæœã‚’å„ªå…ˆ
            if (teacherLearningSystem.isLearned) {
                const learningResult = teacherLearningSystem.classifyText(reviewText);
                
                // é«˜ä¿¡é ¼åº¦ã®å ´åˆã¯å­¦ç¿’çµæœã‚’ä½¿ç”¨
                if (learningResult.confidence > 0.2 && learningResult.score > 0.5) {
                    console.log(`ğŸ“ å­¦ç¿’çµæœä½¿ç”¨: ${learningResult.category} (ä¿¡é ¼åº¦: ${learningResult.confidence.toFixed(2)}, ã‚¹ã‚³ã‚¢: ${learningResult.score.toFixed(2)})`);
                    return learningResult.category;
                }
            }
            
            // OpenAI APIã‚’ä½¿ç”¨
            const openaiResult = await originalDetectLabelsFromConfigV2(reviewText);
            console.log(`ğŸ¤– OpenAIçµæœä½¿ç”¨: ${openaiResult}`);
            return openaiResult;
        }
        
        // æ—¢å­˜ã®åˆ†é¡é–¢æ•°ã‚’ç½®ãæ›ãˆ
        detectLabelsFromConfigV2 = detectLabelsFromConfigV2Enhanced;
        
        // æ•™å¸«ãƒ‡ãƒ¼ã‚¿ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç”¨UIã‚’è¿½åŠ 
        function addTeacherLearningUI() {
            const uiHTML = `
            <div id="teacher-learning-section" style="margin: 20px 0; padding: 20px; border: 2px solid #4CAF50; border-radius: 10px; background-color: #f0f8ff;">
                <h3 style="color: #2c5aa0;">ğŸ“ æ•™å¸«ãƒ‡ãƒ¼ã‚¿å­¦ç¿’ã‚·ã‚¹ãƒ†ãƒ </h3>
                
                <div id="teacher-data-upload" style="margin: 15px 0;">
                    <label for="teacher-file" style="font-weight: bold;">æ•™å¸«ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆExcelï¼‰ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ï¼š</label>
                    <input type="file" id="teacher-file" accept=".xlsx,.xls" style="margin: 10px 0;">
                    <button id="process-teacher-data" style="padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        æ•™å¸«ãƒ‡ãƒ¼ã‚¿ã‚’å‡¦ç†
                    </button>
                </div>
                
                <div id="model-management" style="margin: 15px 0;">
                    <button id="save-model" style="padding: 8px 15px; margin: 5px; background-color: #2196F3; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        ãƒ¢ãƒ‡ãƒ«ã‚’ä¿å­˜
                    </button>
                    <button id="reset-model" style="padding: 8px 15px; margin: 5px; background-color: #f44336; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        ãƒ¢ãƒ‡ãƒ«ã‚’ãƒªã‚»ãƒƒãƒˆ
                    </button>
                    <button id="export-model" style="padding: 8px 15px; margin: 5px; background-color: #FF9800; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        ãƒ¢ãƒ‡ãƒ«ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
                    </button>
                </div>
                
                <div id="learning-status" style="margin: 15px 0; padding: 10px; background-color: #e8f5e9; border-radius: 5px; display: none;">
                    <p style="margin: 0; color: #2e7d32;"></p>
                </div>
                
                <div id="accuracy-display" style="margin: 15px 0; padding: 10px; background-color: #fff3e0; border-radius: 5px; display: none;">
                    <p style="margin: 0; color: #e65100;"><strong>åˆ†é¡ç²¾åº¦:</strong> <span id="accuracy-value">-</span></p>
                </div>
            </div>
            `;
            
            // Insert after the main title
            const mainTitle = document.querySelector('h1');
            if (mainTitle) {
                mainTitle.insertAdjacentHTML('afterend', uiHTML);
                setupTeacherLearningListeners();
            }
        }
        
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
        function setupTeacherLearningListeners() {
            // æ•™å¸«ãƒ‡ãƒ¼ã‚¿å‡¦ç†
            document.getElementById('process-teacher-data').addEventListener('click', () => {
                const fileInput = document.getElementById('teacher-file');
                if (fileInput.files.length === 0) {
                    alert('ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
                    return;
                }
                
                processTeacherDataFile(fileInput.files[0]);
            });
            
            // ãƒ¢ãƒ‡ãƒ«ä¿å­˜
            document.getElementById('save-model').addEventListener('click', () => {
                teacherLearningSystem.saveModel();
                showStatus('ãƒ¢ãƒ‡ãƒ«ãŒä¿å­˜ã•ã‚Œã¾ã—ãŸã€‚');
            });
            
            // ãƒ¢ãƒ‡ãƒ«ãƒªã‚»ãƒƒãƒˆ
            document.getElementById('reset-model').addEventListener('click', () => {
                if (confirm('ãƒ¢ãƒ‡ãƒ«ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ')) {
                    teacherLearningSystem.resetModel();
                    showStatus('ãƒ¢ãƒ‡ãƒ«ãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã—ãŸã€‚');
                    // ç²¾åº¦è¡¨ç¤ºã‚’ãƒªã‚»ãƒƒãƒˆ
                    document.getElementById('accuracy-display').style.display = 'none';
                }
            });
            
            // ãƒ¢ãƒ‡ãƒ«ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
            document.getElementById('export-model').addEventListener('click', () => {
                const modelData = localStorage.getItem('petFoodTeacherModel');
                if (modelData) {
                    const blob = new Blob([modelData], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'pet-food-teacher-model.json';
                    a.click();
                    URL.revokeObjectURL(url);
                    showStatus('ãƒ¢ãƒ‡ãƒ«ãŒã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã•ã‚Œã¾ã—ãŸã€‚');
                } else {
                    alert('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãƒ¢ãƒ‡ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
                }
            });
        }
        
        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º
        function showStatus(message) {
            const statusDiv = document.getElementById('learning-status');
            const statusP = statusDiv.querySelector('p');
            statusP.innerHTML = message.replace(/\n/g, '<br>');
            statusDiv.style.display = 'block';
            
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 5000);
        }
        
        // ç²¾åº¦è¡¨ç¤º
        function showAccuracy(accuracy) {
            const accuracyDiv = document.getElementById('accuracy-display');
            const accuracyValue = document.getElementById('accuracy-value');
            accuracyValue.textContent = (accuracy * 100).toFixed(1) + '%';
            accuracyDiv.style.display = 'block';
        }
        
        // æ•™å¸«ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã®å‡¦ç†
        function processTeacherDataFile(file) {
            showStatus('æ•™å¸«ãƒ‡ãƒ¼ã‚¿ã‚’å‡¦ç†ä¸­...');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const worksheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                    
                    // ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ‘ãƒ¼ã‚¹ï¼ˆAåˆ—ï¼šãƒ†ã‚­ã‚¹ãƒˆã€Båˆ—ï¼šãƒ©ãƒ™ãƒ«ï¼‰
                    const teacherData = [];
                    for (let i = 1; i < jsonData.length; i++) {
                        const row = jsonData[i];
                        if (row[0] && row[1]) {
                            const category = String(row[1]).trim();
                            // 10ã‚«ãƒ†ã‚´ãƒªã®ã¿å—ã‘å…¥ã‚Œ
                            if (teacherLearningSystem.categories.includes(category)) {
                                teacherData.push({
                                    text: String(row[0]).trim(),
                                    category: category
                                });
                            }
                        }
                    }
                    
                    if (teacherData.length === 0) {
                        alert('æœ‰åŠ¹ãªæ•™å¸«ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚Aåˆ—ï¼šãƒ†ã‚­ã‚¹ãƒˆã€Båˆ—ï¼šãƒ©ãƒ™ãƒ«ã®å½¢å¼ã§å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');
                        return;
                    }
                    
                    console.log('ğŸ“Š æ•™å¸«ãƒ‡ãƒ¼ã‚¿çµ±è¨ˆ:', teacherData.length, 'ä»¶');
                    
                    // æ•™å¸«ãƒ‡ãƒ¼ã‚¿ã§å­¦ç¿’
                    teacherLearningSystem.processTeacherData(teacherData);
                    
                    // ç²¾åº¦ãƒ†ã‚¹ãƒˆï¼ˆãƒ†ã‚¹ãƒˆç”¨ãƒ‡ãƒ¼ã‚¿ã‚’åˆ†å‰²ï¼‰
                    const testSize = Math.min(100, Math.floor(teacherData.length * 0.2));
                    const testData = teacherData.slice(0, testSize);
                    
                    let correct = 0;
                    let detailResults = [];
                    
                    testData.forEach(example => {
                        const predicted = teacherLearningSystem.classifyText(example.text);
                        const isCorrect = predicted.category === example.category;
                        
                        if (isCorrect) {
                            correct++;
                        }
                        
                        detailResults.push({
                            text: example.text.substring(0, 50),
                            expected: example.category,
                            predicted: predicted.category,
                            confidence: predicted.confidence,
                            correct: isCorrect
                        });
                    });
                    
                    const accuracy = correct / testData.length;
                    
                    // çµæœè¡¨ç¤º
                    showAccuracy(accuracy);
                    showStatus(`âœ… æ•™å¸«ãƒ‡ãƒ¼ã‚¿ ${teacherData.length} ä»¶ã§å­¦ç¿’å®Œäº†ã€‚\nãƒ†ã‚¹ãƒˆç²¾åº¦: ${(accuracy * 100).toFixed(1)}% (${correct}/${testData.length})`);
                    
                    // è©³ç´°çµæœã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«è¡¨ç¤º
                    console.log('ğŸ“Š ãƒ†ã‚¹ãƒˆçµæœè©³ç´°:');
                    console.table(detailResults);
                    
                } catch (error) {
                    console.error('âŒ æ•™å¸«ãƒ‡ãƒ¼ã‚¿å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
                    alert('æ•™å¸«ãƒ‡ãƒ¼ã‚¿ã®å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚\nãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
                }
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«UIã‚’è¿½åŠ 
        document.addEventListener('DOMContentLoaded', function() {
            // æ—¢å­˜ã®åˆæœŸåŒ–å‡¦ç†ã‚’å®Ÿè¡Œã—ã¦ã‹ã‚‰UIã‚’è¿½åŠ 
            setTimeout(() => {
                addTeacherLearningUI();
            }, 100);
        });
    </script>
</body>
</html>
