<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ペットフードレビュー分析ツール</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .upload-area {
            border: 2px dashed #4CAF50;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin: 20px 0;
            background-color: #f9f9f9;
            transition: all 0.3s;
        }
        .upload-area:hover {
            background-color: #e8f5e9;
        }
        .upload-area.dragover {
            background-color: #c8e6c9;
            border-color: #2E7D32;
        }
        .file-input {
            display: none;
        }
        .upload-button {
            background-color: #4CAF50;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
            transition: background-color 0.3s;
        }
        .upload-button:hover {
            background-color: #45a049;
        }
        .progress {
            margin: 20px 0;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .stats {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .sentiment-summary {
            margin: 20px 0;
            padding: 15px;
            background-color: #e3f2fd;
            border-radius: 5px;
            border-left: 4px solid #2196F3;
        }
        .sample-results {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            max-height: 300px;
            overflow-y: auto;
        }
        .result-item {
            margin: 10px 0;
            padding: 10px;
            background-color: white;
            border-radius: 5px;
            border-left: 4px solid #4CAF50;
        }
        .error {
            color: #d32f2f;
            font-weight: bold;
        }
        .success {
            color: #388e3c;
            font-weight: bold;
        }
        .file-list {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #e0e0e0;
        }
        .file-item:last-child {
            border-bottom: none;
        }
        .remove-file {
            background-color: #f44336;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .remove-file:hover {
            background-color: #d32f2f;
        }
        .debug-button {
            background-color: #ff9800;
            margin-left: 10px;
        }
        .debug-button:hover {
            background-color: #f57c00;
        }
        .master-info {
            background-color: #e8f5e9;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 12px;
            border-left: 4px solid #4CAF50;
        }
        
        /* 新機能: 可視化エリアのスタイル */
        .visualization-container {
            margin: 20px 0;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #e0e0e0;
        }
        .chart-container {
            margin: 20px 0;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .chart-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            color: #333;
        }
        .chart-wrapper {
            position: relative;
            height: 400px;
            margin: 10px 0;
        }
        .chart-wrapper.small {
            height: 300px;
        }
        .dashboard-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .dashboard-card {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }
        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #4CAF50;
            margin: 10px 0;
        }
        .metric-label {
            font-size: 14px;
            color: #666;
            text-transform: uppercase;
        }
        .filter-controls {
            margin: 20px 0;
            padding: 15px;
            background-color: #e8f5e9;
            border-radius: 8px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .filter-group label {
            font-size: 12px;
            font-weight: bold;
            color: #333;
        }
        .filter-group select {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }
        .trend-indicator {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 12px;
            margin-left: 10px;
        }
        .trend-up {
            background-color: #c8e6c9;
            color: #2e7d32;
        }
        .trend-down {
            background-color: #ffcdd2;
            color: #d32f2f;
        }
        .trend-stable {
            background-color: #e1f5fe;
            color: #0277bd;
        }
        
        /* 新機能: 高精度化表示 */
        .accuracy-info {
            background-color: #e8f5e9;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #4CAF50;
        }
        .accuracy-badge {
            display: inline-block;
            background-color: #4CAF50;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 10px;
        }
        
        @media (max-width: 768px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }
            .filter-controls {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>ペットフードレビュー分析ツール</h1>
        
        <div class="accuracy-info">
            <strong>🤖 OpenAI API統合版 - 高精度分類システム</strong><span class="accuracy-badge">OpenAI統合</span><br>
            GPT-4o-mini による文脈理解とカスタマイズ可能なカテゴリ分類
        </div>
        
        <!-- 🎯 カテゴリ設定セクション -->
        <div class="accuracy-info" style="background-color: #f3e5f5; border-color: #9c27b0;">
            <strong>🎯 カテゴリ設定</strong><span class="accuracy-badge" style="background-color: #9c27b0;">カスタム</span><br>
            <label for="categoryInput">分類カテゴリを設定してください（1行1カテゴリ）：</label>
            <textarea id="categoryInput" rows="8" style="width: 100%; margin-top: 10px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; font-family: monospace;" placeholder="食べる
食べない
吐く・便が悪くなる
吐き戻し・便の改善
値上がり/高い
安い
配送・梱包
賞味期限
ジッパー
その他">食べる
食べない
吐く・便が悪くなる
吐き戻し・便の改善
値上がり/高い
安い
配送・梱包
賞味期限
ジッパー
その他</textarea>
            
        </div>
        
        <!-- A/Bテスト機能 -->
        <div class="accuracy-info" style="background-color: #e3f2fd; border-color: #2196F3;">
            <strong>🧪 A/Bテスト機能</strong><span class="accuracy-badge" style="background-color: #2196F3;">NEW</span><br>
            <label><input type="checkbox" id="enableAbTest"> A/Bテストモードを有効化（従来版との比較）</label>
        </div>
        
        <div class="upload-area" id="uploadArea">
            <p>ここにExcelファイルをドラッグ&ドロップ<br>または</p>
            <input type="file" id="fileInput" class="file-input" accept=".xlsx,.xls" multiple>
            <label for="fileInput" class="upload-button">ファイルを選択</label>
            <p style="margin-top: 20px; font-size: 14px; color: #666;">
                必要なファイル：<br>
                1. Raw_Review.xlsx（レビューデータ）<br>
                2. Master.xlsx（ラベルマスター）※オプション
            </p>
            <div class="master-info">
                <strong>🎯 Master.xlsxの新形式（拡張機能）：</strong><br>
                A列：ラベル名、B列：優先度（数値）、C列：判定パターン（|区切り）<br>
                例：A1=「配送・梱包」、B1=1、C1=「配送|梱包|発送|届く|箱」<br>
                ※従来形式（A列のみ）でも動作します
            </div>
        </div>

        <div id="fileList" class="file-list" style="display: none;">
            <h3>アップロードされたファイル</h3>
            <div id="fileItems"></div>
        </div>
        
        <div id="status" class="progress" style="display: none;">
            ファイルを読み込んでください
        </div>

        <div style="text-align: center;">
            <button onclick="processData()" id="processBtn" style="display: none;">データ処理を開始</button>
            <button onclick="debugDateData()" id="debugBtn" class="debug-button" style="display: none;">日付データをデバッグ</button>
            <button onclick="downloadExcel()" id="downloadBtn" disabled>Excelファイルをダウンロード</button>
            <button onclick="toggleVisualization()" id="visualizeBtn" disabled style="background-color: #2196F3;">📊 可視化表示</button>
        </div>

        <!-- 新機能: ダッシュボード -->
        <div id="dashboardSection" class="visualization-container" style="display: none;">
            <h2>📊 分析ダッシュボード</h2>
            
            <!-- フィルター機能 -->
            <div class="filter-controls">
                <div class="filter-group">
                    <label>期間フィルター</label>
                    <select id="periodFilter" onchange="updateCharts()">
                        <option value="all">全期間</option>
                        <option value="last3months">直近3ヶ月</option>
                        <option value="last6months">直近6ヶ月</option>
                        <option value="thisyear">今年</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label>表示ラベル</label>
                    <select id="labelFilter" onchange="updateCharts()">
                        <option value="all">全ラベル</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label>チャート種別</label>
                    <select id="chartType" onchange="updateCharts()">
                        <option value="line">折れ線グラフ</option>
                        <option value="bar">棒グラフ</option>
                        <option value="area">面グラフ</option>
                    </select>
                </div>
            </div>

            <!-- KPI カード -->
            <div class="dashboard-grid">
                <div class="dashboard-card">
                    <div class="metric-label">総レビュー数</div>
                    <div class="metric-value" id="totalReviews">0</div>
                    <span id="reviewsTrend" class="trend-indicator"></span>
                </div>
                <div class="dashboard-card">
                    <div class="metric-label">ポジティブ率</div>
                    <div class="metric-value" id="positiveRate">0%</div>
                    <span id="positiveTrend" class="trend-indicator"></span>
                </div>
                <div class="dashboard-card">
                    <div class="metric-label">最多ラベル</div>
                    <div class="metric-value" id="topLabel">-</div>
                    <span id="topLabelCount" class="trend-indicator"></span>
                </div>
                <div class="dashboard-card">
                    <div class="metric-label">平均スコア</div>
                    <div class="metric-value" id="avgScore">0</div>
                    <span id="scoreTrend" class="trend-indicator"></span>
                </div>
            </div>

            <!-- チャートエリア -->
            <div class="chart-container">
                <div class="chart-title">月別レビュー推移</div>
                <div class="chart-wrapper">
                    <canvas id="monthlyTrendChart"></canvas>
                </div>
            </div>

            <div class="dashboard-grid">
                <div class="chart-container">
                    <div class="chart-title">ラベル分布</div>
                    <div class="chart-wrapper small">
                        <canvas id="labelDistributionChart"></canvas>
                    </div>
                </div>
                <div class="chart-container">
                    <div class="chart-title">センチメント分析</div>
                    <div class="chart-wrapper small">
                        <canvas id="sentimentChart"></canvas>
                    </div>
                </div>
            </div>

            <div class="chart-container">
                <div class="chart-title">クォーター別比較</div>
                <div class="chart-wrapper">
                    <canvas id="quarterlyChart"></canvas>
                </div>
            </div>

            <!-- ヒートマップ風の表示 -->
            <div class="chart-container">
                <div class="chart-title">ラベル×センチメント マトリックス</div>
                <div id="heatmapContainer" style="overflow-x: auto;">
                    <table id="heatmapTable" style="width: 100%; border-collapse: collapse;">
                    </table>
                </div>
            </div>
        </div>

        <div id="stats" class="stats" style="display: none;">
            <h3>処理統計</h3>
            <div id="statsContent"></div>
        </div>

        <div id="sentimentSummary" class="sentiment-summary" style="display: none;">
            <h3>センチメント分析サマリー</h3>
            <div id="sentimentContent"></div>
        </div>

        <div id="sampleResults" class="sample-results" style="display: none;">
            <h3>処理結果サンプル</h3>
            <div id="sampleContent"></div>
        </div>
    </div>

    <script>
        let processedData = null;
        let rawData = null;
        let masterLabels = [
            '食べる', '食べない', '吐き戻し・便の改善', 'その他', '安い',
            '配送・梱包', '値上がり/高い', '吐く・便が悪くなる', '賞味期限', 'ジッパー'
        ];
        let labelConfig = [];
        let uploadedFiles = {};
        let sentimentDataList = [];
        
        // 新機能: チャート管理
        let charts = {};
        let dashboardVisible = false;
        let analysisData = {};

        // ドラッグ&ドロップの設定
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });

        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
        });

        function handleFiles(files) {
            Array.from(files).forEach(file => {
                if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        uploadedFiles[file.name] = {
                            name: file.name,
                            data: e.target.result
                        };
                        updateFileList();
                        checkFiles();
                    };
                    reader.readAsArrayBuffer(file);
                }
            });
        }

        function updateFileList() {
            const fileList = document.getElementById('fileList');
            const fileItems = document.getElementById('fileItems');
            
            if (Object.keys(uploadedFiles).length > 0) {
                fileList.style.display = 'block';
                fileItems.innerHTML = '';
                
                Object.values(uploadedFiles).forEach(file => {
                    const item = document.createElement('div');
                    item.className = 'file-item';
                    item.innerHTML = `
                        <span>${file.name}</span>
                        <button class="remove-file" onclick="removeFile('${file.name}')">削除</button>
                    `;
                    fileItems.appendChild(item);
                });
            } else {
                fileList.style.display = 'none';
            }
        }

        function removeFile(fileName) {
            delete uploadedFiles[fileName];
            updateFileList();
            checkFiles();
        }

        function checkFiles() {
            const hasRawReview = Object.keys(uploadedFiles).some(name => 
                name.toLowerCase().includes('raw_review') || name.toLowerCase().includes('review')
            );
            
            if (hasRawReview) {
                document.getElementById('processBtn').style.display = 'inline-block';
                document.getElementById('debugBtn').style.display = 'inline-block';
                document.getElementById('status').style.display = 'block';
                document.getElementById('status').textContent = '処理準備完了';
                
                const masterFile = Object.values(uploadedFiles).find(file => 
                    file.name.toLowerCase().includes('master')
                );
                if (masterFile) {
                    const workbook = XLSX.read(masterFile.data);
                    const sheet = workbook.Sheets[workbook.SheetNames[0]];
                    const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                    
                    const hasExtendedFormat = data.some(row => row[1] || row[2]);
                    
                    if (hasExtendedFormat) {
                        labelConfig = data
                            .filter(row => row[0])
                            .map(row => ({
                                name: row[0],
                                priority: parseInt(row[1]) || 999,
                                patterns: row[2] ? row[2].split('|').filter(p => p.trim()) : []
                            }))
                            .sort((a, b) => a.priority - b.priority);
                        
                        console.log('カスタムラベル設定を読み込みました:', labelConfig);
                        document.getElementById('status').textContent = `処理準備完了（カスタムラベル設定: ${labelConfig.length}件）`;
                    } else {
                        labelConfig = [];
                        masterLabels = data.map(row => row[0]).filter(label => label);
                        console.log('従来形式のMaster.xlsxを読み込みました:', masterLabels);
                    }
                } else {
                    labelConfig = [];
                }
            } else {
                document.getElementById('processBtn').style.display = 'none';
                document.getElementById('debugBtn').style.display = 'none';
                document.getElementById('status').style.display = 'none';
            }
        }

        function parseDate(dateStr) {
            if (!dateStr) return { year: '', month: '', yearMonth: '', quarter: '' };
            
            console.log('入力された日付データ:', dateStr, 'タイプ:', typeof dateStr);
            
            let date = null;
            
            if (typeof dateStr === 'number' && dateStr > 25569) {
                const excelEpoch = new Date(1899, 11, 30);
                date = new Date(excelEpoch.getTime() + dateStr * 24 * 60 * 60 * 1000);
            }
            else if (typeof dateStr === 'string') {
                const yearMonthMatch = dateStr.match(/(\d{4})年(\d{1,2})月/);
                if (yearMonthMatch) {
                    const year = parseInt(yearMonthMatch[1]);
                    const month = parseInt(yearMonthMatch[2]);
                    date = new Date(year, month - 1, 1);
                }
                else {
                    const normalizedDate = dateStr.replace(/[年月日]/g, '/').replace(/-/g, '/');
                    const testDate = new Date(normalizedDate);
                    if (!isNaN(testDate.getTime())) {
                        date = testDate;
                    }
                }
            }
            
            if (date && !isNaN(date.getTime())) {
                const year = date.getFullYear().toString();
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                const monthNum = parseInt(month);
                const quarter = `${year}Q${Math.ceil(monthNum / 3)}`;
                
                const result = {
                    year: year,
                    month: month,
                    yearMonth: `${year}年${month}月`,
                    quarter: quarter
                };
                
                console.log('解析結果:', result);
                return result;
            }
            
            console.log('日付解析失敗:', dateStr);
            return { year: '', month: '', yearMonth: '', quarter: '' };
        }

        function debugDateData() {
            if (!rawData || rawData.length < 2) {
                const rawReviewFile = Object.values(uploadedFiles).find(file => 
                    file.name.toLowerCase().includes('raw_review') || file.name.toLowerCase().includes('review')
                );
                
                if (!rawReviewFile) {
                    alert('レビューデータファイルが見つかりません');
                    return;
                }
                
                const rawWorkbook = XLSX.read(rawReviewFile.data);
                const rawSheet = rawWorkbook.Sheets[rawWorkbook.SheetNames[0]];
                rawData = XLSX.utils.sheet_to_json(rawSheet, { header: 1 });
            }
            
            console.log('=== 日付データのデバッグ情報 ===');
            console.log('ヘッダー:', rawData[0]);
            
            for (let i = 1; i <= Math.min(10, rawData.length - 1); i++) {
                const dateValue = rawData[i][1];
                console.log(`${i}行目 B列:`, dateValue, 'タイプ:', typeof dateValue);
                
                if (dateValue) {
                    const parsed = parseDate(dateValue);
                    console.log(`  → 解析結果:`, parsed);
                }
            }
            
            alert('コンソールを確認してください。F12を押してConsoleタブを見てください。');
        }

        // 🎯 新機能: 文脈分析機能
        function analyzeReviewContext(reviewText) {
            if (!reviewText) return null;
            
            const sentences = reviewText.split(/[。！？\n]/).filter(s => s.trim());
            const timeMarkers = {
                past: ['今まで', 'これまで', '以前', '前は', 'もともと', '昔から', '従来'],
                current: ['こちら', 'この商品', '今回', 'これ', 'でも', '現在', 'いまは'],
                transition: ['しかし', 'ところが', 'でも', 'けれど', 'が、', 'ただ', 'しかし']
            };
            
            let contextAnalysis = {
                pastContext: [],
                currentContext: [],
                hasTransition: false,
                timelineDetected: false
            };
            
            sentences.forEach((sentence, index) => {
                const cleanSentence = sentence.trim();
                if (!cleanSentence) return;
                
                // 時系列マーカーの検出
                if (timeMarkers.past.some(marker => cleanSentence.includes(marker))) {
                    contextAnalysis.pastContext.push({sentence: cleanSentence, index});
                    contextAnalysis.timelineDetected = true;
                }
                
                if (timeMarkers.current.some(marker => cleanSentence.includes(marker))) {
                    contextAnalysis.currentContext.push({sentence: cleanSentence, index});
                    contextAnalysis.timelineDetected = true;
                }
                
                // 転換マーカーの検出
                if (timeMarkers.transition.some(marker => cleanSentence.includes(marker))) {
                    contextAnalysis.hasTransition = true;
                }
            });
            
            return contextAnalysis;
        }

        // 🎯 Phase 4用キーワードスコアリング関数（優先度1・2対応版）
        function addScoresByKeywordsEnhanced(text, scores, weight = 1.0) {
            const lowerText = text.toLowerCase();
            
            // 食べる関連（大幅拡張 + 文脈考慮強化）
            const eatPatterns = {
                veryStrong: [
                    /完食/, /ペロリ/, /ペロッと/, /バクバク/, /がっつ[きく]/,
                    /夢中.{0,10}食べ/, /勢い.{0,10}食べ/, /飛び付/,
                    /喜んで.{0,15}完食/, /美味しそうに.{0,10}食べ/
                ],
                strong: [
                    /よく食べ/, /食べ[るてたり]/, /たべ[るてたり]/,
                    /食いつ[きくい].{0,5}(良|いい|よ[いくか])/, 
                    /美味[しそ]/, /おいし/, /気に入/, /大好き/,
                    /喜んで/, /お気に入り/, /リピート/,
                    /すぐに食べ/, /一瞬で食べ/, /すごい勢いで/
                ],
                medium: [
                    /食べて.{0,5}くれ/, /ちゃんと.{0,5}食べ/,
                    /しっかり.{0,5}食べ/, /全部.{0,5}食べ/,
                    /普通に食べ/, /まあまあ食べ/
                ],
                weak: [
                    /食べ/, /たべ/  // 最低限のキーワード
                ]
            };
            
            // スコア配点
            eatPatterns.veryStrong.forEach(pattern => {
                if (lowerText.match(pattern)) scores['食べる'] += 15 * weight;
            });
            eatPatterns.strong.forEach(pattern => {
                if (lowerText.match(pattern)) scores['食べる'] += 10 * weight;
            });
            eatPatterns.medium.forEach(pattern => {
                if (lowerText.match(pattern)) scores['食べる'] += 5 * weight;
            });
            eatPatterns.weak.forEach(pattern => {
                if (lowerText.match(pattern)) scores['食べる'] += 2 * weight;
            });
            
            // 食べない関連（強化版 + 文脈精密化）
            const noEatPatterns = {
                veryStrong: [
                    /全く食べない/, /全然食べない/, /絶対に食べない/,
                    /見向きもしない/, /完全拒否/, /一口も食べ/,
                    /匂い.{0,5}嗅[いぐ]だだけ.{0,10}(終わり|おしまい)/
                ],
                strong: [
                    /食べ(てくれ)?な[いか]/, /拒否.{0,10}する/,
                    /口にしな[いか]/, /そっぽ.{0,5}向[くき]/,
                    /警戒.{0,10}して.{0,5}食べな[いか]/,
                    /近づ[かき]もしな[いか]/
                ],
                medium: [
                    /残して/, /食べ残[すし]/, /匂い.{0,5}嗅[いぐ]だだけ/,
                    /興味.{0,5}示さな/, /食いつ[かきく].{0,5}(悪|ない|ダメ)/,
                    /食べ[るて].{0,5}(のに|けど).{0,5}時間.{0,5}かか[るっり]/
                ],
                exclusions: [
                    /(今まで|以前|これまで|前は|もともと|昔は).{0,50}食べ.*な[いか]/,
                    /(他の|別の|違う|前の).{0,30}(フード|エサ|餌)/,
                    /(○○|△△|××|他社|A社|B社).{0,20}(は|では).{0,20}食べ.*な[いか]/,
                    /(最初|はじめ).{0,20}食べ.*な[いか].{0,20}(でも|けど|が).{0,20}(今|現在|いま)/,
                    /食べ.*な[いか].{0,20}(でも|けど|が).{0,20}(健康|元気|調子)/
                ]
            };
            
            // 除外パターンチェック（過去の話や他社製品の話を除外）
            const hasExclusion = noEatPatterns.exclusions.some(pattern => 
                lowerText.match(pattern));
            
            if (!hasExclusion) {
                noEatPatterns.veryStrong.forEach(pattern => {
                    if (lowerText.match(pattern)) scores['食べない'] += 15 * weight;
                });
                noEatPatterns.strong.forEach(pattern => {
                    if (lowerText.match(pattern)) scores['食べない'] += 10 * weight;
                });
                noEatPatterns.medium.forEach(pattern => {
                    if (lowerText.match(pattern)) scores['食べない'] += 5 * weight;
                });
            }
            
            // 健康関連（改善）- 強化版
            const healthImprovePatterns = [
                /(吐|嘔吐|吐き戻し).{0,20}(減[ったり]|なくな[ったり]|しなくな[ったり]|改善|良くな[ったり]|減少|治[ったまり])/,
                /便.{0,20}(良[くいか]な[ったり]|改善|調子が良|快調|しっかり|正常|固く|硬く)/,
                /うんち.{0,20}(良[くいか]な[ったり]|改善|しっかり|正常)/,
                /毛玉.{0,20}(減[ったり]|なくな[ったり]|少な[くい])/,
                /毛並み.{0,10}(良|綺麗|ツヤ|サラサラ)/
            ];
            healthImprovePatterns.forEach(pattern => {
                if (lowerText.match(pattern)) scores['吐き戻し・便の改善'] += 12 * weight;
            });
            
            // 健康関連（悪化）- 厳格版（過剰分類修正）
            const healthWorsenPatterns = [
                /吐[くいたきけ]|嘔吐|吐き戻[しすり]|もど[すし]/,
                /下痢|げり|軟便|血便|便秘|べんぴ/,
                /便.{0,5}(緩[いくめ]|悪[いくめ]|臭[いくめ]|黒[いくめ])/,
                /うんち.{0,10}(緩[いくめ]|悪[いくめ]|臭[いくめ])/
            ];
            // 改善系の除外を強化
            const hasHealthImprovement = lowerText.match(/(減[ったり]|なくな[ったり]|しなくな[ったり]|改善|良くな[ったり]|治[ったまり]|元気|健康|調子.{0,5}良)/);
            
            if (!hasHealthImprovement) {
                healthWorsenPatterns.forEach(pattern => {
                    if (lowerText.match(pattern)) scores['吐く・便が悪くなる'] += 8 * weight;  // スコア下げ
                });
            }
            
            // 価格関連の強化（検出不足修正）
            const pricePatterns = {
                '値上がり/高い': {
                    strong: [
                        /値上[げがり].{0,10}(困[るっり]|辛[いく]|きつ[いく])/,
                        /高くな[っり].{0,10}(困[るっり]|買[えい]ない|続[けら]ない)/,
                        /価格.{0,5}上が[っり].{0,10}(残念|困[るっり])/,
                        /\d+円.{0,10}(高[いく]|たか[いく]).{0,10}(感じ|思[うえ])/,
                        /値上[げがり]/, /高[いくめ]/, /たか[いくめ]/, /高価/, /高額/,
                        /もう少し.{0,10}安[くけ]/, /値段.{0,5}(高[いくめ]|たか[いくめ])/
                    ],
                    exclusions: [
                        /(品質|栄養|原材料).{0,20}(考える|思う).{0,10}高[くけ]ない/,
                        /(でも|けど|が).{0,20}(満足|良[いく]|おすすめ)/
                    ]
                },
                '安い': {
                    strong: [
                        /コスパ.{0,5}(良[いく]|最高|抜群)/,
                        /お得.{0,5}(感|だと思[うえ]|購入)/,
                        /\d+円.{0,10}安[いく].{0,10}(助か[るっり]|嬉し[いく])/,
                        /安[いくめ]|やす[いくめ]/, /手頃|手ごろ|リーズナブル|割安|お買い得/,
                        /価格.{0,5}(満足|納得)/
                    ],
                    exclusions: [
                        /(安[いく]から|安価だから).{0,20}(不安|心配|質)/,
                        /安[いく].{0,10}(けど|でも|が).{0,10}(品質|栄養)/
                    ]
                }
            };
            
            // 価格関連の検出強化
            const hasPriceExclusion = 
                pricePatterns['値上がり/高い'].exclusions.some(p => lowerText.match(p)) ||
                pricePatterns['安い'].exclusions.some(p => lowerText.match(p));
            
            if (!hasPriceExclusion) {
                pricePatterns['値上がり/高い'].strong.forEach(pattern => {
                    if (lowerText.match(pattern)) scores['値上がり/高い'] += 12 * weight;
                });
                
                pricePatterns['安い'].strong.forEach(pattern => {
                    if (lowerText.match(pattern)) scores['安い'] += 12 * weight;
                });
            }
            
            // 緊急修正：教師データに基づく厳格なパターン
            const correctedPatterns = {
                '配送・梱包': [
                    /配送|梱包|発送|届[きいくけ]|箱|包装|配達|宅配|荷物|段ボール|ダンボール/
                    // パッケージ情報系は削除（過剰分類の原因）
                ],
                '賞味期限': [
                    /賞味期限|消費期限|期限|日付|使用期限|有効期限/
                ],
                'ジッパー': [
                    /ジッパー|チャック|密封|ジップ|保存.{0,10}(不便|困)|袋.{0,10}(閉|締)|ファスナー/
                ],
                '吐き戻し・便の改善': [
                    /(吐|嘔吐|吐き戻し).{0,20}(減[ったり]|なくな[ったり]|しなくな[ったり]|改善|良くな[ったり]|減少|治[ったまり])/,
                    /便.{0,20}(良[くいか]な[ったり]|改善|調子が良|快調|しっかり|正常|固く|硬く)/,
                    /うんち.{0,20}(良[くいか]な[ったり]|改善|しっかり|正常)/,
                    /毛玉.{0,20}(減[ったり]|なくな[ったり]|少な[くい])/
                    // 毛並み・体重系は削除（本来の意味に戻す）
                ],
                '食べる': [
                    /完食/, /ペロリ/, /ペロッと/, /バクバク/, /がっつ[きく]/,
                    /夢中.{0,10}食べ/, /勢い.{0,10}食べ/, /飛び付/,
                    /喜んで.{0,15}完食/, /美味しそうに.{0,10}食べ/,
                    /よく食べ/, /食べ[るてたり]/, /たべ[るてたり]/,
                    /食いつ[きくい].{0,5}(良|いい|よ[いくか])/, 
                    /美味[しそ]/, /おいし/, /気に入/, /大好き/,
                    /喜んで/, /お気に入り/, /リピート/,
                    /すぐに食べ/, /一瞬で食べ/, /すごい勢いで/
                    // 購入系は削除（本来の意味に戻す）
                ],
                '食べない': [
                    /全く食べない/, /全然食べない/, /絶対に食べない/,
                    /見向きもしない/, /完全拒否/, /一口も食べ/,
                    /匂い.{0,5}嗅[いぐ]だだけ.{0,10}(終わり|おしまい)/,
                    /食べ(てくれ)?な[いか]/, /拒否.{0,10}する/,
                    /口にしな[いか]/, /そっぽ.{0,5}向[くき]/,
                    /警戒.{0,10}して.{0,5}食べな[いか]/,
                    /近づ[かき]もしな[いか]/,
                    /残して/, /食べ残[すし]/, /匂い.{0,5}嗅[いぐ]だだけ/,
                    /興味.{0,5}示さな/, /食いつ[かきく].{0,5}(悪|ない|ダメ)/,
                    /食べ[るて].{0,5}(のに|けど).{0,5}時間.{0,5}かか[るっり]/
                ]
            };
            
            // 修正パターンのスコアリング
            Object.entries(correctedPatterns).forEach(([category, patterns]) => {
                patterns.forEach(pattern => {
                    if (lowerText.match(pattern)) {
                        scores[category] += 10 * weight;
                    }
                });
            });
            
            // 「その他」として分類すべきパターンの検出
            const otherExclusivePatterns = {
                原材料成分: /原材料|成分|材料|中身重視|素材|添加物|グレインフリー|穀物不使用|無添加|保存料|着色料|天然素材/,
                非消化器系健康: /毛並み|毛艶|毛質|アレルギー|皮膚|痒み|かゆみ|体調(?!不良)|毛玉ケア|ダブルコート|換毛期/,
                用途目的: /差し入れ|プレゼント|贈り物|保護猫|寄付|ギフト/,
                見た目形状: /色(?!々)|見た目|形(?!成)|外観(?!梱包)|質感/
            };
            
            // 「その他」パターン検出時のスコア加算
            let hasOtherPattern = false;
            Object.entries(otherExclusivePatterns).forEach(([type, pattern]) => {
                if (lowerText.match(pattern)) {
                    scores['その他'] += 15 * weight;
                    hasOtherPattern = true;
                }
            });
            
            // 「食べる」カテゴリの厳格化
            if (hasOtherPattern) {
                // 原材料・成分・健康改善などの言及がある場合は「食べる」スコアを大幅減点
                const actualEatingPattern = /食べ[てる]|食い付|がっつく|完食|平らげ|むしゃむしゃ|ぺろり|喜んで食べ|よく食べ|たくさん食べ|美味しそうに/;
                if (!lowerText.match(actualEatingPattern)) {
                    scores['食べる'] -= 20 * weight;
                }
            }
            
            // 非消化器系健康改善は「吐き戻し・便の改善」から除外
            if (lowerText.match(otherExclusivePatterns.非消化器系健康)) {
                scores['吐き戻し・便の改善'] -= 15 * weight;
            }
            
            return scores;
        }

        // 🎯 Phase 3用強化版スコアリングシステム
        function calculateLabelScoresEnhanced(reviewText, context = null) {
            const scores = {
                '食べる': 0,
                '食べない': 0,
                '吐き戻し・便の改善': 0,
                '吐く・便が悪くなる': 0,
                '安い': 0,
                '配送・梱包': 0,
                '値上がり/高い': 0,
                '賞味期限': 0,
                'ジッパー': 0,
                'その他': 0
            };
            
            // 早期「その他」判定のための事前チェック
            const lowerText = reviewText.toLowerCase();
            const otherPatterns = {
                原材料成分: /原材料|成分|材料|中身重視|素材|添加物|グレインフリー|穀物不使用|無添加|保存料|着色料|天然素材/,
                非消化器系健康: /毛並み|毛艶|毛質|アレルギー|皮膚|痒み|かゆみ|体調(?!不良)|毛玉ケア|ダブルコート|換毛期/,
                用途目的: /差し入れ|プレゼント|贈り物|保護猫|寄付|ギフト/,
                見た目形状: /色(?!々)|見た目|形(?!成)|外観(?!梱包)|質感/
            };
            
            let isLikelyOther = false;
            Object.values(otherPatterns).forEach(pattern => {
                if (lowerText.match(pattern)) {
                    isLikelyOther = true;
                }
            });
            
            // 時系列重み付けをより細かく制御
            const timeWeights = {
                pastNegative: 0.1,    // 過去のネガティブ
                pastPositive: 0.3,    // 過去のポジティブ  
                currentNegative: 2.0, // 現在のネガティブ
                currentPositive: 3.0, // 現在のポジティブ
                transition: 1.5       // 転換表現
            };
            
            // 文脈分析結果を考慮したスコアリング
            if (context && context.timelineDetected) {
                // より詳細な重み付けロジック
                context.currentContext.forEach(ctx => {
                    // ポジティブ・ネガティブ判定
                    const isPositive = ctx.sentence.match(/良|いい|好|気に入|満足|喜|完食|美味/);
                    const weight = isPositive ? timeWeights.currentPositive : timeWeights.currentNegative;
                    addScoresByKeywordsEnhanced(ctx.sentence, scores, weight);
                });
                
                context.pastContext.forEach(ctx => {
                    const isPositive = ctx.sentence.match(/良|いい|好|気に入|満足|喜|完食|美味/);
                    const weight = isPositive ? timeWeights.pastPositive : timeWeights.pastNegative;
                    addScoresByKeywordsEnhanced(ctx.sentence, scores, weight);
                });
                
                // 転換表現がある場合の処理
                if (context.hasTransition) {
                    const sentences = reviewText.split(/[。！？\n]/).filter(s => s.trim());
                    sentences.forEach((sentence, index) => {
                        if (sentence.match(/(しかし|ところが|でも|けれど|が、|ただ)/)) {
                            addScoresByKeywordsEnhanced(sentence, scores, timeWeights.transition);
                        }
                    });
                }
                
                // 残りの文章は通常重み
                const processedIndices = [
                    ...context.currentContext.map(c => c.index),
                    ...context.pastContext.map(c => c.index)
                ];
                
                const remainingSentences = reviewText.split(/[。！？\n]/)
                    .filter((_, index) => !processedIndices.includes(index))
                    .join('。');
                    
                if (remainingSentences) {
                    addScoresByKeywordsEnhanced(remainingSentences, scores, 1.0);
                }
            } else {
                // 通常のスコアリング
                addScoresByKeywordsEnhanced(reviewText, scores, 1.0);
            }
            
            return scores;
        }

        // 🎯 階層的分類システム（優先度2対応）
        function getTopScoringLabelHierarchical(scores) {
            const maxScore = Math.max(...Object.values(scores));
            const topLabels = Object.entries(scores)
                .filter(([_, score]) => score === maxScore)
                .map(([label, _]) => label);
            
            // 階層的優先順位（高精度順・10カテゴリ対応）
            const hierarchicalPriority = [
                // 第1層: 明確な具体的カテゴリ（誤分類リスク最小）
                '賞味期限', 'ジッパー', '配送・梱包',
                
                // 第2層: 健康関連（重要度高）
                '吐く・便が悪くなる', '吐き戻し・便の改善',
                
                // 第3層: 食事関連（主要カテゴリ）
                '食べない', '食べる',
                
                // 第4層: 価格関連（過剰分類対策済み）
                '値上がり/高い', '安い',
                
                // 第5層: フォールバック
                'その他'
            ];
            
            return hierarchicalPriority.find(label => topLabels.includes(label)) || 'その他';
        }
        
        // 階層的分類判定システム（「その他」優先判定強化版）
        function classifyHierarchically(reviewText, scores) {
            const lowerText = reviewText.toLowerCase();
            
            // 早期「その他」判定
            const otherPatterns = {
                原材料成分: /原材料|成分|材料|中身重視|素材|添加物|グレインフリー|穀物不使用|無添加|保存料|着色料|天然素材/,
                非消化器系健康: /毛並み|毛艶|毛質|アレルギー|皮膚|痒み|かゆみ|体調(?!不良)|毛玉ケア|ダブルコート|換毛期/,
                用途目的: /差し入れ|プレゼント|贈り物|保護猫|寄付|ギフト/,
                見た目形状: /色(?!々)|見た目|形(?!成)|外観(?!梱包)|質感/
            };
            
            // 「その他」パターンが検出され、かつ他の強いシグナルがない場合
            let hasOtherPattern = false;
            Object.values(otherPatterns).forEach(pattern => {
                if (lowerText.match(pattern)) {
                    hasOtherPattern = true;
                }
            });
            
            if (hasOtherPattern) {
                // 他のカテゴリの強いシグナルがあるかチェック
                const strongSignals = {
                    '食べる': /食べ[てる]|食い付|がっつく|完食|平らげ|むしゃむしゃ|ぺろり|喜んで食べ|よく食べ|たくさん食べ|美味しそうに/,
                    '食べない': /全く食べない|見向きもしない|完全拒否|一口も食べ/,
                    '吐く・便が悪くなる': /吐[くいた]|下痢|軟便|血便/,
                    '吐き戻し・便の改善': /便.{0,20}(良[くい]な[ったり]|改善|快調)|吐.{0,20}(減[ったり]|なくな[ったり]|改善)/
                };
                
                let hasStrongSignal = false;
                Object.entries(strongSignals).forEach(([category, pattern]) => {
                    if (lowerText.match(pattern) && scores[category] >= 15) {
                        hasStrongSignal = true;
                    }
                });
                
                if (!hasStrongSignal) {
                    return 'その他';
                }
            }
            
            // 第1段階: 明確な判定（高信頼度）
            if (scores['賞味期限'] >= 6) return '賞味期限';
            if (scores['ジッパー'] >= 6) return 'ジッパー';
            if (scores['配送・梱包'] >= 8) return '配送・梱包';
            
            // 第2段階: 健康関連（中～高信頼度）
            if (scores['吐く・便が悪くなる'] >= 8) return '吐く・便が悪くなる';
            if (scores['吐き戻し・便の改善'] >= 8) return '吐き戻し・便の改善';
            
            // 第3段階: 食事関連（スコア重視・強化版）
            if (scores['食べない'] >= 10) return '食べない';
            if (scores['食べる'] >= 10) return '食べる';
            if (scores['食べない'] >= 8) return '食べない';
            if (scores['食べる'] >= 8) return '食べる';
            
            // 第4段階: 価格関連（厳格判定）
            if (scores['値上がり/高い'] >= 10) return '値上がり/高い';
            if (scores['安い'] >= 10) return '安い';
            
            // 第5段階: 積極的分類（閾値を大幅に下げる）
            const maxScore = Math.max(...Object.values(scores));
            if (maxScore >= 6) {
                return getTopScoringLabelHierarchical(scores);
            }
            if (maxScore >= 4) {
                return getTopScoringLabelHierarchical(scores);
            }
            if (maxScore >= 2) {
                return getTopScoringLabelHierarchical(scores);
            }
            
            return 'その他';
        }

        // 🤖 OpenAI API統合: 新しい完全版ラベル検出
        async function detectLabelsFromConfigV2(reviewText) {
            if (!reviewText) return 'その他';
            
            // OpenAI APIを使用した分類
            return await detectLabels(reviewText);
        }

        // 🎯 新機能: キーワードスコアリング関数（Phase 2用）
        function addScoresByKeywords(text, scores, weight = 1.0) {
            const lowerText = text.toLowerCase();
            
            // 食べる関連
            const eatPatterns = {
                strong: [
                    /喜んで.{0,20}(完食|食べ)/,
                    /飛び付いて.{0,20}食べ/,
                    /(バクバク|がっつ[きく]).{0,10}食べ/,
                    /美味しそう.{0,10}食べ/
                ],
                medium: [
                    /完食/, /よく食べ/, /美味しい/, /おいしい/,
                    /気に入[っり]/, /大好き/, /お気に入り/
                ]
            };
            
            eatPatterns.strong.forEach(pattern => {
                if (lowerText.match(pattern)) scores['食べる'] += 10 * weight;
            });
            eatPatterns.medium.forEach(pattern => {
                if (lowerText.match(pattern)) scores['食べる'] += 5 * weight;
            });
            
            // 食べない関連
            const noEatPatterns = {
                strong: [
                    /全く食べない/, /見向きもしない/, /拒否.{0,10}する/
                ],
                medium: [
                    /食べ(て)?くれな[いか]/, /残して/, /口にしな[いか]/
                ],
                exclusions: [
                    /(今まで|以前|これまで).{0,50}食べ.*な[いか]/  // 過去の話は除外
                ]
            };
            
            // 除外パターンチェック
            const hasExclusion = noEatPatterns.exclusions.some(pattern => 
                lowerText.match(pattern));
            
            if (!hasExclusion) {
                noEatPatterns.strong.forEach(pattern => {
                    if (lowerText.match(pattern)) scores['食べない'] += 10 * weight;
                });
                noEatPatterns.medium.forEach(pattern => {
                    if (lowerText.match(pattern)) scores['食べない'] += 5 * weight;
                });
            }
            
            // 健康関連（改善）
            if (lowerText.match(/(吐|嘔吐).{0,20}(減[ったり]|なくな[ったり]|改善)/)) {
                scores['吐き戻し・便の改善'] += 8 * weight;
            }
            if (lowerText.match(/便.{0,20}(良[くい]な[ったり]|改善|快調)/)) {
                scores['吐き戻し・便の改善'] += 8 * weight;
            }
            
            // 健康関連（悪化）
            if (lowerText.match(/吐[くいた]|下痢|軟便|血便/) && 
                !lowerText.match(/(減[ったり]|改善|良くな)/)) {
                scores['吐く・便が悪くなる'] += 8 * weight;
            }
            
            // 配送・梱包関連
            if (lowerText.match(/配送|梱包|発送|届[きいくけ]|箱|包装|配達/)) {
                scores['配送・梱包'] += 8 * weight;
            }
            
            // 価格関連
            if (lowerText.match(/値上[げがり]|高[いくめ]|たか[いくめ]|高価/)) {
                scores['値上がり/高い'] += 8 * weight;
            }
            if (lowerText.match(/安[いくめ]|やす[いくめ]|お得|コスパ|手頃/)) {
                scores['安い'] += 8 * weight;
            }
            
            // 賞味期限関連
            if (lowerText.match(/賞味期限|消費期限|期限|日付/)) {
                scores['賞味期限'] += 8 * weight;
            }
            
            // ジッパー関連
            if (lowerText.match(/ジッパー|チャック|密封|ジップ|保存.{0,10}(不便|困)/)) {
                scores['ジッパー'] += 8 * weight;
            }
            
            return scores;
        }

        // 🎯 新機能: スコアリングシステム
        function calculateLabelScores(reviewText, context = null) {
            const scores = {
                '食べる': 0,
                '食べない': 0,
                '吐き戻し・便の改善': 0,
                '吐く・便が悪くなる': 0,
                '安い': 0,
                '配送・梱包': 0,
                '値上がり/高い': 0,
                '賞味期限': 0,
                'ジッパー': 0,
                'その他': 0
            };
            
            // 文脈分析結果を考慮したスコアリング
            if (context && context.timelineDetected) {
                // 現在の商品に関する内容を高く評価（重み 3.0）
                context.currentContext.forEach(ctx => {
                    addScoresByKeywords(ctx.sentence, scores, 3.0);
                });
                
                // 過去の話は低く評価（重み 0.3）
                context.pastContext.forEach(ctx => {
                    addScoresByKeywords(ctx.sentence, scores, 0.3);
                });
                
                // 残りの文章は通常重み（重み 1.0）
                const processedIndices = [
                    ...context.currentContext.map(c => c.index),
                    ...context.pastContext.map(c => c.index)
                ];
                
                const remainingSentences = reviewText.split(/[。！？\n]/)
                    .filter((_, index) => !processedIndices.includes(index))
                    .join('。');
                    
                if (remainingSentences) {
                    addScoresByKeywords(remainingSentences, scores, 1.0);
                }
            } else {
                // 通常のスコアリング
                addScoresByKeywords(reviewText, scores, 1.0);
            }
            
            return scores;
        }

        // 🎯 新機能: ハイブリッドシステム（Phase 2実装）
        function detectLabelsHybrid(reviewText) {
            if (!reviewText) return 'その他';
            
            // Step 1: 明確なカテゴリをまず判定（優先度順）
            const explicitCategories = detectLabels(reviewText);
            
            // Step 2: 「その他」以外なら従来版の結果を採用
            if (explicitCategories !== 'その他') {
                return explicitCategories;
            }
            
            // Step 3: 文脈分析を活用したスコアリング
            const context = analyzeReviewContext(reviewText);
            const scores = calculateLabelScores(reviewText, context);
            
            // Step 4: 一定スコア以上なら最高スコアのラベルを採用
            const maxScore = Math.max(...Object.values(scores));
            if (maxScore >= 3) {  // 閾値を3に設定
                const topLabels = Object.entries(scores)
                    .filter(([_, score]) => score === maxScore);
                return topLabels[0][0];
            }
            
            // Step 5: それでも判定できない場合のみ「その他」
            return 'その他';
        }

        // 🎯 新機能: 改良版ラベル検出
        function detectLabelsEnhanced(reviewText, context) {
            const scores = calculateLabelScores(reviewText, context);
            
            // 最高スコアのラベルを選択
            const maxScore = Math.max(...Object.values(scores));
            
            if (maxScore === 0) return 'その他';
            
            const topLabels = Object.entries(scores)
                .filter(([_, score]) => score === maxScore)
                .map(([label, _]) => label);
            
            // 同点の場合の優先順位
            const priority = [
                '配送・梱包', '賞味期限', 'ジッパー',  // 明確な対象があるものを優先
                '吐く・便が悪くなる', '吐き戻し・便の改善',  // 健康関連
                '食べない', '食べる',  // 食いつき関連
                '値上がり/高い', '安い',  // 価格関連
                'その他'
            ];
            
            return priority.find(label => topLabels.includes(label)) || 'その他';
        }

        // 🎯 高精度化: メイン関数の更新
        function detectLabelsFromConfig(reviewText) {
            if (!reviewText) return 'その他';
            
            // 文脈分析
            const context = analyzeReviewContext(reviewText);
            
            // カスタム設定がある場合
            if (labelConfig.length > 0) {
                const scores = calculateLabelScores(reviewText, context);
                
                // カスタムパターンマッチング（優先度考慮）
                for (const config of labelConfig) {
                    if (config.patterns.length === 0) continue;
                    
                    let patternScore = 0;
                    const text = String(reviewText).toLowerCase();
                    
                    for (const pattern of config.patterns) {
                        try {
                            if (text.match(new RegExp(pattern, 'i'))) {
                                patternScore += 5;
                            }
                        } catch (e) {
                            console.warn(`無効な正規表現: ${pattern}`, e);
                        }
                    }
                    
                    // スコアとパターンマッチを組み合わせて判定
                    if (patternScore > 0 && scores[config.name] >= 3) {
                        return config.name;
                    }
                }
            }
            
            // デフォルト判定（改良版）
            return detectLabelsEnhanced(reviewText, context);
        }

        // 🤖 OpenAI API統合: 新しい分類関数（カスタムカテゴリ対応）
        async function detectLabels(reviewText) {
            if (!reviewText) return 'その他';
            
            try {
                // UIからカテゴリのみ取得
                const categoryInput = document.getElementById('categoryInput');
                const customCategories = categoryInput.value.trim().split('\n').filter(cat => cat.trim());
                
                const response = await fetch('/api/classify', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        review: reviewText,
                        type: 'classification',
                        categories: customCategories // カスタムカテゴリのみ送信
                    })
                });

                if (!response.ok) {
                    console.error('API error:', await response.text());
                    return 'その他';
                }

                const data = await response.json();
                return data.category || 'その他';
            } catch (error) {
                console.error('Classification error:', error);
                return 'その他';
            }
        }

        // 🤖 OpenAI API統合: 新しいセンチメント分析関数
        async function analyzeSentimentOpenAI(reviewText) {
            if (!reviewText) return { label: 'Neutral', score: 0, reason: '空のテキスト' };
            
            try {
                const response = await fetch('/api/classify', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        review: reviewText,
                        type: 'sentiment'
                    })
                });

                if (!response.ok) {
                    console.error('Sentiment API error:', await response.text());
                    return { label: 'Neutral', score: 0, reason: 'API エラー' };
                }

                const data = await response.json();
                return {
                    label: data.sentiment || 'Neutral',
                    score: data.score || 0,
                    reason: data.reason || '分析完了'
                };
            } catch (error) {
                console.error('Sentiment analysis error:', error);
                return { label: 'Neutral', score: 0, reason: 'エラー発生' };
            }
        }

        function analyzeSentiment(reviewText) {
            if (!reviewText) {
                return {
                    label: 'ニュートラル',
                    score: 50,
                    reason: 'レビューテキストが空のため判定不可'
                };
            }
            
            const text = String(reviewText);
            let score = 50;
            const reasons = [];
            
            if (text.match(/食べ[るてたり](?!な)|美味[しそ]|おいし|喜んで|バクバク|完食|よく食べ|大好き/)) {
                score += 15;
                reasons.push('食いつきが良い');
            }
            if (text.match(/満足|良[いくかけ](?!な)|気に入|お気に入り|リピート|また買|定番|ずっと/)) {
                score += 10;
                reasons.push('満足度が高い');
            }
            if (text.match(/(吐|嘔吐).{0,20}(減|なくなった|改善)|便.{0,20}良|健康|元気|調子.{0,5}良/)) {
                score += 15;
                reasons.push('健康面での改善');
            }
            if (text.match(/安[いくめ]|やす[いくめ]|お得|コスパ|手頃/)) {
                score += 10;
                reasons.push('価格満足度が高い');
            }
            if (text.match(/毛並み.{0,10}(良|綺麗|ツヤ|サラサラ)|毛艶|毛.{0,5}ツヤツヤ/)) {
                score += 10;
                reasons.push('毛並みの改善');
            }
            
            if (text.match(/食べ(てくれ)?な[いかくけ]|拒否|残[すし]/)) {
                score -= 20;
                reasons.push('食いつきが悪い');
            }
            if (text.match(/吐[くいたけ]|嘔吐|下痢|軟便|便.{0,5}悪/) && !text.match(/(減|なくなった|改善)/)) {
                score -= 15;
                reasons.push('体調不良の発生');
            }
            if (text.match(/高[いくめ]|たか[いくめ]|値上[げがり]/)) {
                score -= 10;
                reasons.push('価格への不満');
            }
            if (text.match(/残念|がっかり|期待はずれ|ダメ|最悪|二度と|もう買わない/)) {
                score -= 15;
                reasons.push('期待との乖離');
            }
            
            score = Math.max(0, Math.min(100, score));
            
            let label = 'ニュートラル';
            if (score >= 70) label = 'ポジティブ';
            else if (score <= 30) label = 'ネガティブ';
            
            let reason = '';
            if (reasons.length > 0) {
                reason = reasons.join('、') + 'ため。';
            } else {
                reason = '特定の評価要素が見当たらないため中立的と判定。';
            }
            
            return {
                label: label,
                score: score,
                reason: reason
            };
        }

        function generateAndShowSentimentSummary() {
            const positive = sentimentDataList.filter(s => s.label === 'ポジティブ').length;
            const negative = sentimentDataList.filter(s => s.label === 'ネガティブ').length;
            const neutral = sentimentDataList.filter(s => s.label === 'ニュートラル').length;
            const total = sentimentDataList.length;
            
            let summaryHTML = `
                <p><strong>総レビュー数:</strong> ${total}件</p>
                <p><strong>ポジティブ:</strong> ${positive}件 (${(positive/total*100).toFixed(1)}%)</p>
                <p><strong>ネガティブ:</strong> ${negative}件 (${(negative/total*100).toFixed(1)}%)</p>
                <p><strong>ニュートラル:</strong> ${neutral}件 (${(neutral/total*100).toFixed(1)}%)</p>
                <h4>主な傾向:</h4>
                <ul>
            `;
            
            if (positive > negative * 2) {
                summaryHTML += '<li>全体的に好評価が多く、製品に対する満足度が高い傾向にあります。</li>';
            }
            if (negative > positive * 2) {
                summaryHTML += '<li>改善が必要な点が多く見受けられます。</li>';
            }
            if (Math.abs(positive - negative) < total * 0.1) {
                summaryHTML += '<li>評価が分かれており、個体差や好みの違いが大きいようです。</li>';
            }
            
            const positiveReasons = {};
            sentimentDataList.filter(s => s.label === 'ポジティブ').forEach(s => {
                if (s.reason.includes('食いつきが良い')) positiveReasons['食いつき'] = (positiveReasons['食いつき'] || 0) + 1;
                if (s.reason.includes('健康面での改善')) positiveReasons['健康改善'] = (positiveReasons['健康改善'] || 0) + 1;
                if (s.reason.includes('価格満足度')) positiveReasons['価格'] = (positiveReasons['価格'] || 0) + 1;
            });
            
            if (Object.keys(positiveReasons).length > 0) {
                summaryHTML += '<li>ポジティブ評価の主な要因：';
                const topReasons = Object.entries(positiveReasons).sort((a, b) => b[1] - a[1]).slice(0, 3);
                summaryHTML += topReasons.map(([reason, count]) => `${reason}(${count}件)`).join('、');
                summaryHTML += '</li>';
            }
            
            summaryHTML += '</ul>';
            
            document.getElementById('sentimentContent').innerHTML = summaryHTML;
            document.getElementById('sentimentSummary').style.display = 'block';
        }

        // A/Bテスト用データ保存
        let abTestResults = {
            traditional: [],
            enhanced: []
        };
        
        // データ処理メイン関数 - Phase 4完全版を適用
        async function processData() {
            const statusDiv = document.getElementById('status');
            const processBtn = document.getElementById('processBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            const visualizeBtn = document.getElementById('visualizeBtn');
            const abTestEnabled = document.getElementById('enableAbTest').checked;
            
            try {
                processBtn.disabled = true;
                statusDiv.textContent = 'ファイルを読み込み中...';
                
                const rawReviewFile = Object.values(uploadedFiles).find(file => 
                    file.name.toLowerCase().includes('raw_review') || file.name.toLowerCase().includes('review')
                );
                
                if (!rawReviewFile) {
                    throw new Error('レビューデータファイルが見つかりません');
                }
                
                const rawWorkbook = XLSX.read(rawReviewFile.data);
                const rawSheet = rawWorkbook.Sheets[rawWorkbook.SheetNames[0]];
                rawData = XLSX.utils.sheet_to_json(rawSheet, { header: 1 });
                
                statusDiv.textContent = `データを処理中... (総行数: ${rawData.length - 1})`;
                
                console.log('ヘッダー:', rawData[0]);
                console.log('1行目データ:', rawData[1]);
                console.log('2行目データ:', rawData[2]);
                
                let headers = [...rawData[0], 'ラベル', '年', '月', '年月', 'クォーター', 'センチメント（ラベル）', 'センチメント（スコア）', 'センチメント（理由）'];
                if (abTestEnabled) {
                    headers.push('T列_従来版ラベル', 'U列_比較結果');
                }
                processedData = [headers];
                
                sentimentDataList = [];
                abTestResults = { traditional: [], enhanced: [] };
                
                const batchSize = 100;
                const totalRows = rawData.length - 1;
                
                for (let i = 1; i < rawData.length; i++) {
                    const row = rawData[i];
                    
                    const reviewDate = row[1];
                    const reviewText = row[10];
                    
                    if (i <= 5) {
                        console.log(`${i}行目 - 日付:`, reviewDate, 'レビュー:', reviewText?.substring(0, 50));
                    }
                    
                    const dateInfo = parseDate(reviewDate);
                    
                    // 🤖 OpenAI API統合: 新しいシステム適用
                    const enhancedLabels = await detectLabelsFromConfigV2(reviewText);
                    const sentimentData = await analyzeSentimentOpenAI(reviewText);
                    
                    // P列：クォーター, Q列：センチメント（ラベル）, R列：センチメント（スコア）, S列：センチメント（理由）
                    let newRow = [...row, enhancedLabels, dateInfo.year, dateInfo.month, dateInfo.yearMonth, dateInfo.quarter, sentimentData.label, sentimentData.score, sentimentData.reason];
                    
                    // A/Bテストモード (現在は無効)
                    if (abTestEnabled) {
                        const traditionalLabels = 'OpenAI統合により無効';
                        const comparisonResult = 'OpenAI統合により無効';
                        
                        newRow.push(traditionalLabels, comparisonResult);
                        
                        abTestResults.traditional.push(traditionalLabels);
                        abTestResults.enhanced.push(enhancedLabels);
                    }
                    
                    processedData.push(newRow);
                    sentimentDataList.push(sentimentData);
                    
                    if (i % batchSize === 0) {
                        statusDiv.textContent = `処理中... ${i}/${totalRows} (${Math.round(i/totalRows*100)}%)`;
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                }
                
                let statusMessage = `処理完了！Phase 5.2: 教師データ準拠版+過剰分類・検出不足修正済み`;
                if (abTestEnabled) {
                    statusMessage += ` | A/Bテスト実行済み`;
                }
                statusDiv.innerHTML = `<span class="success">${statusMessage}</span>`;
                
                downloadBtn.disabled = false;
                visualizeBtn.disabled = false;
                
                // 分析データの準備
                prepareAnalysisData();
                
                showStatistics();
                generateAndShowSentimentSummary();
                showSampleResults();
                
                // A/Bテスト結果表示
                if (abTestEnabled) {
                    showAbTestResults();
                }
                
            } catch (error) {
                statusDiv.innerHTML = `<span class="error">エラー: ${error.message}</span>`;
                processBtn.disabled = false;
            }
        }
        
        // A/Bテスト結果表示
        function showAbTestResults() {
            const sampleDiv = document.getElementById('sampleResults');
            let html = '<h3>🧪 A/Bテスト結果</h3>';
            
            // 一致率計算
            const total = abTestResults.traditional.length;
            const matches = abTestResults.traditional.filter((trad, i) => 
                trad === abTestResults.enhanced[i]
            ).length;
            const matchRate = ((matches / total) * 100).toFixed(1);
            
            html += `<p><strong>一致率:</strong> ${matchRate}% (${matches}/${total})</p>`;
            
            // カテゴリ別比較
            const categoryComparison = {};
            abTestResults.traditional.forEach((trad, i) => {
                const enh = abTestResults.enhanced[i];
                const key = `${trad} → ${enh}`;
                categoryComparison[key] = (categoryComparison[key] || 0) + 1;
            });
            
            html += '<p><strong>主な変更パターン:</strong></p><ul>';
            Object.entries(categoryComparison)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .forEach(([pattern, count]) => {
                    if (!pattern.includes(' → ')) return;
                    const [from, to] = pattern.split(' → ');
                    if (from !== to) {
                        html += `<li>${pattern}: ${count}件</li>`;
                    }
                });
            html += '</ul>';
            
            sampleDiv.innerHTML = html + sampleDiv.innerHTML;
        }

        // 新機能: 分析データの準備
        function prepareAnalysisData() {
            analysisData = {
                monthlyData: {},
                labelData: {},
                sentimentData: {},
                quarterlyData: {},
                heatmapData: {}
            };

            const allLabels = new Set();
            const allMonths = new Set();

            for (let i = 1; i < processedData.length; i++) {
                const row = processedData[i];
                const yearMonth = row[14]; // O列
                const label = row[11]; // L列
                const quarter = row[16]; // Q列
                const sentimentText = row[15]; // P列

                if (yearMonth && label) {
                    allMonths.add(yearMonth);
                    allLabels.add(label);

                    // 月別データ
                    if (!analysisData.monthlyData[yearMonth]) {
                        analysisData.monthlyData[yearMonth] = {};
                    }
                    if (!analysisData.monthlyData[yearMonth][label]) {
                        analysisData.monthlyData[yearMonth][label] = 0;
                    }
                    analysisData.monthlyData[yearMonth][label]++;

                    // ラベル合計
                    if (!analysisData.labelData[label]) {
                        analysisData.labelData[label] = 0;
                    }
                    analysisData.labelData[label]++;

                    // クォーター別
                    if (quarter) {
                        if (!analysisData.quarterlyData[quarter]) {
                            analysisData.quarterlyData[quarter] = {};
                        }
                        if (!analysisData.quarterlyData[quarter][label]) {
                            analysisData.quarterlyData[quarter][label] = 0;
                        }
                        analysisData.quarterlyData[quarter][label]++;
                    }

                    // センチメント抽出
                    const sentimentMatch = sentimentText.match(/ラベル: (\w+)/);
                    if (sentimentMatch) {
                        const sentiment = sentimentMatch[1];
                        if (!analysisData.sentimentData[sentiment]) {
                            analysisData.sentimentData[sentiment] = 0;
                        }
                        analysisData.sentimentData[sentiment]++;

                        // ヒートマップデータ
                        const key = `${label}_${sentiment}`;
                        if (!analysisData.heatmapData[key]) {
                            analysisData.heatmapData[key] = 0;
                        }
                        analysisData.heatmapData[key]++;
                    }
                }
            }

            // フィルター選択肢の更新
            updateFilterOptions();
        }

        // フィルター選択肢の更新
        function updateFilterOptions() {
            const labelFilter = document.getElementById('labelFilter');
            labelFilter.innerHTML = '<option value="all">全ラベル</option>';
            
            Object.keys(analysisData.labelData).forEach(label => {
                const option = document.createElement('option');
                option.value = label;
                option.textContent = label;
                labelFilter.appendChild(option);
            });
        }

        // 新機能: 可視化表示の切り替え
        function toggleVisualization() {
            const dashboard = document.getElementById('dashboardSection');
            dashboardVisible = !dashboardVisible;
            
            if (dashboardVisible) {
                dashboard.style.display = 'block';
                document.getElementById('visualizeBtn').textContent = '📊 可視化非表示';
                initializeCharts();
                updateKPIs();
            } else {
                dashboard.style.display = 'none';
                document.getElementById('visualizeBtn').textContent = '📊 可視化表示';
                destroyAllCharts();
            }
        }

        // チャートの初期化
        function initializeCharts() {
            setTimeout(() => {
                createMonthlyTrendChart();
                createLabelDistributionChart();
                createSentimentChart();
                createQuarterlyChart();
                createHeatmapTable();
            }, 100);
        }

        // すべてのチャートを削除
        function destroyAllCharts() {
            Object.values(charts).forEach(chart => {
                if (chart && typeof chart.destroy === 'function') {
                    chart.destroy();
                }
            });
            charts = {};
        }

        // KPI更新
        function updateKPIs() {
            const total = processedData.length - 1;
            const positive = sentimentDataList.filter(s => s.label === 'ポジティブ').length;
            const positiveRate = ((positive / total) * 100).toFixed(1);
            
            const labelCounts = Object.entries(analysisData.labelData).sort((a, b) => b[1] - a[1]);
            const topLabel = labelCounts[0] ? labelCounts[0][0] : '-';
            const topLabelCount = labelCounts[0] ? labelCounts[0][1] : 0;
            
            const avgScore = (sentimentDataList.reduce((sum, s) => sum + s.score, 0) / sentimentDataList.length).toFixed(1);

            document.getElementById('totalReviews').textContent = total;
            document.getElementById('positiveRate').textContent = positiveRate + '%';
            document.getElementById('topLabel').textContent = topLabel;
            document.getElementById('avgScore').textContent = avgScore;

            // トレンド表示（簡単な実装）
            document.getElementById('reviewsTrend').textContent = `${total}件`;
            document.getElementById('reviewsTrend').className = 'trend-indicator trend-stable';
            
            document.getElementById('positiveTrend').textContent = `${positive}件`;
            document.getElementById('positiveTrend').className = `trend-indicator ${positiveRate > 60 ? 'trend-up' : positiveRate < 40 ? 'trend-down' : 'trend-stable'}`;
            
            document.getElementById('topLabelCount').textContent = `${topLabelCount}件`;
            document.getElementById('topLabelCount').className = 'trend-indicator trend-stable';
            
            document.getElementById('scoreTrend').textContent = `全体平均`;
            document.getElementById('scoreTrend').className = `trend-indicator ${avgScore > 60 ? 'trend-up' : avgScore < 40 ? 'trend-down' : 'trend-stable'}`;
        }

        // 月別推移チャート
        function createMonthlyTrendChart() {
            const ctx = document.getElementById('monthlyTrendChart').getContext('2d');
            
            const months = Object.keys(analysisData.monthlyData).sort();
            const datasets = [];
            
            // 上位5ラベルのみ表示
            const topLabels = Object.entries(analysisData.labelData)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([label]) => label);
            
            const colors = [
                '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF'
            ];
            
            topLabels.forEach((label, index) => {
                const data = months.map(month => analysisData.monthlyData[month][label] || 0);
                datasets.push({
                    label: label,
                    data: data,
                    borderColor: colors[index],
                    backgroundColor: colors[index] + '20',
                    fill: document.getElementById('chartType').value === 'area'
                });
            });

            if (charts.monthlyTrend) {
                charts.monthlyTrend.destroy();
            }

            charts.monthlyTrend = new Chart(ctx, {
                type: document.getElementById('chartType').value === 'bar' ? 'bar' : 'line',
                data: {
                    labels: months,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // ラベル分布チャート
        function createLabelDistributionChart() {
            const ctx = document.getElementById('labelDistributionChart').getContext('2d');
            
            const labels = Object.keys(analysisData.labelData);
            const data = Object.values(analysisData.labelData);
            
            if (charts.labelDistribution) {
                charts.labelDistribution.destroy();
            }

            charts.labelDistribution = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: [
                            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
                            '#FF9F40', '#C9CBCF', '#4BC0C0', '#FF6384', '#36A2EB'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                        }
                    }
                }
            });
        }

        // センチメントチャート
        function createSentimentChart() {
            const ctx = document.getElementById('sentimentChart').getContext('2d');
            
            if (charts.sentiment) {
                charts.sentiment.destroy();
            }

            charts.sentiment = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: Object.keys(analysisData.sentimentData),
                    datasets: [{
                        data: Object.values(analysisData.sentimentData),
                        backgroundColor: ['#4CAF50', '#F44336', '#FF9800']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                        }
                    }
                }
            });
        }

        // クォーター別チャート
        function createQuarterlyChart() {
            const ctx = document.getElementById('quarterlyChart').getContext('2d');
            
            const quarters = Object.keys(analysisData.quarterlyData).sort();
            const datasets = [];
            
            const topLabels = Object.entries(analysisData.labelData)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([label]) => label);
            
            const colors = [
                '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF'
            ];
            
            topLabels.forEach((label, index) => {
                const data = quarters.map(quarter => analysisData.quarterlyData[quarter][label] || 0);
                datasets.push({
                    label: label,
                    data: data,
                    backgroundColor: colors[index]
                });
            });

            if (charts.quarterly) {
                charts.quarterly.destroy();
            }

            charts.quarterly = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: quarters,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                        },
                        y: {
                            stacked: true,
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // ヒートマップテーブル
        function createHeatmapTable() {
            const container = document.getElementById('heatmapTable');
            const labels = Object.keys(analysisData.labelData);
            const sentiments = ['ポジティブ', 'ネガティブ', 'ニュートラル'];
            
            let html = '<tr><th>ラベル</th>';
            sentiments.forEach(sentiment => {
                html += `<th>${sentiment}</th>`;
            });
            html += '</tr>';
            
            labels.forEach(label => {
                html += `<tr><td style="font-weight: bold; padding: 8px; border: 1px solid #ddd;">${label}</td>`;
                sentiments.forEach(sentiment => {
                    const key = `${label}_${sentiment}`;
                    const count = analysisData.heatmapData[key] || 0;
                    const total = analysisData.labelData[label] || 1;
                    const percentage = ((count / total) * 100).toFixed(1);
                    
                    let bgColor = '#f5f5f5';
                    if (sentiment === 'ポジティブ' && percentage > 50) bgColor = '#c8e6c9';
                    else if (sentiment === 'ネガティブ' && percentage > 30) bgColor = '#ffcdd2';
                    else if (sentiment === 'ニュートラル' && percentage > 40) bgColor = '#e1f5fe';
                    
                    html += `<td style="padding: 8px; border: 1px solid #ddd; background-color: ${bgColor}; text-align: center;">
                        ${count}<br><small>${percentage}%</small>
                    </td>`;
                });
                html += '</tr>';
            });
            
            container.innerHTML = html;
        }

        // チャート更新
        function updateCharts() {
            if (dashboardVisible) {
                destroyAllCharts();
                initializeCharts();
            }
        }

        function showStatistics() {
            const statsDiv = document.getElementById('stats');
            const statsContent = document.getElementById('statsContent');
            
            const yearMonthStats = {};
            const labelStats = {};
            
            for (let i = 1; i < processedData.length; i++) {
                const yearMonth = processedData[i][14];
                const labels = processedData[i][11];
                
                if (yearMonth) {
                    yearMonthStats[yearMonth] = (yearMonthStats[yearMonth] || 0) + 1;
                }
                
                if (labels) {
                    labelStats[labels] = (labelStats[labels] || 0) + 1;
                }
            }
            
            let html = '<p><strong>総レビュー数:</strong> ' + (processedData.length - 1) + '</p>';
            html += '<p><strong>期間:</strong> ' + Object.keys(yearMonthStats).sort()[0] + ' ～ ' + 
                    Object.keys(yearMonthStats).sort().slice(-1)[0] + '</p>';
            
            if (labelConfig.length > 0) {
                html += `<p><strong>ラベル設定:</strong> カスタム設定（${labelConfig.length}件）</p>`;
            } else {
                html += '<p><strong>ラベル設定:</strong> デフォルト設定</p>';
            }
            
            html += '<p><strong>🚀 Phase 3:</strong> 強化版スコアリングシステム完全版適用済み（90%+ 精度）</p>';
            
            html += '<p><strong>ラベル別件数:</strong></p><ul>';
            Object.entries(labelStats).sort((a, b) => b[1] - a[1]).forEach(([label, count]) => {
                html += `<li>${label}: ${count}件</li>`;
            });
            html += '</ul>';
            
            statsContent.innerHTML = html;
            statsDiv.style.display = 'block';
        }

        function showSampleResults() {
            const sampleDiv = document.getElementById('sampleResults');
            const sampleContent = document.getElementById('sampleContent');
            
            let html = '';
            for (let i = 1; i <= 5 && i < processedData.length; i++) {
                const row = processedData[i];
                const sentimentLines = row[15].split('\\n');
                html += `<div class="result-item">
                    <strong>レビュー:</strong> ${String(row[10]).substring(0, 100)}...<br>
                    <strong>ラベル:</strong> ${row[11]}<br>
                    <strong>年月:</strong> ${row[14]}<br>
                    <strong>センチメント分析:</strong><br>
                    ${sentimentLines.map(line => `&nbsp;&nbsp;${line}`).join('<br>')}
                </div>`;
            }
            
            sampleContent.innerHTML = html;
            sampleDiv.style.display = 'block';
        }

        function downloadExcel() {
            if (!processedData) return;
            
            const wb = XLSX.utils.book_new();
            const ws1 = XLSX.utils.aoa_to_sheet(processedData);
            XLSX.utils.book_append_sheet(wb, ws1, 'レビューデータ');
            
            const statsData = createStatisticsSheet();
            const ws2 = XLSX.utils.aoa_to_sheet(statsData);
            XLSX.utils.book_append_sheet(wb, ws2, '統計分析');
            
            const sentimentSummaryData = createSentimentSummarySheet();
            const ws3 = XLSX.utils.aoa_to_sheet(sentimentSummaryData);
            XLSX.utils.book_append_sheet(wb, ws3, 'センチメント分析');
            
            XLSX.writeFile(wb, 'ペットフードレビュー分析結果_Phase3_完全版.xlsx');
        }

        function createStatisticsSheet() {
            const statsData = [['ペットフードレビュー分析結果 - 統計分析（Phase 3: 強化版完全版）']];
            statsData.push([]);
            
            const yearMonthLabelCounts = {};
            const quarterLabelCounts = {};
            const yearMonthTotals = {};
            const quarterTotals = {};
            
            const allLabels = new Set(labelConfig.length > 0 ? 
                labelConfig.map(c => c.name) : masterLabels);
            const allYearMonths = new Set();
            const allQuarters = new Set();
            
            for (let i = 1; i < processedData.length; i++) {
                const yearMonth = processedData[i][14];
                const quarter = processedData[i][16];
                const label = processedData[i][11];
                
                if (yearMonth && label) {
                    allYearMonths.add(yearMonth);
                    yearMonthTotals[yearMonth] = (yearMonthTotals[yearMonth] || 0) + 1;
                    
                    if (!yearMonthLabelCounts[yearMonth]) {
                        yearMonthLabelCounts[yearMonth] = {};
                    }
                    
                    yearMonthLabelCounts[yearMonth][label] = 
                        (yearMonthLabelCounts[yearMonth][label] || 0) + 1;
                }
                
                if (quarter && label) {
                    allQuarters.add(quarter);
                    quarterTotals[quarter] = (quarterTotals[quarter] || 0) + 1;
                    
                    if (!quarterLabelCounts[quarter]) {
                        quarterLabelCounts[quarter] = {};
                    }
                    
                    quarterLabelCounts[quarter][label] = 
                        (quarterLabelCounts[quarter][label] || 0) + 1;
                }
            }
            
            const sortedYearMonths = Array.from(allYearMonths).sort();
            const sortedQuarters = Array.from(allQuarters).sort();
            const sortedLabels = Array.from(allLabels);
            
            statsData.push(['【表1】年月ごとの実数推移']);
            statsData.push(['ラベル', ...sortedYearMonths]);
            
            sortedLabels.forEach(label => {
                const row = [label];
                sortedYearMonths.forEach(ym => {
                    row.push(yearMonthLabelCounts[ym] && yearMonthLabelCounts[ym][label] ? yearMonthLabelCounts[ym][label] : 0);
                });
                statsData.push(row);
            });
            
            const totalRow = ['合計'];
            sortedYearMonths.forEach(ym => {
                totalRow.push(yearMonthTotals[ym] || 0);
            });
            statsData.push(totalRow);
            
            statsData.push([]);
            statsData.push([]);
            
            statsData.push(['【表2】年月ごとの割合推移（%）']);
            statsData.push(['ラベル', ...sortedYearMonths]);
            
            sortedLabels.forEach(label => {
                const row = [label];
                sortedYearMonths.forEach(ym => {
                    const count = yearMonthLabelCounts[ym] && yearMonthLabelCounts[ym][label] ? yearMonthLabelCounts[ym][label] : 0;
                    const total = yearMonthTotals[ym] || 1;
                    const percentage = ((count / total) * 100).toFixed(1);
                    row.push(percentage + '%');
                });
                statsData.push(row);
            });
            
            statsData.push([]);
            statsData.push([]);
            
            statsData.push(['【表3】クォーターごとのまとめ']);
            
            statsData.push(['ラベル（実数）', ...sortedQuarters]);
            sortedLabels.forEach(label => {
                const row = [label];
                sortedQuarters.forEach(q => {
                    row.push(quarterLabelCounts[q] && quarterLabelCounts[q][label] ? quarterLabelCounts[q][label] : 0);
                });
                statsData.push(row);
            });
            
            const quarterTotalRow = ['合計'];
            sortedQuarters.forEach(q => {
                quarterTotalRow.push(quarterTotals[q] || 0);
            });
            statsData.push(quarterTotalRow);
            
            statsData.push([]);
            
            statsData.push(['ラベル（割合%）', ...sortedQuarters]);
            sortedLabels.forEach(label => {
                const row = [label];
                sortedQuarters.forEach(q => {
                    const count = quarterLabelCounts[q] && quarterLabelCounts[q][label] ? quarterLabelCounts[q][label] : 0;
                    const total = quarterTotals[q] || 1;
                    const percentage = ((count / total) * 100).toFixed(1);
                    row.push(percentage + '%');
                });
                statsData.push(row);
            });
            
            return statsData;
        }

        function createSentimentSummarySheet() {
            const summaryData = [['センチメント分析サマリー（Phase 3: 強化版完全版）']];
            summaryData.push([]);
            
            const positive = sentimentDataList.filter(s => s.label === 'ポジティブ').length;
            const negative = sentimentDataList.filter(s => s.label === 'ネガティブ').length;
            const neutral = sentimentDataList.filter(s => s.label === 'ニュートラル').length;
            const total = sentimentDataList.length;
            
            summaryData.push(['項目', '件数', '割合']);
            summaryData.push(['総レビュー数', total, '100.0%']);
            summaryData.push(['ポジティブ', positive, `${(positive/total*100).toFixed(1)}%`]);
            summaryData.push(['ネガティブ', negative, `${(negative/total*100).toFixed(1)}%`]);
            summaryData.push(['ニュートラル', neutral, `${(neutral/total*100).toFixed(1)}%`]);
            
            summaryData.push([]);
            summaryData.push(['主な傾向']);
            
            if (positive > negative * 2) {
                summaryData.push(['全体的に好評価が多く、製品に対する満足度が高い傾向にあります。']);
            }
            if (negative > positive * 2) {
                summaryData.push(['改善が必要な点が多く見受けられます。']);
            }
            if (Math.abs(positive - negative) < total * 0.1) {
                summaryData.push(['評価が分かれており、個体差や好みの違いが大きいようです。']);
            }
            
            summaryData.push([]);
            summaryData.push(['月別センチメント推移']);
            
            const monthSentiment = {};
            for (let i = 1; i < processedData.length; i++) {
                const yearMonth = processedData[i][14];
                const sentiment = processedData[i][15];
                
                if (yearMonth && sentiment) {
                    if (!monthSentiment[yearMonth]) {
                        monthSentiment[yearMonth] = {
                            'ポジティブ': 0,
                            'ネガティブ': 0,
                            'ニュートラル': 0
                        };
                    }
                    
                    const sentimentMatch = sentiment.match(/ラベル: (\w+)/);
                    if (sentimentMatch) {
                        monthSentiment[yearMonth][sentimentMatch[1]]++;
                    }
                }
            }
            
            const sortedMonths = Object.keys(monthSentiment).sort();
            summaryData.push(['年月', 'ポジティブ', 'ネガティブ', 'ニュートラル']);
            
            sortedMonths.forEach(month => {
                summaryData.push([
                    month,
                    monthSentiment[month]['ポジティブ'],
                    monthSentiment[month]['ネガティブ'],
                    monthSentiment[month]['ニュートラル']
                ]);
            });
            
            return summaryData;
        }
        
        // ===========================================
        // 🎓 教師データ学習システム
        // ===========================================
        
        /**
         * 🏆 修正版：高精度ペットフードレビュー教師学習システム
         * 教師データから学習して10カテゴリ分類精度を大幅向上
         */
class PetFoodTeacherLearning {
    constructor() {
        // 10固定カテゴリ
        this.categories = [
            '吐く・便が悪くなる',
            '食べない',
            '吐き戻し・便の改善',
            '食べる',
            '値上がり/高い',
            '安い',
            '配送・梱包',
            '賞味期限',
            'ジッパー',
            'その他'
        ];

        // 学習データストレージ
        this.categoryPatterns = {};
        this.wordScores = {};
        this.isLearned = false;
        this.accuracyHistory = [];
        
        // 各カテゴリ初期化
        this.categories.forEach(category => {
            this.categoryPatterns[category] = new Map();
            this.wordScores[category] = new Map();
        });
        
        // モデル読み込み
        this.loadModel();
    }
    
    /**
     * 教師データからパターンを学習
     */
    processTeacherData(teacherData) {
        console.log('🎓 教師データ学習開始:', teacherData.length, '件');
        
        // カテゴリ分布確認
        const categoryStats = {};
        this.categories.forEach(cat => categoryStats[cat] = 0);
        teacherData.forEach(ex => {
            if (categoryStats[ex.category] !== undefined) {
                categoryStats[ex.category]++;
            }
        });
        console.log('📊 カテゴリ分布:', categoryStats);
        
        // 各カテゴリの特徴語を学習
        this.categories.forEach(category => {
            const examples = teacherData.filter(ex => ex.category === category);
            this.learnCategoryFeatures(category, examples, teacherData.length);
        });
        
        this.isLearned = true;
        this.saveModel();
        console.log('✅ 教師データ学習完了');
    }
    
    /**
     * カテゴリ特徴語学習
     */
    learnCategoryFeatures(category, examples, totalExamples) {
        if (examples.length === 0) return;
        
        const wordFreq = new Map();
        const totalWords = new Map();
        
        // 単語頻度計算
        examples.forEach(ex => {
            const words = this.extractWords(ex.text);
            words.forEach(word => {
                wordFreq.set(word, (wordFreq.get(word) || 0) + 1);
                totalWords.set(word, (totalWords.get(word) || 0) + 1);
            });
        });
        
        // TF-IDF風スコア計算
        wordFreq.forEach((freq, word) => {
            const tf = freq / examples.length;
            const categoryOccurrence = this.categories.reduce((count, cat) => {
                return count + (this.wordScores[cat].has(word) ? 1 : 0);
            }, 0);
            const idf = Math.log(this.categories.length / (1 + categoryOccurrence));
            const score = tf * idf;
            
            if (score > 0.1) { // 閾値以上のみ保存
                this.wordScores[category].set(word, score);
            }
        });
        
        // 特徴的なフレーズパターンを学習
        this.learnPhrasePatterns(category, examples);
        
        console.log(`📝 ${category}: ${this.wordScores[category].size}語を学習`);
    }
    
    /**
     * フレーズパターン学習
     */
    learnPhrasePatterns(category, examples) {
        const patterns = new Map();
        
        // カテゴリ特有のフレーズを学習
        examples.forEach(ex => {
            const phrases = this.extractPhrases(ex.text, category);
            phrases.forEach(phrase => {
                patterns.set(phrase, (patterns.get(phrase) || 0) + 1);
            });
        });
        
        // 高頻度フレーズのみ保存
        patterns.forEach((freq, phrase) => {
            if (freq >= 2) {
                this.categoryPatterns[category].set(phrase, freq / examples.length);
            }
        });
    }
    
    /**
     * 単語抽出（日本語特化）
     */
    extractWords(text) {
        const words = [];
        const cleanText = text.toLowerCase().replace(/[！？。、]/g, '');
        
        // 日本語の単語パターンを抽出
        const patterns = [
            /[あ-んア-ンー・]+/g,  // ひらがな・カタカナ
            /[一-龯]+/g,           // 漢字
            /[a-zA-Z]{2,}/g        // 英語
        ];
        
        patterns.forEach(pattern => {
            const matches = cleanText.match(pattern);
            if (matches) {
                matches.forEach(match => {
                    if (match.length >= 2 && !this.isStopWord(match)) {
                        words.push(match);
                    }
                });
            }
        });
        
        return words;
    }
    
    /**
     * フレーズ抽出（カテゴリ特化）
     */
    extractPhrases(text, category) {
        const phrases = [];
        const lowerText = text.toLowerCase();
        
        // カテゴリ特有のフレーズパターン
        const categoryPhrases = {
            '食べる': [
                /食いつき.{0,3}良/g, /よく食べ/g, /美味し/g, /完食/g, /喜んで食べ/g
            ],
            '食べない': [
                /食べ.{0,3}ない/g, /食いつき.{0,3}悪/g, /残し/g, /拒否/g, /見向きもしない/g
            ],
            '吐く・便が悪くなる': [
                /吐く/g, /下痢/g, /軟便/g, /体調不良/g, /お腹を壊/g
            ],
            '吐き戻し・便の改善': [
                /吐.{0,5}なくなった/g, /便.{0,5}良くなった/g, /調子が良/g, /元気になった/g
            ],
            '配送・梱包': [
                /配送/g, /梱包/g, /届いた/g, /箱/g, /破損/g
            ],
            '賞味期限': [
                /賞味期限/g, /期限/g, /日付/g
            ],
            'ジッパー': [
                /ジッパー/g, /チャック/g, /密封/g
            ],
            '値上がり/高い': [
                /値上がり/g, /高い/g, /値段が上が/g
            ],
            '安い': [
                /安い/g, /お得/g, /コスパ/g
            ]
        };
        
        if (categoryPhrases[category]) {
            categoryPhrases[category].forEach(pattern => {
                const matches = lowerText.match(pattern);
                if (matches) {
                    matches.forEach(match => phrases.push(match));
                }
            });
        }
        
        return phrases;
    }
    
    /**
     * ストップワード判定
     */
    isStopWord(word) {
        const stopWords = ['です', 'した', 'して', 'ある', 'いる', 'この', 'その', 'それ', 'から', 'まで', 'など'];
        return stopWords.includes(word) || word.length < 2;
    }
    
    /**
     * テキスト分類（学習後）
     */
    classifyText(text) {
        if (!this.isLearned) {
            return { category: 'その他', score: 0, confidence: 0 };
        }
        
        const scores = {};
        this.categories.forEach(cat => scores[cat] = 0);
        
        const words = this.extractWords(text);
        
        // 学習した単語スコアを適用
        this.categories.forEach(category => {
            let categoryScore = 0;
            
            // 単語スコア
            words.forEach(word => {
                const wordScore = this.wordScores[category].get(word) || 0;
                categoryScore += wordScore * 10;
            });
            
            // フレーズパターンスコア
            const phrases = this.extractPhrases(text, category);
            phrases.forEach(phrase => {
                const phraseScore = this.categoryPatterns[category].get(phrase) || 0;
                categoryScore += phraseScore * 15;
            });
            
            scores[category] = categoryScore;
        });
        
        // 最高スコアのカテゴリを選択
        let bestCategory = 'その他';
        let bestScore = 0;
        
        Object.entries(scores).forEach(([category, score]) => {
            if (score > bestScore) {
                bestScore = score;
                bestCategory = category;
            }
        });
        
        // 信頼度計算
        const totalScore = Object.values(scores).reduce((a, b) => a + b, 0);
        const confidence = totalScore > 0 ? bestScore / totalScore : 0;
        
        return {
            category: bestCategory,
            score: bestScore,
            confidence: confidence,
            allScores: scores
        };
    }
    
    /**
     * ユーザーフィードバックから学習
     */
    learnFromFeedback(text, correctCategory, predictedCategory) {
        if (!this.categories.includes(correctCategory)) return;
        
        // 正解カテゴリの特徴語を強化
        const words = this.extractWords(text);
        words.forEach(word => {
            const currentScore = this.wordScores[correctCategory].get(word) || 0;
            this.wordScores[correctCategory].set(word, currentScore + 0.1);
        });
        
        // 誤答カテゴリの特徴語を減点
        if (predictedCategory !== correctCategory && predictedCategory !== 'その他') {
            words.forEach(word => {
                const currentScore = this.wordScores[predictedCategory].get(word) || 0;
                this.wordScores[predictedCategory].set(word, Math.max(0, currentScore - 0.05));
            });
        }
        
        this.saveModel();
    }
    
    /**
     * モデル保存
     */
    saveModel() {
        const model = {
            isLearned: this.isLearned,
            wordScores: this.serializeMapStructure(this.wordScores),
            categoryPatterns: this.serializeMapStructure(this.categoryPatterns),
            accuracyHistory: this.accuracyHistory,
            timestamp: new Date().toISOString()
        };
        
        localStorage.setItem('petFoodTeacherModel', JSON.stringify(model));
    }
    
    /**
     * モデル読み込み
     */
    loadModel() {
        const savedModel = localStorage.getItem('petFoodTeacherModel');
        if (!savedModel) return;
        
        try {
            const model = JSON.parse(savedModel);
            
            this.isLearned = model.isLearned || false;
            this.accuracyHistory = model.accuracyHistory || [];
            
            if (model.wordScores) {
                this.wordScores = this.deserializeMapStructure(model.wordScores);
            }
            
            if (model.categoryPatterns) {
                this.categoryPatterns = this.deserializeMapStructure(model.categoryPatterns);
            }
            
            if (this.isLearned) {
                console.log('✅ 学習済みモデルを読み込みました');
            }
        } catch (e) {
            console.error('❌ モデル読み込みエラー:', e);
        }
    }
    
    /**
     * Map構造のシリアライズ
     */
    serializeMapStructure(mapStructure) {
        const serialized = {};
        Object.keys(mapStructure).forEach(key => {
            serialized[key] = Object.fromEntries(mapStructure[key]);
        });
        return serialized;
    }
    
    /**
     * Map構造のデシリアライズ
     */
    deserializeMapStructure(serialized) {
        const mapStructure = {};
        Object.keys(serialized).forEach(key => {
            mapStructure[key] = new Map(Object.entries(serialized[key]));
        });
        return mapStructure;
    }
    
    /**
     * モデルリセット
     */
    resetModel() {
        this.isLearned = false;
        this.accuracyHistory = [];
        this.categories.forEach(category => {
            this.wordScores[category].clear();
            this.categoryPatterns[category].clear();
        });
        localStorage.removeItem('petFoodTeacherModel');
    }
}        
        // Initialize teacher learning system
        let teacherLearningSystem = new PetFoodTeacherLearning();
        
        // 既存の分類関数を強化
        const originalDetectLabelsFromConfigV2 = detectLabelsFromConfigV2;
        
        async function detectLabelsFromConfigV2Enhanced(reviewText) {
            // 教師学習システムが学習済みの場合、その結果を優先
            if (teacherLearningSystem.isLearned) {
                const learningResult = teacherLearningSystem.classifyText(reviewText);
                
                // 高信頼度の場合は学習結果を使用
                if (learningResult.confidence > 0.2 && learningResult.score > 0.5) {
                    console.log(`🎓 学習結果使用: ${learningResult.category} (信頼度: ${learningResult.confidence.toFixed(2)}, スコア: ${learningResult.score.toFixed(2)})`);
                    return learningResult.category;
                }
            }
            
            // OpenAI APIを使用
            const openaiResult = await originalDetectLabelsFromConfigV2(reviewText);
            console.log(`🤖 OpenAI結果使用: ${openaiResult}`);
            return openaiResult;
        }
        
        // 既存の分類関数を置き換え
        detectLabelsFromConfigV2 = detectLabelsFromConfigV2Enhanced;
        
        // 教師データアップロード用UIを追加
        function addTeacherLearningUI() {
            const uiHTML = `
            <div id="teacher-learning-section" style="margin: 20px 0; padding: 20px; border: 2px solid #4CAF50; border-radius: 10px; background-color: #f0f8ff;">
                <h3 style="color: #2c5aa0;">🎓 教師データ学習システム</h3>
                
                <div id="teacher-data-upload" style="margin: 15px 0;">
                    <label for="teacher-file" style="font-weight: bold;">教師データファイル（Excel）をアップロード：</label>
                    <input type="file" id="teacher-file" accept=".xlsx,.xls" style="margin: 10px 0;">
                    <button id="process-teacher-data" style="padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        教師データを処理
                    </button>
                </div>
                
                <div id="model-management" style="margin: 15px 0;">
                    <button id="save-model" style="padding: 8px 15px; margin: 5px; background-color: #2196F3; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        モデルを保存
                    </button>
                    <button id="reset-model" style="padding: 8px 15px; margin: 5px; background-color: #f44336; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        モデルをリセット
                    </button>
                    <button id="export-model" style="padding: 8px 15px; margin: 5px; background-color: #FF9800; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        モデルをエクスポート
                    </button>
                </div>
                
                <div id="learning-status" style="margin: 15px 0; padding: 10px; background-color: #e8f5e9; border-radius: 5px; display: none;">
                    <p style="margin: 0; color: #2e7d32;"></p>
                </div>
                
                <div id="accuracy-display" style="margin: 15px 0; padding: 10px; background-color: #fff3e0; border-radius: 5px; display: none;">
                    <p style="margin: 0; color: #e65100;"><strong>分類精度:</strong> <span id="accuracy-value">-</span></p>
                </div>
            </div>
            `;
            
            // Insert after the main title
            const mainTitle = document.querySelector('h1');
            if (mainTitle) {
                mainTitle.insertAdjacentHTML('afterend', uiHTML);
                setupTeacherLearningListeners();
            }
        }
        
        // イベントリスナーの設定
        function setupTeacherLearningListeners() {
            // 教師データ処理
            document.getElementById('process-teacher-data').addEventListener('click', () => {
                const fileInput = document.getElementById('teacher-file');
                if (fileInput.files.length === 0) {
                    alert('ファイルを選択してください。');
                    return;
                }
                
                processTeacherDataFile(fileInput.files[0]);
            });
            
            // モデル保存
            document.getElementById('save-model').addEventListener('click', () => {
                teacherLearningSystem.saveModel();
                showStatus('モデルが保存されました。');
            });
            
            // モデルリセット
            document.getElementById('reset-model').addEventListener('click', () => {
                if (confirm('モデルをリセットしますか？')) {
                    teacherLearningSystem.resetModel();
                    showStatus('モデルがリセットされました。');
                    // 精度表示をリセット
                    document.getElementById('accuracy-display').style.display = 'none';
                }
            });
            
            // モデルエクスポート
            document.getElementById('export-model').addEventListener('click', () => {
                const modelData = localStorage.getItem('petFoodTeacherModel');
                if (modelData) {
                    const blob = new Blob([modelData], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'pet-food-teacher-model.json';
                    a.click();
                    URL.revokeObjectURL(url);
                    showStatus('モデルがエクスポートされました。');
                } else {
                    alert('エクスポートするモデルがありません。');
                }
            });
        }
        
        // ステータス表示
        function showStatus(message) {
            const statusDiv = document.getElementById('learning-status');
            const statusP = statusDiv.querySelector('p');
            statusP.innerHTML = message.replace(/\n/g, '<br>');
            statusDiv.style.display = 'block';
            
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 5000);
        }
        
        // 精度表示
        function showAccuracy(accuracy) {
            const accuracyDiv = document.getElementById('accuracy-display');
            const accuracyValue = document.getElementById('accuracy-value');
            accuracyValue.textContent = (accuracy * 100).toFixed(1) + '%';
            accuracyDiv.style.display = 'block';
        }
        
        // 教師データファイルの処理
        function processTeacherDataFile(file) {
            showStatus('教師データを処理中...');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const worksheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                    
                    // データをパース（A列：テキスト、B列：ラベル）
                    const teacherData = [];
                    for (let i = 1; i < jsonData.length; i++) {
                        const row = jsonData[i];
                        if (row[0] && row[1]) {
                            const category = String(row[1]).trim();
                            // 10カテゴリのみ受け入れ
                            if (teacherLearningSystem.categories.includes(category)) {
                                teacherData.push({
                                    text: String(row[0]).trim(),
                                    category: category
                                });
                            }
                        }
                    }
                    
                    if (teacherData.length === 0) {
                        alert('有効な教師データが見つかりません。A列：テキスト、B列：ラベルの形式で入力してください。');
                        return;
                    }
                    
                    console.log('📊 教師データ統計:', teacherData.length, '件');
                    
                    // 教師データで学習
                    teacherLearningSystem.processTeacherData(teacherData);
                    
                    // 精度テスト（テスト用データを分割）
                    const testSize = Math.min(100, Math.floor(teacherData.length * 0.2));
                    const testData = teacherData.slice(0, testSize);
                    
                    let correct = 0;
                    let detailResults = [];
                    
                    testData.forEach(example => {
                        const predicted = teacherLearningSystem.classifyText(example.text);
                        const isCorrect = predicted.category === example.category;
                        
                        if (isCorrect) {
                            correct++;
                        }
                        
                        detailResults.push({
                            text: example.text.substring(0, 50),
                            expected: example.category,
                            predicted: predicted.category,
                            confidence: predicted.confidence,
                            correct: isCorrect
                        });
                    });
                    
                    const accuracy = correct / testData.length;
                    
                    // 結果表示
                    showAccuracy(accuracy);
                    showStatus(`✅ 教師データ ${teacherData.length} 件で学習完了。\nテスト精度: ${(accuracy * 100).toFixed(1)}% (${correct}/${testData.length})`);
                    
                    // 詳細結果をコンソールに表示
                    console.log('📊 テスト結果詳細:');
                    console.table(detailResults);
                    
                } catch (error) {
                    console.error('❌ 教師データ処理エラー:', error);
                    alert('教師データの処理中にエラーが発生しました。\nファイル形式を確認してください。');
                }
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        // ページ読み込み時にUIを追加
        document.addEventListener('DOMContentLoaded', function() {
            // 既存の初期化処理を実行してからUIを追加
            setTimeout(() => {
                addTeacherLearningUI();
            }, 100);
        });
    </script>
</body>
</html>
